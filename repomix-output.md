This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where comments have been removed, empty lines have been removed, content has been formatted for parsing in markdown style.

# File Summary

## Purpose
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: **/repomix-output.*, **/bin/**, **/obj/**, **/*.pdb, **/*.lib, **/*.dll, **/*.zip, **/*.exe, **/*.vcxproj*, **/*.filters, **/*.user, **/*.sln, **/Localization/**, UI/**, SevenZip/**, Lua/**, Utilities/**, Linux/**, MacOS/**, Windows/**, Sdl/**, PGOHelper/**, Core/NES/**, Core/SNES/**, Core/Gameboy/**, Core/GBA/**, Core/PCE/**, Core/SMS/**, Core/WS/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Empty lines have been removed from all files
- Content has been formatted for parsing in markdown style
- Files are sorted by Git change count (files with more changes are at the bottom)

# User Provided Header
CONTEXTO DE INFRAESTRUCTURA MCP:
Este repositorio (Mesen2) actúa como el motor de emulación. El control programático, la lectura de memoria y la interacción con LLMs se gestionan mediante el repositorio paralelo 'mesen-mcp-infra'.
Los puntos de entrada clave para el control externo en este repositorio son InteropDLL y Core/Debugger.

# Directory Structure
```
.claude/settings.local.json
.editorconfig
.gitattributes
.github/actions/build-sha1-action/action.yml
.github/actions/setup-ccache-action/action.yml
.github/workflows/build.yml
.gitignore
.repomixignore
buildPGO.sh
COMPILING.md
Core/Core.ruleset
Core/Core.vcxproj
Core/Debugger/AddressInfo.h
Core/Debugger/Base6502Assembler.cpp
Core/Debugger/Base6502Assembler.h
Core/Debugger/BaseEventManager.cpp
Core/Debugger/BaseEventManager.h
Core/Debugger/BaseTraceLogger.h
Core/Debugger/Breakpoint.cpp
Core/Debugger/Breakpoint.h
Core/Debugger/BreakpointManager.cpp
Core/Debugger/BreakpointManager.h
Core/Debugger/CallstackManager.cpp
Core/Debugger/CallstackManager.h
Core/Debugger/CdlManager.cpp
Core/Debugger/CdlManager.h
Core/Debugger/CodeDataLogger.cpp
Core/Debugger/CodeDataLogger.h
Core/Debugger/DebugBreakHelper.h
Core/Debugger/Debugger.cpp
Core/Debugger/Debugger.h
Core/Debugger/DebuggerFeatures.h
Core/Debugger/DebugTypes.h
Core/Debugger/DebugUtilities.h
Core/Debugger/Disassembler.cpp
Core/Debugger/Disassembler.h
Core/Debugger/DisassemblyInfo.cpp
Core/Debugger/DisassemblyInfo.h
Core/Debugger/DisassemblySearch.cpp
Core/Debugger/DisassemblySearch.h
Core/Debugger/ExpressionEvaluator.cpp
Core/Debugger/ExpressionEvaluator.Cx4.cpp
Core/Debugger/ExpressionEvaluator.Gameboy.cpp
Core/Debugger/ExpressionEvaluator.Gba.cpp
Core/Debugger/ExpressionEvaluator.Gsu.cpp
Core/Debugger/ExpressionEvaluator.h
Core/Debugger/ExpressionEvaluator.NecDsp.cpp
Core/Debugger/ExpressionEvaluator.Nes.cpp
Core/Debugger/ExpressionEvaluator.Pce.cpp
Core/Debugger/ExpressionEvaluator.Sms.cpp
Core/Debugger/ExpressionEvaluator.Snes.cpp
Core/Debugger/ExpressionEvaluator.Spc.cpp
Core/Debugger/ExpressionEvaluator.St018.cpp
Core/Debugger/ExpressionEvaluator.Ws.cpp
Core/Debugger/FrozenAddressManager.h
Core/Debugger/IAssembler.h
Core/Debugger/IDebugger.h
Core/Debugger/ITraceLogger.h
Core/Debugger/LabelManager.cpp
Core/Debugger/LabelManager.h
Core/Debugger/LuaApi.cpp
Core/Debugger/LuaApi.h
Core/Debugger/LuaCallHelper.cpp
Core/Debugger/LuaCallHelper.h
Core/Debugger/MemoryAccessCounter.cpp
Core/Debugger/MemoryAccessCounter.h
Core/Debugger/MemoryDumper.cpp
Core/Debugger/MemoryDumper.h
Core/Debugger/PpuTools.cpp
Core/Debugger/PpuTools.h
Core/Debugger/Profiler.cpp
Core/Debugger/Profiler.h
Core/Debugger/ScriptHost.cpp
Core/Debugger/ScriptHost.h
Core/Debugger/ScriptingContext.cpp
Core/Debugger/ScriptingContext.h
Core/Debugger/ScriptManager.cpp
Core/Debugger/ScriptManager.h
Core/Debugger/StepBackManager.cpp
Core/Debugger/StepBackManager.h
Core/Debugger/TraceLogFileSaver.h
Core/Netplay/ClientConnectionData.h
Core/Netplay/ForceDisconnectMessage.h
Core/Netplay/GameClient.cpp
Core/Netplay/GameClient.h
Core/Netplay/GameClientConnection.cpp
Core/Netplay/GameClientConnection.h
Core/Netplay/GameConnection.cpp
Core/Netplay/GameConnection.h
Core/Netplay/GameInformationMessage.h
Core/Netplay/GameServer.cpp
Core/Netplay/GameServer.h
Core/Netplay/GameServerConnection.cpp
Core/Netplay/GameServerConnection.h
Core/Netplay/HandShakeMessage.h
Core/Netplay/InputDataMessage.h
Core/Netplay/MessageType.h
Core/Netplay/MovieDataMessage.h
Core/Netplay/NetMessage.h
Core/Netplay/NetplayTypes.h
Core/Netplay/PlayerListMessage.h
Core/Netplay/SaveStateMessage.h
Core/Netplay/SelectControllerMessage.h
Core/Netplay/ServerInformationMessage.h
Core/pch.cpp
Core/pch.h
Core/Shared/ArmEnums.h
Core/Shared/Audio/AudioPlayerHud.cpp
Core/Shared/Audio/AudioPlayerHud.h
Core/Shared/Audio/AudioPlayerTypes.h
Core/Shared/Audio/BaseSoundManager.cpp
Core/Shared/Audio/BaseSoundManager.h
Core/Shared/Audio/PcmReader.cpp
Core/Shared/Audio/PcmReader.h
Core/Shared/Audio/SoundMixer.cpp
Core/Shared/Audio/SoundMixer.h
Core/Shared/Audio/SoundResampler.cpp
Core/Shared/Audio/SoundResampler.h
Core/Shared/Audio/WaveRecorder.cpp
Core/Shared/Audio/WaveRecorder.h
Core/Shared/BaseControlDevice.cpp
Core/Shared/BaseControlDevice.h
Core/Shared/BaseControlManager.cpp
Core/Shared/BaseControlManager.h
Core/Shared/BaseState.h
Core/Shared/BatteryManager.cpp
Core/Shared/BatteryManager.h
Core/Shared/CdReader.cpp
Core/Shared/CdReader.h
Core/Shared/CheatManager.cpp
Core/Shared/CheatManager.h
Core/Shared/ColorUtilities.h
Core/Shared/ControlDeviceState.h
Core/Shared/ControllerHub.h
Core/Shared/CpuType.h
Core/Shared/DebuggerRequest.cpp
Core/Shared/DebuggerRequest.h
Core/Shared/Emulator.cpp
Core/Shared/Emulator.h
Core/Shared/EmulatorLock.cpp
Core/Shared/EmulatorLock.h
Core/Shared/EmuSettings.cpp
Core/Shared/EmuSettings.h
Core/Shared/EventType.h
Core/Shared/FirmwareHelper.h
Core/Shared/FrameLimiter.h
Core/Shared/HistoryViewer.cpp
Core/Shared/HistoryViewer.h
Core/Shared/IControllerHub.h
Core/Shared/InputHud.cpp
Core/Shared/InputHud.h
Core/Shared/Interfaces/IAudioDevice.h
Core/Shared/Interfaces/IAudioProvider.h
Core/Shared/Interfaces/IBarcodeReader.h
Core/Shared/Interfaces/IBattery.h
Core/Shared/Interfaces/IConsole.h
Core/Shared/Interfaces/IInputProvider.h
Core/Shared/Interfaces/IInputRecorder.h
Core/Shared/Interfaces/IKeyManager.h
Core/Shared/Interfaces/IMessageManager.h
Core/Shared/Interfaces/IMouseManager.h
Core/Shared/Interfaces/INotificationListener.h
Core/Shared/Interfaces/IRenderingDevice.h
Core/Shared/Interfaces/ITapeRecorder.h
Core/Shared/KeyDefinitions.h
Core/Shared/KeyManager.cpp
Core/Shared/KeyManager.h
Core/Shared/McpServer.cpp
Core/Shared/McpServer.h
Core/Shared/MemoryOperationType.h
Core/Shared/MemoryType.h
Core/Shared/MessageManager.cpp
Core/Shared/MessageManager.h
Core/Shared/Movies/MesenMovie.cpp
Core/Shared/Movies/MesenMovie.h
Core/Shared/Movies/MovieManager.cpp
Core/Shared/Movies/MovieManager.h
Core/Shared/Movies/MovieRecorder.cpp
Core/Shared/Movies/MovieRecorder.h
Core/Shared/Movies/MovieTypes.h
Core/Shared/NotificationManager.cpp
Core/Shared/NotificationManager.h
Core/Shared/RecordedRomTest.cpp
Core/Shared/RecordedRomTest.h
Core/Shared/RenderedFrame.h
Core/Shared/RewindData.cpp
Core/Shared/RewindData.h
Core/Shared/RewindManager.cpp
Core/Shared/RewindManager.h
Core/Shared/RomFinder.h
Core/Shared/RomInfo.h
Core/Shared/SaveStateCompatInfo.h
Core/Shared/SaveStateManager.cpp
Core/Shared/SaveStateManager.h
Core/Shared/SettingTypes.h
Core/Shared/ShortcutKeyHandler.cpp
Core/Shared/ShortcutKeyHandler.h
Core/Shared/SystemActionManager.h
Core/Shared/TimingInfo.h
Core/Shared/Utilities/emu2413.cpp
Core/Shared/Utilities/emu2413.h
Core/Shared/Utilities/Emu2413Serializer.h
InteropDLL/Common.h
InteropDLL/ConfigApiWrapper.cpp
InteropDLL/DebugApiWrapper.cpp
InteropDLL/EmuApiWrapper.cpp
InteropDLL/HistoryApiWrapper.cpp
InteropDLL/InputApiWrapper.cpp
InteropDLL/InteropDLL.vcxproj
InteropDLL/InteropNotificationListener.h
InteropDLL/InteropNotificationListeners.h
InteropDLL/NetplayApiWrapper.cpp
InteropDLL/RecordApiWrapper.cpp
InteropDLL/TestApiWrapper.cpp
LICENSE
linux-debugging/.gitignore
linux-debugging/log_processor.awk
linux-debugging/suppressions
linux-debugging/tsan_launch.sh
makefile
NuGet.Config
README.md
repomix.config.json
SteamOS.md
```

# Files

## File: .claude/settings.local.json
```json
{
  "permissions": {
    "allow": [
      "Bash(rtk git status:*)",
      "Bash(dotnet build:*)",
      "Bash(git checkout:*)",
      "Bash(git clean:*)"
    ]
  }
}
```

## File: .editorconfig
```
root = true

[*]
indent_style = tab
indent_size = 3

[*.{c++,cc,cpp,cppm,cxx,h,h++,hh,hpp,hxx,inl,ipp,ixx,tlh,tli}]

# Visual C++ Code Style settings

cpp_generate_documentation_comments = xml

# Visual C++ Formatting settings

cpp_indent_braces = false
cpp_indent_multi_line_relative_to = innermost_parenthesis
cpp_indent_within_parentheses = indent
cpp_indent_preserve_within_parentheses = true
cpp_indent_case_contents = true
cpp_indent_case_labels = true
cpp_indent_case_contents_when_block = false
cpp_indent_lambda_braces_when_parameter = false
cpp_indent_goto_labels = one_left
cpp_indent_preprocessor = leftmost_column
cpp_indent_access_specifiers = false
cpp_indent_namespace_contents = true
cpp_indent_preserve_comments = false
cpp_new_line_before_open_brace_namespace = new_line
cpp_new_line_before_open_brace_type = new_line
cpp_new_line_before_open_brace_function = new_line
cpp_new_line_before_open_brace_block = same_line
cpp_new_line_before_open_brace_lambda = same_line
cpp_new_line_scope_braces_on_separate_lines = true
cpp_new_line_close_brace_same_line_empty_type = false
cpp_new_line_close_brace_same_line_empty_function = false
cpp_new_line_before_catch = false
cpp_new_line_before_else = false
cpp_new_line_before_while_in_do_while = false
cpp_space_before_function_open_parenthesis = remove
cpp_space_within_parameter_list_parentheses = false
cpp_space_between_empty_parameter_list_parentheses = false
cpp_space_after_keywords_in_control_flow_statements = false
cpp_space_within_control_flow_statement_parentheses = false
cpp_space_before_lambda_open_parenthesis = false
cpp_space_within_cast_parentheses = false
cpp_space_after_cast_close_parenthesis = false
cpp_space_within_expression_parentheses = false
cpp_space_before_block_open_brace = true
cpp_space_between_empty_braces = false
cpp_space_before_initializer_list_open_brace = true
cpp_space_within_initializer_list_braces = true
cpp_space_preserve_in_initializer_list = true
cpp_space_before_open_square_bracket = false
cpp_space_within_square_brackets = false
cpp_space_before_empty_square_brackets = false
cpp_space_between_empty_square_brackets = false
cpp_space_group_square_brackets = true
cpp_space_within_lambda_brackets = false
cpp_space_between_empty_lambda_brackets = false
cpp_space_before_comma = false
cpp_space_after_comma = true
cpp_space_remove_around_member_operators = true
cpp_space_before_inheritance_colon = true
cpp_space_before_constructor_colon = true
cpp_space_remove_before_semicolon = true
cpp_space_after_semicolon = true
cpp_space_remove_around_unary_operator = true
cpp_space_around_binary_operator = insert
cpp_space_around_assignment_operator = insert
cpp_space_pointer_reference_alignment = left
cpp_space_around_ternary_operator = insert
cpp_wrap_preserve_blocks = one_liners

# C# files
[*.cs]

#### Core EditorConfig Options ####

# Indentation and spacing
indent_size = 3
indent_style = tab
tab_width = 3

# New line preferences
end_of_line = crlf
insert_final_newline = false

#### .NET Coding Conventions ####

# Organize usings
dotnet_separate_import_directive_groups = false
dotnet_sort_system_directives_first = false
file_header_template = unset

# this. and Me. preferences
dotnet_style_qualification_for_event = false
dotnet_style_qualification_for_field = false
dotnet_style_qualification_for_method = false
dotnet_style_qualification_for_property = false

# Language keywords vs BCL types preferences
dotnet_style_predefined_type_for_locals_parameters_members = true
dotnet_style_predefined_type_for_member_access = true

# Parentheses preferences
dotnet_style_parentheses_in_arithmetic_binary_operators = always_for_clarity
dotnet_style_parentheses_in_other_binary_operators = always_for_clarity
dotnet_style_parentheses_in_other_operators = never_if_unnecessary
dotnet_style_parentheses_in_relational_binary_operators = always_for_clarity

# Modifier preferences
dotnet_style_require_accessibility_modifiers = for_non_interface_members

# Expression-level preferences
dotnet_style_coalesce_expression = true
dotnet_style_collection_initializer = true
dotnet_style_explicit_tuple_names = true
dotnet_style_namespace_match_folder = true
dotnet_style_null_propagation = true
dotnet_style_object_initializer = true
dotnet_style_operator_placement_when_wrapping = beginning_of_line
dotnet_style_prefer_auto_properties = true
dotnet_style_prefer_compound_assignment = true
dotnet_style_prefer_conditional_expression_over_assignment = true
dotnet_style_prefer_conditional_expression_over_return = true
dotnet_style_prefer_inferred_anonymous_type_member_names = true
dotnet_style_prefer_inferred_tuple_names = true
dotnet_style_prefer_is_null_check_over_reference_equality_method = true
dotnet_style_prefer_simplified_boolean_expressions = true
dotnet_style_prefer_simplified_interpolation = true

# Field preferences
dotnet_style_readonly_field = true

# Parameter preferences
dotnet_code_quality_unused_parameters = all

# Suppression preferences
dotnet_remove_unnecessary_suppression_exclusions = none

# New line preferences
dotnet_style_allow_multiple_blank_lines_experimental = true
dotnet_style_allow_statement_immediately_after_block_experimental = true

#### C# Coding Conventions ####

# var preferences
csharp_style_var_elsewhere = false
csharp_style_var_for_built_in_types = false
csharp_style_var_when_type_is_apparent = false

# Expression-bodied members
csharp_style_expression_bodied_accessors = true
csharp_style_expression_bodied_constructors = false
csharp_style_expression_bodied_indexers = true
csharp_style_expression_bodied_lambdas = true
csharp_style_expression_bodied_local_functions = false
csharp_style_expression_bodied_methods = false
csharp_style_expression_bodied_operators = false
csharp_style_expression_bodied_properties = true

# Pattern matching preferences
csharp_style_pattern_matching_over_as_with_null_check = true
csharp_style_pattern_matching_over_is_with_cast_check = true
csharp_style_prefer_not_pattern = true
csharp_style_prefer_pattern_matching = true
csharp_style_prefer_switch_expression = true

# Null-checking preferences
csharp_style_conditional_delegate_call = true

# Modifier preferences
csharp_prefer_static_local_function = true
csharp_preferred_modifier_order = public,private,protected,internal,static,extern,new,virtual,abstract,sealed,override,readonly,unsafe,volatile,async

# Code-block preferences
csharp_prefer_braces = true
csharp_prefer_simple_using_statement = true
csharp_style_namespace_declarations = block_scoped

# Expression-level preferences
csharp_prefer_simple_default_expression = true
csharp_style_deconstructed_variable_declaration = true
csharp_style_implicit_object_creation_when_type_is_apparent = true
csharp_style_inlined_variable_declaration = true
csharp_style_pattern_local_over_anonymous_function = true
csharp_style_prefer_index_operator = true
csharp_style_prefer_null_check_over_type_check = true
csharp_style_prefer_range_operator = true
csharp_style_throw_expression = true
csharp_style_unused_value_assignment_preference = discard_variable
csharp_style_unused_value_expression_statement_preference = discard_variable

# 'using' directive preferences
csharp_using_directive_placement = outside_namespace

# New line preferences
csharp_style_allow_blank_line_after_colon_in_constructor_initializer_experimental = true
csharp_style_allow_blank_lines_between_consecutive_braces_experimental = true
csharp_style_allow_embedded_statements_on_same_line_experimental = true

#### C# Formatting Rules ####

# New line preferences
csharp_new_line_before_catch = false
csharp_new_line_before_else = false
csharp_new_line_before_finally = false
csharp_new_line_before_members_in_anonymous_types = true
csharp_new_line_before_members_in_object_initializers = true
csharp_new_line_before_open_brace = accessors,methods,properties,types
csharp_new_line_between_query_expression_clauses = true

# Indentation preferences
csharp_indent_block_contents = true
csharp_indent_braces = false
csharp_indent_case_contents = true
csharp_indent_case_contents_when_block = false
csharp_indent_labels = one_less_than_current
csharp_indent_switch_labels = true

# Space preferences
csharp_space_after_cast = false
csharp_space_after_colon_in_inheritance_clause = true
csharp_space_after_comma = true
csharp_space_after_dot = false
csharp_space_after_keywords_in_control_flow_statements = false
csharp_space_after_semicolon_in_for_statement = true
csharp_space_around_binary_operators = before_and_after
csharp_space_around_declaration_statements = false
csharp_space_before_colon_in_inheritance_clause = true
csharp_space_before_comma = false
csharp_space_before_dot = false
csharp_space_before_open_square_brackets = false
csharp_space_before_semicolon_in_for_statement = false
csharp_space_between_empty_square_brackets = false
csharp_space_between_method_call_empty_parameter_list_parentheses = false
csharp_space_between_method_call_name_and_opening_parenthesis = false
csharp_space_between_method_call_parameter_list_parentheses = false
csharp_space_between_method_declaration_empty_parameter_list_parentheses = false
csharp_space_between_method_declaration_name_and_open_parenthesis = false
csharp_space_between_method_declaration_parameter_list_parentheses = false
csharp_space_between_parentheses = false
csharp_space_between_square_brackets = false

# Wrapping preferences
csharp_preserve_single_line_blocks = true
csharp_preserve_single_line_statements = true

#### Naming styles ####

# Naming rules

dotnet_naming_rule.interface_should_be_begins_with_i.severity = silent
dotnet_naming_rule.interface_should_be_begins_with_i.symbols = interface
dotnet_naming_rule.interface_should_be_begins_with_i.style = begins_with_i

dotnet_naming_rule.types_should_be_pascal_case.severity = silent
dotnet_naming_rule.types_should_be_pascal_case.symbols = types
dotnet_naming_rule.types_should_be_pascal_case.style = pascal_case

dotnet_naming_rule.non_field_members_should_be_pascal_case.severity = silent
dotnet_naming_rule.non_field_members_should_be_pascal_case.symbols = non_field_members
dotnet_naming_rule.non_field_members_should_be_pascal_case.style = pascal_case

# Symbol specifications

dotnet_naming_symbols.interface.applicable_kinds = interface
dotnet_naming_symbols.interface.applicable_accessibilities = public, internal, private, protected, protected_internal
dotnet_naming_symbols.interface.required_modifiers = 

dotnet_naming_symbols.types.applicable_kinds = class, struct, interface, enum
dotnet_naming_symbols.types.applicable_accessibilities = public, internal, private, protected, protected_internal
dotnet_naming_symbols.types.required_modifiers = 

dotnet_naming_symbols.non_field_members.applicable_kinds = property, event, method
dotnet_naming_symbols.non_field_members.applicable_accessibilities = public, internal, private, protected, protected_internal
dotnet_naming_symbols.non_field_members.required_modifiers = 

# Naming styles

dotnet_naming_style.pascal_case.required_prefix = 
dotnet_naming_style.pascal_case.required_suffix = 
dotnet_naming_style.pascal_case.word_separator = 
dotnet_naming_style.pascal_case.capitalization = pascal_case

dotnet_naming_style.begins_with_i.required_prefix = I
dotnet_naming_style.begins_with_i.required_suffix = 
dotnet_naming_style.begins_with_i.word_separator = 
dotnet_naming_style.begins_with_i.capitalization = pascal_case
```

## File: .gitattributes
```
###############################################################################
# Set default behavior to automatically normalize line endings.
###############################################################################
* text=auto

###############################################################################
# Set default behavior for command prompt diff.
#
# This is need for earlier builds of msysgit that does not have it on by
# default for csharp files.
# Note: This is only used by command line
###############################################################################
#*.cs     diff=csharp

###############################################################################
# Set the merge driver for project and solution files
#
# Merging from the command prompt will add diff markers to the files if there
# are conflicts (Merging from VS is not affected by the settings below, in VS
# the diff markers are never inserted). Diff markers may cause the following 
# file extensions to fail to load in VS. An alternative would be to treat
# these files as binary and thus will always conflict and require user
# intervention with every merge. To do so, just uncomment the entries below
###############################################################################
#*.sln       merge=binary
#*.csproj    merge=binary
#*.vbproj    merge=binary
#*.vcxproj   merge=binary
#*.vcproj    merge=binary
#*.dbproj    merge=binary
#*.fsproj    merge=binary
#*.lsproj    merge=binary
#*.wixproj   merge=binary
#*.modelproj merge=binary
#*.sqlproj   merge=binary
#*.wwaproj   merge=binary

###############################################################################
# behavior for image files
#
# image files are treated as binary by default.
###############################################################################
#*.jpg   binary
#*.png   binary
#*.gif   binary

###############################################################################
# diff behavior for common document formats
# 
# Convert binary document formats to text before diffing them. This feature
# is only available from the command line. Turn it on by uncommenting the 
# entries below.
###############################################################################
#*.doc   diff=astextplain
#*.DOC   diff=astextplain
#*.docx  diff=astextplain
#*.DOCX  diff=astextplain
#*.dot   diff=astextplain
#*.DOT   diff=astextplain
#*.pdf   diff=astextplain
#*.PDF   diff=astextplain
#*.rtf   diff=astextplain
#*.RTF   diff=astextplain
```

## File: .github/actions/build-sha1-action/action.yml
```yaml
name: 'Write commit SHA1 to file'
runs:
  using: "composite"
  steps:
      - name: Write commit SHA1 to file
        uses: "DamianReeves/write-file-action@master"
        with:
          path: "UI/Dependencies/Internal/BuildSha.txt"
          write-mode: overwrite
          contents: ${{ github.sha }}
```

## File: .github/actions/setup-ccache-action/action.yml
```yaml
name: 'Setup CCache'
inputs:
  ccache-path:
    required: true
    default: '/usr/lib/ccache'
runs:
  using: "composite"
  steps:
      - name: Setup CCache
        shell: bash
        run: |
          eval $(printf 'PATH=${{ inputs.ccache-path }}:%s\n' "$PATH" | tee -a "$GITHUB_ENV")
          cat <<EOF >>"$GITHUB_ENV"
          CCACHE_MAXSIZE=500M
          CCACHE_DIR=$HOME/.cache/ccache
          CCACHE_BASEDIR=$PWD
          EOF
      - name: Cache compilation
        uses: actions/cache@v4
        with:
          path: ${{ env.CCACHE_DIR }}
          key: ccache-${{ matrix.compiler }}-${{ matrix.platform.os }}
          restore-keys: |
            ccache-${{ matrix.compiler }}
```

## File: .gitignore
```
## Ignore Visual Studio temporary files, build results, and
## files generated by popular Visual Studio add-ons.

# User-specific files
*.suo
*.user
*.sln.docstates
.vs/*

# Build results

[Dd]ebug/
[Rr]elease/
x64/
build/
[Bb]in/
[Oo]bj/
[Oo]bj.x86/
[Oo]bj.x64/
[Oo]bj.linux-*/
[Oo]bj.osx-*/

# Enable "build/" folder in the NuGet Packages folder since NuGet packages use it for MSBuild targets
!packages/*/build/

# MSTest test Results
[Tt]est[Rr]esult*/
[Bb]uild[Ll]og.*

*_i.c
*_p.c
*.ilk
*.meta
*.obj
*.pch
*.pdb
*.pgc
*.pgd
*.rsp
*.sbr
*.tlb
*.tli
*.tlh
*.tmp
*.tmp_proj
*.log
*.vspscc
*.vssscc
.builds
*.pidb
*.log
*.scc

# Libretro build files
*.o

# Visual C++ cache files
ipch/
*.aps
*.ncb
*.opensdf
*.sdf
*.cachefile

# Visual Studio profiler
*.psess
*.vsp
*.vspx

# Guidance Automation Toolkit
*.gpState

# ReSharper is a .NET coding add-in
_ReSharper*/
*.[Rr]e[Ss]harper

# TeamCity is a build add-in
_TeamCity*

# DotCover is a Code Coverage Tool
*.dotCover

# NCrunch
*.ncrunch*
.*crunch*.local.xml

# Installshield output folder
[Ee]xpress/

# DocProject is a documentation generator add-in
DocProject/buildhelp/
DocProject/Help/*.HxT
DocProject/Help/*.HxC
DocProject/Help/*.hhc
DocProject/Help/*.hhk
DocProject/Help/*.hhp
DocProject/Help/Html2
DocProject/Help/html

# Click-Once directory
publish/

# Publish Web Output
*.Publish.xml

# NuGet Packages Directory
## TODO: If you have NuGet Package Restore enabled, uncomment the next line
#packages/

# Windows Azure Build Output
csx
*.build.csdef

# Windows Store app package directory
AppPackages/

# Others
sql/
*.Cache
ClientBin/
[Ss]tyle[Cc]op.*
~$*
*~
*.dbmdl
*.[Pp]ublish.xml
*.pfx
*.publishsettings

# RIA/Silverlight projects
Generated_Code/

# Backup & report files from converting an old project file to a newer
# Visual Studio version. Backup files are not needed, because we have git ;-)
_UpgradeReport_Files/
Backup*/
UpgradeLog*.XML
UpgradeLog*.htm

# SQL Server files
App_Data/*.mdf
App_Data/*.ldf

#LightSwitch generated files
GeneratedArtifacts/
_Pvt_Extensions/
ModelManifest.xml

# =========================
# Windows detritus
# =========================

# Windows image file caches
Thumbs.db
ehthumbs.db

# Folder config file
Desktop.ini

# Recycle Bin used on file shares
$RECYCLE.BIN/

# Mac desktop service store files
.DS_Store
*.nes
*.sfc
*.gb
*.gbc
*.sav
*.svs
*.trt
*.rar
*.pce
PGOHelper/PGOGames/*

*.VC.opendb
*.VC.db
*.VC.db-wal
*.VC.db-shm

Docs/docs/
Docs/*.exe

PGOHelper/PGOMesenHome
*.profraw
*.profdata

packages/*

!Libretro/hakchi/bin

TestHelper/*
UI/Dependencies.zip
```

## File: .repomixignore
```
# Salidas de Repomix (importante ignorarlas)
repomix-output.xml
repomix-output.md

# Carpetas de distribución y build
dist
node_modules
build
bin
obj

# Exclusiones específicas de Mesen2
Core/Shared/Video/
Core/Shared/Rendering/
DrawStringCommand.cpp
UI/Dependencies/

# Archivos específicos ignorados
Utilities/miniz.cpp
Utilities/Audio/stb_vorbis.cpp
**/*.bin
**/*.icns
```

## File: buildPGO.sh
```bash
PLAT="x64"
TARG="core"
OBJ="PGOHelper/obj.${PLAT}/"
eval make clean
eval PGO=profile make pgohelper -B -j 16
eval cp bin/pgohelperlib.so ${OBJ}
cd ${OBJ}
./pgohelper
cd ..
if [ "$USE_GCC" != true ]; then
	llvm-profdata merge -output=pgo.profdata pgo.profraw
	cd ..
	eval make clean
else
	cd ..
fi
eval PGO=optimize make -j 16 -B
if [ "$USE_GCC" != true ]; then
	rm PGOHelper/pgo.profdata
	rm PGOHelper/pgo.profraw
else
	rm ./*.gcda
fi
```

## File: COMPILING.md
```markdown
## Windows

1) Open the solution in Visual Studio 2022
2) Compile as `Release`/`x64`
3) Set the startup project to the `UI` project and run

## Linux

To build under Linux you need a version of Clang or GCC that supports C++17.  

Additionally, SDL2 and the [.NET 8 SDK](https://learn.microsoft.com/en-us/dotnet/core/install/linux) must also be installed.

Once SDL2 and the .NET 8 SDK are installed, run `make` to compile with Clang.  
To compile with GCC instead, use `USE_GCC=true make`.  
**Note:** Mesen usually runs faster when built with Clang instead of GCC.


## macOS

To build macOS, install SDL2 (i.e via Homebrew) and the [.NET 8 SDK](https://dotnet.microsoft.com/en-us/download/dotnet/8.0).  

Once SDL2 and the .NET 8 SDK are installed, run `make`.
```

## File: Core/Core.ruleset
```
<?xml version="1.0" encoding="utf-8"?>
<RuleSet Name="Rules for Core" Description="Code analysis rules for Core.vcxproj." ToolsVersion="17.0">
  <Rules AnalyzerId="Microsoft.Analyzers.NativeCodeAnalysis" RuleNamespace="Microsoft.Rules.Native">
    <Rule Id="C26100" Action="Warning" />
    <Rule Id="C26101" Action="Warning" />
    <Rule Id="C26110" Action="Warning" />
    <Rule Id="C26111" Action="Warning" />
    <Rule Id="C26112" Action="Warning" />
    <Rule Id="C26115" Action="Warning" />
    <Rule Id="C26116" Action="Warning" />
    <Rule Id="C26117" Action="Warning" />
    <Rule Id="C26140" Action="Warning" />
    <Rule Id="C26437" Action="Warning" />
    <Rule Id="C26439" Action="Warning" />
    <Rule Id="C26441" Action="Warning" />
    <Rule Id="C26444" Action="Warning" />
    <Rule Id="C26449" Action="Warning" />
    <Rule Id="C26450" Action="Warning" />
    <Rule Id="C26452" Action="Warning" />
    <Rule Id="C26453" Action="Warning" />
    <Rule Id="C26454" Action="Warning" />
    <Rule Id="C26478" Action="Warning" />
    <Rule Id="C26479" Action="Warning" />
    <Rule Id="C26495" Action="Warning" />
    <Rule Id="C26498" Action="Warning" />
    <Rule Id="C26800" Action="Warning" />
    <Rule Id="C26810" Action="Warning" />
    <Rule Id="C26811" Action="Warning" />
    <Rule Id="C26815" Action="Warning" />
    <Rule Id="C26816" Action="Warning" />
    <Rule Id="C26817" Action="Warning" />
    <Rule Id="C26819" Action="Warning" />
    <Rule Id="C26820" Action="Warning" />
    <Rule Id="C28020" Action="Warning" />
    <Rule Id="C28021" Action="Warning" />
    <Rule Id="C28022" Action="Warning" />
    <Rule Id="C28023" Action="Warning" />
    <Rule Id="C28024" Action="Warning" />
    <Rule Id="C28039" Action="Warning" />
    <Rule Id="C28112" Action="Warning" />
    <Rule Id="C28113" Action="Warning" />
    <Rule Id="C28125" Action="Warning" />
    <Rule Id="C28137" Action="Warning" />
    <Rule Id="C28138" Action="Warning" />
    <Rule Id="C28159" Action="Warning" />
    <Rule Id="C28160" Action="Warning" />
    <Rule Id="C28163" Action="Warning" />
    <Rule Id="C28164" Action="Warning" />
    <Rule Id="C28182" Action="Warning" />
    <Rule Id="C28183" Action="Warning" />
    <Rule Id="C28193" Action="Warning" />
    <Rule Id="C28196" Action="Warning" />
    <Rule Id="C28202" Action="Warning" />
    <Rule Id="C28203" Action="Warning" />
    <Rule Id="C28205" Action="Warning" />
    <Rule Id="C28206" Action="Warning" />
    <Rule Id="C28207" Action="Warning" />
    <Rule Id="C28209" Action="Warning" />
    <Rule Id="C28210" Action="Warning" />
    <Rule Id="C28211" Action="Warning" />
    <Rule Id="C28212" Action="Warning" />
    <Rule Id="C28213" Action="Warning" />
    <Rule Id="C28214" Action="Warning" />
    <Rule Id="C28215" Action="Warning" />
    <Rule Id="C28216" Action="Warning" />
    <Rule Id="C28217" Action="Warning" />
    <Rule Id="C28218" Action="Warning" />
    <Rule Id="C28219" Action="Warning" />
    <Rule Id="C28220" Action="Warning" />
    <Rule Id="C28221" Action="Warning" />
    <Rule Id="C28222" Action="Warning" />
    <Rule Id="C28223" Action="Warning" />
    <Rule Id="C28224" Action="Warning" />
    <Rule Id="C28225" Action="Warning" />
    <Rule Id="C28226" Action="Warning" />
    <Rule Id="C28227" Action="Warning" />
    <Rule Id="C28228" Action="Warning" />
    <Rule Id="C28229" Action="Warning" />
    <Rule Id="C28230" Action="Warning" />
    <Rule Id="C28231" Action="Warning" />
    <Rule Id="C28232" Action="Warning" />
    <Rule Id="C28233" Action="Warning" />
    <Rule Id="C28234" Action="Warning" />
    <Rule Id="C28235" Action="Warning" />
    <Rule Id="C28236" Action="Warning" />
    <Rule Id="C28237" Action="Warning" />
    <Rule Id="C28238" Action="Warning" />
    <Rule Id="C28239" Action="Warning" />
    <Rule Id="C28240" Action="Warning" />
    <Rule Id="C28241" Action="Warning" />
    <Rule Id="C28243" Action="Warning" />
    <Rule Id="C28244" Action="Warning" />
    <Rule Id="C28245" Action="Warning" />
    <Rule Id="C28246" Action="Warning" />
    <Rule Id="C28250" Action="Warning" />
    <Rule Id="C28251" Action="Warning" />
    <Rule Id="C28252" Action="Warning" />
    <Rule Id="C28253" Action="Warning" />
    <Rule Id="C28254" Action="Warning" />
    <Rule Id="C28262" Action="Warning" />
    <Rule Id="C28263" Action="Warning" />
    <Rule Id="C28267" Action="Warning" />
    <Rule Id="C28272" Action="Warning" />
    <Rule Id="C28273" Action="Warning" />
    <Rule Id="C28275" Action="Warning" />
    <Rule Id="C28279" Action="Warning" />
    <Rule Id="C28280" Action="Warning" />
    <Rule Id="C28282" Action="Warning" />
    <Rule Id="C28285" Action="Warning" />
    <Rule Id="C28286" Action="Warning" />
    <Rule Id="C28287" Action="Warning" />
    <Rule Id="C28288" Action="Warning" />
    <Rule Id="C28289" Action="Warning" />
    <Rule Id="C28290" Action="Warning" />
    <Rule Id="C28291" Action="Warning" />
    <Rule Id="C28300" Action="Warning" />
    <Rule Id="C28301" Action="Warning" />
    <Rule Id="C28302" Action="Warning" />
    <Rule Id="C28303" Action="Warning" />
    <Rule Id="C28304" Action="Warning" />
    <Rule Id="C28305" Action="Warning" />
    <Rule Id="C28306" Action="Warning" />
    <Rule Id="C28307" Action="Warning" />
    <Rule Id="C28308" Action="Warning" />
    <Rule Id="C28309" Action="Warning" />
    <Rule Id="C28350" Action="Warning" />
    <Rule Id="C28351" Action="Warning" />
    <Rule Id="C33001" Action="Warning" />
    <Rule Id="C33004" Action="Warning" />
    <Rule Id="C33005" Action="Warning" />
    <Rule Id="C33010" Action="Warning" />
    <Rule Id="C33011" Action="Warning" />
    <Rule Id="C33020" Action="Warning" />
    <Rule Id="C6001" Action="Warning" />
    <Rule Id="C6011" Action="Warning" />
    <Rule Id="C6029" Action="Warning" />
    <Rule Id="C6031" Action="Warning" />
    <Rule Id="C6053" Action="Warning" />
    <Rule Id="C6054" Action="Warning" />
    <Rule Id="C6059" Action="Warning" />
    <Rule Id="C6063" Action="Warning" />
    <Rule Id="C6064" Action="Warning" />
    <Rule Id="C6066" Action="Warning" />
    <Rule Id="C6067" Action="Warning" />
    <Rule Id="C6101" Action="Warning" />
    <Rule Id="C6200" Action="Warning" />
    <Rule Id="C6201" Action="Warning" />
    <Rule Id="C6214" Action="Warning" />
    <Rule Id="C6215" Action="Warning" />
    <Rule Id="C6216" Action="Warning" />
    <Rule Id="C6217" Action="Warning" />
    <Rule Id="C6220" Action="Warning" />
    <Rule Id="C6226" Action="Warning" />
    <Rule Id="C6230" Action="Warning" />
    <Rule Id="C6235" Action="Warning" />
    <Rule Id="C6236" Action="Warning" />
    <Rule Id="C6237" Action="Warning" />
    <Rule Id="C6242" Action="Warning" />
    <Rule Id="C6248" Action="Warning" />
    <Rule Id="C6250" Action="Warning" />
    <Rule Id="C6255" Action="Warning" />
    <Rule Id="C6258" Action="Warning" />
    <Rule Id="C6259" Action="Warning" />
    <Rule Id="C6260" Action="Warning" />
    <Rule Id="C6262" Action="Warning" />
    <Rule Id="C6263" Action="Warning" />
    <Rule Id="C6268" Action="Warning" />
    <Rule Id="C6269" Action="Warning" />
    <Rule Id="C6270" Action="Warning" />
    <Rule Id="C6271" Action="Warning" />
    <Rule Id="C6272" Action="Warning" />
    <Rule Id="C6273" Action="Warning" />
    <Rule Id="C6274" Action="Warning" />
    <Rule Id="C6276" Action="Warning" />
    <Rule Id="C6277" Action="Warning" />
    <Rule Id="C6278" Action="Warning" />
    <Rule Id="C6279" Action="Warning" />
    <Rule Id="C6280" Action="Warning" />
    <Rule Id="C6281" Action="Warning" />
    <Rule Id="C6282" Action="Warning" />
    <Rule Id="C6283" Action="Warning" />
    <Rule Id="C6284" Action="Warning" />
    <Rule Id="C6285" Action="Warning" />
    <Rule Id="C6286" Action="Warning" />
    <Rule Id="C6287" Action="Warning" />
    <Rule Id="C6288" Action="Warning" />
    <Rule Id="C6289" Action="Warning" />
    <Rule Id="C6290" Action="Warning" />
    <Rule Id="C6291" Action="Warning" />
    <Rule Id="C6292" Action="Warning" />
    <Rule Id="C6293" Action="Warning" />
    <Rule Id="C6294" Action="Warning" />
    <Rule Id="C6295" Action="Warning" />
    <Rule Id="C6296" Action="Warning" />
    <Rule Id="C6297" Action="Warning" />
    <Rule Id="C6299" Action="Warning" />
    <Rule Id="C6302" Action="Warning" />
    <Rule Id="C6303" Action="Warning" />
    <Rule Id="C6305" Action="Warning" />
    <Rule Id="C6306" Action="Warning" />
    <Rule Id="C6308" Action="Warning" />
    <Rule Id="C6310" Action="Warning" />
    <Rule Id="C6312" Action="Warning" />
    <Rule Id="C6314" Action="Warning" />
    <Rule Id="C6317" Action="Warning" />
    <Rule Id="C6318" Action="Warning" />
    <Rule Id="C6319" Action="Warning" />
    <Rule Id="C6324" Action="Warning" />
    <Rule Id="C6328" Action="Warning" />
    <Rule Id="C6331" Action="Warning" />
    <Rule Id="C6332" Action="Warning" />
    <Rule Id="C6333" Action="Warning" />
    <Rule Id="C6335" Action="Warning" />
    <Rule Id="C6381" Action="Warning" />
    <Rule Id="C6383" Action="Warning" />
    <Rule Id="C6384" Action="Warning" />
    <Rule Id="C6385" Action="Warning" />
    <Rule Id="C6386" Action="Warning" />
    <Rule Id="C6387" Action="Warning" />
    <Rule Id="C6388" Action="Warning" />
    <Rule Id="C6500" Action="Warning" />
    <Rule Id="C6501" Action="Warning" />
    <Rule Id="C6503" Action="Warning" />
    <Rule Id="C6504" Action="Warning" />
    <Rule Id="C6505" Action="Warning" />
    <Rule Id="C6506" Action="Warning" />
    <Rule Id="C6508" Action="Warning" />
    <Rule Id="C6509" Action="Warning" />
    <Rule Id="C6510" Action="Warning" />
    <Rule Id="C6511" Action="Warning" />
    <Rule Id="C6513" Action="Warning" />
    <Rule Id="C6514" Action="Warning" />
    <Rule Id="C6515" Action="Warning" />
    <Rule Id="C6516" Action="Warning" />
    <Rule Id="C6517" Action="Warning" />
    <Rule Id="C6518" Action="Warning" />
    <Rule Id="C6522" Action="Warning" />
    <Rule Id="C6525" Action="Warning" />
    <Rule Id="C6527" Action="Warning" />
    <Rule Id="C6530" Action="Warning" />
    <Rule Id="C6540" Action="Warning" />
    <Rule Id="C6551" Action="Warning" />
    <Rule Id="C6552" Action="Warning" />
    <Rule Id="C6701" Action="Warning" />
    <Rule Id="C6702" Action="Warning" />
    <Rule Id="C6703" Action="Warning" />
    <Rule Id="C6704" Action="Warning" />
    <Rule Id="C6705" Action="Warning" />
    <Rule Id="C6706" Action="Warning" />
    <Rule Id="C6993" Action="Warning" />
    <Rule Id="C6995" Action="Warning" />
    <Rule Id="C6997" Action="Warning" />
  </Rules>
</RuleSet>
```

## File: Core/Debugger/AddressInfo.h
```
#pragma once
#include "pch.h"
enum class MemoryType;
struct AddressInfo
{
	int32_t Address;
	MemoryType Type;
};
```

## File: Core/Debugger/Base6502Assembler.cpp
```cpp
#include "pch.h"
#include <regex>
#include <unordered_map>
#include "Utilities/HexUtilities.h"
#include "Utilities/StringUtilities.h"
#include "Debugger/Base6502Assembler.h"
#include "Debugger/DisassemblyInfo.h"
#include "Debugger/LabelManager.h"
static const std::regex labelRegex = std::regex("^\\s*([@_a-zA-Z][@_a-zA-Z0-9+]*):(.*)", std::regex_constants::icase);
static const std::regex byteRegex = std::regex("^\\s*[.]db\\s+((\\$[a-fA-F0-9]{1,2}[ ])*)(\\$[a-fA-F0-9]{1,2})+\\s*(;*)(.*)$", std::regex_constants::icase);
template<class T>
void Base6502Assembler<T>::ProcessLine(string code, uint32_t& instructionAddress, vector<int16_t>& output, unordered_map<string, uint32_t>& labels, bool firstPass, unordered_map<string, uint32_t>& currentPassLabels)
{
	size_t commentOffset = code.find_first_of(';');
	if(commentOffset != string::npos) {
		code = code.substr(0, commentOffset);
	}
	code = StringUtilities::Trim(code);
	std::smatch match;
	if(std::regex_search(code, match, byteRegex)) {
		vector<string> bytes = StringUtilities::Split(match.str(1) + match.str(3), ' ');
		for(string& byte : bytes) {
			output.push_back((uint8_t)(HexUtilities::FromHex(byte.substr(1))));
			instructionAddress++;
		}
		output.push_back(AssemblerSpecialCodes::EndOfLine);
		return;
	} else if(std::regex_search(code, match, labelRegex)) {
		string label = match.str(1);
		string afterLabel = match.str(2);
		if(currentPassLabels.find(match.str(1)) != currentPassLabels.end()) {
			output.push_back(AssemblerSpecialCodes::LabelRedefinition);
		} else {
			labels[match.str(1)] = instructionAddress;
			currentPassLabels[match.str(1)] = instructionAddress;
			ProcessLine(afterLabel, instructionAddress, output, labels, firstPass, currentPassLabels);
		}
		return;
	}
	code = StringUtilities::Trim(code);
	if(code.empty()) {
		output.push_back(AssemblerSpecialCodes::EndOfLine);
		return;
	}
	AssemblerLineData op = {};
	size_t opnameOffset = code.find_first_of(' ', 0);
	if(opnameOffset != string::npos) {
		op.OpCode = StringUtilities::ToUpper(code.substr(0, opnameOffset));
		code = StringUtilities::Trim(code.substr(opnameOffset));
		if(code.size() > 0) {
			vector<string> operands = StringUtilities::Split(code, ',');
			for(string& operand : operands) {
				if(op.OperandCount >= 3) {
					output.push_back(AssemblerSpecialCodes::InvalidOperands);
					return;
				}
				AssemblerSpecialCodes result = ParseOperand(op, StringUtilities::Trim(operand), firstPass, labels);
				if(result != AssemblerSpecialCodes::OK) {
					output.push_back(result);
					return;
				}
				op.OperandCount++;
			}
		}
	} else {
		op.OpCode = StringUtilities::ToUpper(code);
	}
	AssemblerSpecialCodes result = ResolveOpMode(op, instructionAddress, firstPass);
	if(result != AssemblerSpecialCodes::OK) {
		output.push_back(result);
		return;
	}
	AssembleInstruction(op, instructionAddress, output, firstPass);
}
template<class T>
AssemblerSpecialCodes Base6502Assembler<T>::ParseOperand(AssemblerLineData& lineData, string operandStr, bool firstPass, unordered_map<string, uint32_t>& labels)
{
	AssemblerOperand& operand = lineData.Operands[lineData.OperandCount];
	if(operandStr.empty()) {
		return AssemblerSpecialCodes::OK;
	}
	static const std::regex operandRegex = std::regex("^([(\\[]?)[\\s]*(((#?)[\\s]*([$%]?)(-?)([0-9a-f]{1,16}))|(#{0,1})([@_a-zA-Z][@_a-zA-Z0-9+]*))[\\s]*([\\])]?)[\\s]*$", std::regex_constants::icase);
	std::smatch match;
	if(std::regex_search(operandStr, match, operandRegex)) {
		operand.HasOpeningBracket = !match.str(1).empty() && match.str(1) == "[";
		operand.HasOpeningParenthesis = !match.str(1).empty() && match.str(1) == "(";
		operand.HasClosingBracket = !match.str(10).empty() && match.str(10) == "]";
		operand.HasClosingParenthesis = !match.str(10).empty() && match.str(10) == ")";
		operand.IsImmediate = !match.str(4).empty() || !match.str(8).empty();
		bool hasNegativeSign = !match.str(6).empty();
		string label = match.str(9);
		if(!match.str(5).empty()) {
			if(hasNegativeSign) {
				return AssemblerSpecialCodes::InvalidOperands;
			}
			operand.ValueType = match.str(5) == "$" ? OperandValueType::Hex : OperandValueType::Binary;
		} else if(!label.empty()) {
			operand.ValueType = OperandValueType::Label;
		} else {
			if(match.str(7)[0] < '0' || match.str(7)[0] > '9') {
				label = match.str(7);
				operand.ValueType = OperandValueType::Label;
			} else {
				operand.ValueType = OperandValueType::Decimal;
			}
		}
		if(operand.ValueType != OperandValueType::Label) {
			operand.Type = OperandType::Custom;
			string rawOperand = match.str(7);
			for(char c : rawOperand) {
				if(operand.ValueType == OperandValueType::Hex && !((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))) {
					return AssemblerSpecialCodes::InvalidHex;
				} else if(operand.ValueType == OperandValueType::Binary && c != '0' && c != '1') {
					return AssemblerSpecialCodes::InvalidBinaryValue;
				} else if(operand.ValueType == OperandValueType::Decimal && (c < '0' || c > '9')) {
					return AssemblerSpecialCodes::InvalidOperands;
				}
			}
			if(operand.ValueType == OperandValueType::Hex) {
				operand.Value = HexUtilities::FromHex(rawOperand);
				if(rawOperand.size() == 0) {
					return AssemblerSpecialCodes::MissingOperand;
				} else if(rawOperand.size() <= 2) {
					operand.ByteCount = 1;
				} else if(rawOperand.size() <= 4) {
					operand.ByteCount = 2;
				} else if(rawOperand.size() <= 6) {
					operand.ByteCount = 3;
				} else {
					return AssemblerSpecialCodes::OperandOutOfRange;
				}
			} else if(operand.ValueType == OperandValueType::Decimal) {
				operand.Value = std::stoll((hasNegativeSign ? "-" : "") + rawOperand);
				if(operand.Value < -0x800000) {
					//< -2^23 is invalid
					return AssemblerSpecialCodes::OperandOutOfRange;
				} else if(operand.Value < -0x8000) {
					operand.ByteCount = 3;
				} else if(operand.Value < -0x80) {
					operand.ByteCount = 2;
				} else if(operand.Value <= 0xFF) {
					operand.ByteCount = 1;
				} else if(operand.Value <= 0xFFFF) {
					operand.ByteCount = 2;
				} else if(operand.Value <= 0xFFFFFF) {
					operand.ByteCount = 3;
				} else {
					//>= 2^23 is invalid
					return AssemblerSpecialCodes::OperandOutOfRange;
				}
			} else if(operand.ValueType == OperandValueType::Binary) {
				//Convert the binary value to hex
				int32_t value = 0;
				for(size_t i = 0; i < rawOperand.size(); i++) {
					value <<= 1;
					value |= rawOperand[i] == '1' ? 1 : 0;
				}
				operand.Value = value;
				operand.ByteCount = rawOperand.size() > 8 ? 2 : 1;
			}
		} else {
			//Labels / register name
			string lcOperand = StringUtilities::ToLower(label);
			if(lcOperand == "a") {
				operand.Type = OperandType::A;
			} else if(lcOperand == "x") {
				operand.Type = OperandType::X;
			} else if(lcOperand == "y") {
				operand.Type = OperandType::Y;
			} else if(lcOperand == "s") {
				operand.Type = OperandType::S;
			} else {
				operand.Type = OperandType::Custom;
				auto result = labels.find(label);
				int32_t addr = -1;
				if(result != labels.end()) {
					addr = result->second;
				} else {
					addr = _labelManager->GetLabelRelativeAddress(label, _cpuType);
				}
				if(addr > 0xFFFF) {
					operand.Value = addr;
					operand.ByteCount = 3;
				} else if(addr > 0xFF) {
					operand.Value = addr;
					operand.ByteCount = 2;
				} else if(addr >= 0) {
					operand.Value = addr;
					operand.ByteCount = 1;
				} else {
					if(firstPass) {
						_needSecondPass = true;
						operand.Value = 0xFF;
						operand.ByteCount = 1;
					} else {
						return AssemblerSpecialCodes::UnknownLabel;
					}
				}
			}
		}
		return AssemblerSpecialCodes::OK;
	} else {
		return AssemblerSpecialCodes::InvalidOperands;
	}
}
template<class T>
bool Base6502Assembler<T>::IsOpModeAvailable(string& opCode, T addrMode)
{
	return _availableModesByOpName[opCode].find(addrMode) != _availableModesByOpName[opCode].end();
}
template<class T>
int16_t Base6502Assembler<T>::GetOpByteCode(string& opCode, T addrMode)
{
	auto nameResult = _availableModesByOpName.find(opCode);
	if(nameResult != _availableModesByOpName.end()) {
		auto modeResult = nameResult->second.find(addrMode);
		if(modeResult != _availableModesByOpName[opCode].end()) {
			return modeResult->second;
		}
	}
	return -1;
}
template<class T>
void Base6502Assembler<T>::AssembleInstruction(AssemblerLineData& op, uint32_t& instructionAddress, vector<int16_t>& output, bool firstPass)
{
	int16_t result = GetOpByteCode(op.OpCode, op.AddrMode);
	if(result < 0) {
		output.push_back(AssemblerSpecialCodes::InvalidInstruction);
		return;
	}
	uint8_t opCode = (uint8_t)result;
	output.push_back(opCode);
	instructionAddress++;
	for(int i = 0; i < op.OperandCount; i++) {
		instructionAddress += op.Operands[i].ByteCount;
		if(op.Operands[i].ByteCount == 1) {
			output.push_back(op.Operands[i].Value & 0xFF);
		} else if(op.Operands[i].ByteCount == 2) {
			output.push_back(op.Operands[i].Value & 0xFF);
			output.push_back((op.Operands[i].Value >> 8) & 0xFF);
		} else if(op.Operands[i].ByteCount == 3) {
			output.push_back(op.Operands[i].Value & 0xFF);
			output.push_back((op.Operands[i].Value >> 8) & 0xFF);
			output.push_back((op.Operands[i].Value >> 16) & 0xFF);
		}
	}
	output.push_back(AssemblerSpecialCodes::EndOfLine);
}
enum class SnesAddrMode : uint8_t;
template void Base6502Assembler<SnesAddrMode>::ProcessLine(string code, uint32_t& instructionAddress, vector<int16_t>& output, unordered_map<string, uint32_t>& labels, bool firstPass, unordered_map<string, uint32_t>& currentPassLabels);
template bool Base6502Assembler<SnesAddrMode>::IsOpModeAvailable(string& opcode, SnesAddrMode mode);
enum class NesAddrMode;
template void Base6502Assembler<NesAddrMode>::ProcessLine(string code, uint32_t& instructionAddress, vector<int16_t>& output, unordered_map<string, uint32_t>& labels, bool firstPass, unordered_map<string, uint32_t>& currentPassLabels);
template bool Base6502Assembler<NesAddrMode>::IsOpModeAvailable(string& opcode, NesAddrMode mode);
enum class PceAddrMode;
template void Base6502Assembler<PceAddrMode>::ProcessLine(string code, uint32_t& instructionAddress, vector<int16_t>& output, unordered_map<string, uint32_t>& labels, bool firstPass, unordered_map<string, uint32_t>& currentPassLabels);
template bool Base6502Assembler<PceAddrMode>::IsOpModeAvailable(string& opcode, PceAddrMode mode);
```

## File: Core/Debugger/Base6502Assembler.h
```
#pragma once
#include "pch.h"
#include "Shared/CpuType.h"
#include "Debugger/IAssembler.h"
#include "Utilities/StringUtilities.h"
class LabelManager;
template<class T>
class Base6502Assembler : public IAssembler
{
protected:
	enum class OperandType
	{
		None,
		A,
		X,
		Y,
		S,
		Custom
	};
	enum class OperandValueType
	{
		None,
		Decimal,
		Hex,
		Binary,
		Label
	};
	struct AssemblerOperand
	{
		OperandType Type = OperandType::None;
		OperandValueType ValueType = OperandValueType::None;
		int64_t Value = 0;
		int ByteCount = 0;
		int OperandSize = 0;
		bool IsImmediate = false;
		bool HasOpeningParenthesis = false;
		bool HasClosingParenthesis = false;
		bool HasOpeningBracket = false;
		bool HasClosingBracket = false;
		bool HasParenOrBracket()
		{
			return HasOpeningBracket || HasClosingParenthesis || HasOpeningBracket || HasClosingBracket;
		}
	};
	struct AssemblerLineData
	{
		string OpCode;
		T AddrMode = {};
		AssemblerOperand Operands[3] = {};
		int OperandCount = 0;
	};
private:
	unordered_map<string, unordered_map<T, uint8_t>> _availableModesByOpName;
	bool _needSecondPass = false;
	CpuType _cpuType;
	LabelManager* _labelManager;
	void ProcessLine(string code, uint32_t& instructionAddress, vector<int16_t>& output, unordered_map<string, uint32_t>& labels, bool firstPass, unordered_map<string, uint32_t>& currentPassLabels);
	AssemblerSpecialCodes ParseOperand(AssemblerLineData& lineData, string operand, bool firstPass, unordered_map<string, uint32_t>& labels);
	void AssembleInstruction(AssemblerLineData& lineData, uint32_t& instructionAddress, vector<int16_t>& output, bool firstPass);
protected:
	bool IsOpModeAvailable(string& opCode, T mode);
	int16_t GetOpByteCode(string& opCode, T addrMode);
	virtual string GetOpName(uint8_t opcode) = 0;
	virtual T GetOpMode(uint8_t opcode) = 0;
	virtual bool IsOfficialOp(uint8_t opcode) = 0;
	virtual AssemblerSpecialCodes ResolveOpMode(AssemblerLineData& op, uint32_t instructionAddress, bool firstPass) = 0;
	void AdjustOperandSize(AssemblerLineData& op, AssemblerOperand& operand, T orgMode, T extMode)
	{
		if(!IsOpModeAvailable(op.OpCode, orgMode)) {
			op.AddrMode = extMode;
			operand.ByteCount = 2;
		} else {
			op.AddrMode = orgMode;
		}
	}
public:
	Base6502Assembler(LabelManager* labelManager, CpuType cpuType)
	{
		_labelManager = labelManager;
		_cpuType = cpuType;
	}
	virtual ~Base6502Assembler()
	{
	}
	uint32_t AssembleCode(string code, uint32_t startAddress, int16_t* assembledCode)
	{
		for(int i = 0; i < 256; i++) {
			string opName = StringUtilities::ToUpper(GetOpName(i));
			if(_availableModesByOpName.find(opName) == _availableModesByOpName.end()) {
				_availableModesByOpName[opName] = unordered_map<T, uint8_t>();
			}
			T addrMode = GetOpMode(i);
			if(IsOfficialOp(i) || _availableModesByOpName[opName].find(addrMode) == _availableModesByOpName[opName].end()) {
				_availableModesByOpName[opName][addrMode] = i;
			}
		}
		unordered_map<string, uint32_t> temporaryLabels;
		unordered_map<string, uint32_t> currentPassLabels;
		vector<int16_t> output;
		output.reserve(1000);
		uint32_t originalStartAddr = startAddress;
		vector<string> codeLines = StringUtilities::Split(code, '\n');
		_needSecondPass = false;
		for(string& line : codeLines) {
			ProcessLine(line, startAddress, output, temporaryLabels, true, currentPassLabels);
		}
		if(_needSecondPass) {
			vector<int16_t> prevOut;
			int pass = 1;
			do {
				prevOut = output;
				currentPassLabels.clear();
				output.clear();
				startAddress = originalStartAddr;
				for(string& line : codeLines) {
					ProcessLine(line, startAddress, output, temporaryLabels, false, currentPassLabels);
				}
				pass++;
			} while(prevOut != output && pass <= 5);
		}
		memcpy(assembledCode, output.data(), std::min<int>(100000, (int)output.size()) * sizeof(uint16_t));
		return (uint32_t)output.size();
	}
};
```

## File: Core/Debugger/BaseEventManager.cpp
```cpp
#include "pch.h"
#include "Debugger/BaseEventManager.h"
void BaseEventManager::FilterEvents()
{
	auto lock = _lock.AcquireSafe();
	_sentEvents.clear();
	if(ShowPreviousFrameEvents() && !_forAutoRefresh) {
		int offset = GetScanlineOffset();
		uint32_t key = (_snapshotScanline << 16) + _snapshotCycle;
		for(DebugEventInfo& evt : _snapshotPrevFrame) {
			uint32_t evtKey = ((evt.Scanline + offset) << 16) + evt.Cycle;
			if(evtKey > key) {
				EventViewerCategoryCfg eventCfg = GetEventConfig(evt);
				if(eventCfg.Visible) {
					_sentEvents.push_back(evt);
					_sentEvents.back().Flags |= (uint32_t)EventFlags::PreviousFrame;
				}
			}
		}
	}
	for(DebugEventInfo& evt : _snapshotCurrentFrame) {
		EventViewerCategoryCfg eventCfg = GetEventConfig(evt);
		if(eventCfg.Visible) {
			_sentEvents.push_back(evt);
		}
	}
}
void BaseEventManager::DrawDot(uint32_t x, uint32_t y, uint32_t color, bool drawBackground, uint32_t* buffer)
{
	if(drawBackground) {
		color = 0xFF000000 | ((color >> 1) & 0x7F7F7F);
	} else {
		color |= 0xFF000000;
	}
	int iMin = drawBackground ? -2 : 0;
	int iMax = drawBackground ? 3 : 1;
	int jMin = drawBackground ? -2 : 0;
	int jMax = drawBackground ? 3 : 1;
	FrameInfo size = GetDisplayBufferSize();
	for(int i = iMin; i <= iMax; i++) {
		for(int j = jMin; j <= jMax; j++) {
			if(j + x >= size.Width) {
				continue;
			}
			int32_t pos = (y + i) * size.Width + x + j;
			if(pos < 0 || pos >= (int)(size.Width * size.Height)) {
				continue;
			}
			buffer[pos] = color;
		}
	}
}
void BaseEventManager::GetEvents(DebugEventInfo* eventArray, uint32_t& maxEventCount)
{
	auto lock = _lock.AcquireSafe();
	uint32_t eventCount = std::min(maxEventCount, (uint32_t)_sentEvents.size());
	for(uint32_t i = 0; i < eventCount; i++) {
		_sentEvents[i].Color = GetEventConfig(_sentEvents[i]).Color;
	}
	memcpy(eventArray, _sentEvents.data(), eventCount * sizeof(DebugEventInfo));
	maxEventCount = eventCount;
}
uint32_t BaseEventManager::GetEventCount()
{
	auto lock = _lock.AcquireSafe();
	FilterEvents();
	return (uint32_t)_sentEvents.size();
}
void BaseEventManager::ClearFrameEvents()
{
	_prevDebugEvents = _debugEvents;
	_debugEvents.clear();
}
void BaseEventManager::GetDisplayBuffer(uint32_t* buffer, uint32_t bufferSize)
{
	auto lock = _lock.AcquireSafe();
	FrameInfo size = GetDisplayBufferSize();
	if(_snapshotScanline < 0 || bufferSize < size.Width * size.Height * sizeof(uint32_t)) {
		return;
	}
	for(uint32_t i = 0; i < size.Width * size.Height; i++) {
		buffer[i] = 0xFF555555;
	}
	DrawScreen(buffer);
	DrawEvents(buffer, size);
}
void BaseEventManager::DrawLine(uint32_t* buffer, FrameInfo size, uint32_t color, uint32_t row)
{
	int32_t x = 0;
	int32_t y = row - GetScanlineOffset();
	ConvertScanlineCycleToRowColumn(x, y);
	uint32_t offset = y * size.Width;
	for(int i = 0; i < (int)size.Width; i++) {
		buffer[offset + i] = color;
		buffer[offset + size.Width + i] = color;
	}
}
void BaseEventManager::DrawEvent(DebugEventInfo& evt, bool drawBackground, uint32_t* buffer)
{
	EventViewerCategoryCfg evtCfg = GetEventConfig(evt);
	uint32_t color = evtCfg.Color;
	int32_t y = evt.Scanline;
	int32_t x = evt.Cycle;
	ConvertScanlineCycleToRowColumn(x, y);
	DrawDot(x, y, color, drawBackground, buffer);
}
void BaseEventManager::DrawEvents(uint32_t* buffer, FrameInfo size)
{
	if(!_forAutoRefresh) {
		DrawLine(buffer, size, 0xFFFFFF55, _snapshotScanline);
	}
	FilterEvents();
	for(DebugEventInfo& evt : _sentEvents) {
		DrawEvent(evt, true, buffer);
	}
	for(DebugEventInfo& evt : _sentEvents) {
		DrawEvent(evt, false, buffer);
	}
	if(!_forAutoRefresh) {
		int32_t y = _snapshotScanline + _snapshotScanlineOffset;
		int32_t x = _snapshotCycle;
		ConvertScanlineCycleToRowColumn(x, y);
		DrawDot(x, y, 0xFF990099, true, buffer);
		DrawDot(x, y, 0xFFFF00FF, false, buffer);
	}
}
```

## File: Core/Debugger/BaseEventManager.h
```
#pragma once
#include "pch.h"
#include "Debugger/DebugTypes.h"
#include "Shared/SettingTypes.h"
#include "Utilities/SimpleLock.h"
#include "SNES/DmaControllerTypes.h"
enum class EventFlags
{
	PreviousFrame = 1 << 0,
	RegFirstWrite = 1 << 1,
	RegSecondWrite = 1 << 2,
	WithTargetMemory = 1 << 3,
	SmsVdpPaletteWrite = 1 << 4,
	ReadWriteOp = 1 << 5,
};
struct DebugEventInfo
{
	MemoryOperationInfo Operation;
	DebugEventType Type;
	uint32_t ProgramCounter;
	int16_t Scanline;
	uint16_t Cycle;
	int16_t BreakpointId = -1;
	int8_t DmaChannel = -1;
	DmaChannelConfig DmaChannelInfo;
	uint32_t Flags;
	int32_t RegisterId = -1;
	MemoryOperationInfo TargetMemory;
	uint32_t Color = 0;
};
struct EventViewerCategoryCfg
{
	bool Visible;
	uint32_t Color;
};
struct BaseEventViewerConfig
{
};
class BaseEventManager
{
protected:
	vector<DebugEventInfo> _debugEvents;
	vector<DebugEventInfo> _prevDebugEvents;
	vector<DebugEventInfo> _sentEvents;
	vector<DebugEventInfo> _snapshotCurrentFrame;
	vector<DebugEventInfo> _snapshotPrevFrame;
	int16_t _snapshotScanline = -1;
	int16_t _snapshotScanlineOffset = 0;
	uint16_t _snapshotCycle = 0;
	bool _forAutoRefresh = false;
	SimpleLock _lock;
	virtual bool ShowPreviousFrameEvents() = 0;
	void FilterEvents();
	void DrawDot(uint32_t x, uint32_t y, uint32_t color, bool drawBackground, uint32_t* buffer);
	virtual int GetScanlineOffset() { return 0; }
	void DrawLine(uint32_t* buffer, FrameInfo size, uint32_t color, uint32_t row);
	void DrawEvents(uint32_t* buffer, FrameInfo size);
	virtual void ConvertScanlineCycleToRowColumn(int32_t& x, int32_t& y) = 0;
	virtual void DrawScreen(uint32_t* buffer) = 0;
	void DrawEvent(DebugEventInfo& evt, bool drawBackground, uint32_t* buffer);
public:
	virtual ~BaseEventManager() {}
	virtual void SetConfiguration(BaseEventViewerConfig& config) = 0;
	virtual void AddEvent(DebugEventType type, MemoryOperationInfo& operation, int32_t breakpointId = -1) = 0;
	virtual void AddEvent(DebugEventType type) = 0;
	void GetEvents(DebugEventInfo* eventArray, uint32_t& maxEventCount);
	uint32_t GetEventCount();
	virtual void ClearFrameEvents();
	virtual EventViewerCategoryCfg GetEventConfig(DebugEventInfo& evt) = 0;
	virtual uint32_t TakeEventSnapshot(bool forAutoRefresh) = 0;
	virtual FrameInfo GetDisplayBufferSize() = 0;
	virtual DebugEventInfo GetEvent(uint16_t scanline, uint16_t cycle) = 0;
	void GetDisplayBuffer(uint32_t* buffer, uint32_t bufferSize);
};
```

## File: Core/Debugger/BaseTraceLogger.h
```
#pragma once
#include "pch.h"
#include <regex>
#include "Utilities/SimpleLock.h"
#include "Debugger/DisassemblyInfo.h"
#include "Debugger/Debugger.h"
#include "Debugger/IDebugger.h"
#include "Debugger/DebugTypes.h"
#include "Debugger/LabelManager.h"
#include "Debugger/DebugTypes.h"
#include "Debugger/DebugUtilities.h"
#include "Debugger/DebugBreakHelper.h"
#include "Debugger/ITraceLogger.h"
#include "Debugger/ExpressionEvaluator.h"
#include "Debugger/TraceLogFileSaver.h"
#include "Utilities/HexUtilities.h"
#include "Shared/Emulator.h"
#include "Shared/EmuSettings.h"
class IConsole;
class Debugger;
class LabelManager;
class MemoryDumper;
class EmuSettings;
enum class RowDataType
{
	Text = 0,
	ByteCode,
	Disassembly,
	EffectiveAddress,
	MemoryValue,
	Align,
	PC,
	A,
	B,
	C,
	D,
	E,
	F,
	H,
	I,
	K,
	L,
	M,
	N,
	R,
	X,
	Y,
	AltA,
	AltB,
	AltC,
	AltD,
	AltE,
	AltF,
	AltH,
	AltL,
	IX,
	IY,
	DB,
	SP,
	PS,
	Cycle,
	Scanline,
	HClock,
	FrameCount,
	CycleCount,
	R0,
	R1,
	R2,
	R3,
	R4,
	R5,
	R6,
	R7,
	R8,
	R9,
	R10,
	R11,
	R12,
	R13,
	R14,
	R15,
	Src,
	Dst,
	SFR,
	MAR,
	MDR,
	DPR,
	ML,
	MH,
	PB,
	P,
	RP,
	DP,
	DR,
	SR,
	TR,
	TRB,
	FlagsA,
	FlagsB,
	CPSR,
	Mode,
	AX,
	BX,
	CX,
	DX,
	CS,
	IP,
	SS,
	BP,
	DS,
	ES,
	SI,
	DI
};
struct TraceLogPpuState
{
	uint32_t Cycle;
	uint32_t HClock;
	int32_t Scanline;
	uint32_t FrameCount;
};
struct RowPart
{
	RowDataType DataType;
	string Text;
	bool DisplayInHex;
	int MinWidth;
};
template<typename TraceLoggerType, typename CpuStateType>
class BaseTraceLogger : public ITraceLogger
{
protected:
	static constexpr int ExecutionLogSize = 30000;
	TraceLoggerOptions _options;
	IConsole* _console;
	EmuSettings* _settings;
	LabelManager* _labelManager;
	MemoryDumper* _memoryDumper;
	Debugger* _debugger;
	CpuType _cpuType = CpuType::Snes;
	MemoryType _cpuMemoryType = MemoryType::SnesMemory;
	vector<RowPart> _rowParts;
	uint32_t _currentPos = 0;
	bool _pendingLog = false;
	CpuStateType _lastState = {};
	DisassemblyInfo _lastDisassemblyInfo = {};
	CpuStateType* _cpuState = nullptr;
	DisassemblyInfo *_disassemblyCache = nullptr;
	uint64_t* _rowIds = nullptr;
	TraceLogPpuState* _ppuState = nullptr;
	unique_ptr<ExpressionEvaluator> _expEvaluator;
	ExpressionData _conditionData;
	void WriteByteCode(DisassemblyInfo& info, RowPart& rowPart, string& output)
	{
		string byteCode;
		info.GetByteCode(byteCode);
		if(!rowPart.DisplayInHex) {
			byteCode.erase(std::remove(byteCode.begin(), byteCode.end(), '$'), byteCode.end());
		}
		WriteStringValue(output, byteCode, rowPart);
	}
	void WriteDisassembly(DisassemblyInfo& info, RowPart& rowPart, uint8_t sp, uint32_t pc, string& output)
	{
		int indentLevel = 0;
		size_t startPos = output.size();
		if(_options.IndentCode) {
			indentLevel = 0xFF - (sp & 0xFF);
			output += std::string(indentLevel / 2, ' ');
		}
		LabelManager* labelManager = _options.UseLabels ? _labelManager : nullptr;
		info.GetDisassembly(output, pc, labelManager, _settings);
		if(rowPart.MinWidth > (int)(output.size() - startPos)) {
			output += std::string(rowPart.MinWidth - (output.size() - startPos), ' ');
		}
	}
	void WriteEffectiveAddress(DisassemblyInfo& info, RowPart& rowPart, void* cpuState, string& output, MemoryType cpuMemoryType, CpuType cpuType)
	{
		EffectiveAddressInfo effectiveAddress = info.GetEffectiveAddress(_debugger, cpuState, cpuType);
		if(effectiveAddress.ShowAddress && effectiveAddress.Address >= 0) {
			MemoryType effectiveMemType = effectiveAddress.Type == MemoryType::None ? cpuMemoryType : effectiveAddress.Type;
			if(_options.UseLabels) {
				AddressInfo addr { (int32_t)effectiveAddress.Address, effectiveMemType };
				string label = _labelManager->GetLabel(addr);
				if(!label.empty()) {
					if(label.size() > 2 && label[label.size() - 1] == '0' && label[label.size() - 2] == '+') {
						WriteStringValue(output, " [" + label.substr(0, label.size() - 2) + "]", rowPart);
					} else {
						WriteStringValue(output, " [" + label + "]", rowPart);
					}
					return;
				}
			}
			WriteStringValue(output, " [$" + DebugUtilities::AddressToHex(cpuType, effectiveAddress.Address) + "]", rowPart);
		}
	}
	void WriteMemoryValue(DisassemblyInfo& info, RowPart& rowPart, void* cpuState, string& output, MemoryType memType, CpuType cpuType)
	{
		EffectiveAddressInfo effectiveAddress = info.GetEffectiveAddress(_debugger, cpuState, cpuType);
		if(effectiveAddress.Address >= 0 && effectiveAddress.ValueSize > 0) {
			MemoryType effectiveMemType = effectiveAddress.Type == MemoryType::None ? memType : effectiveAddress.Type;
			uint16_t value = info.GetMemoryValue(effectiveAddress, _memoryDumper, effectiveMemType);
			if(rowPart.DisplayInHex) {
				output += "= $";
				if(effectiveAddress.ValueSize == 2) {
					WriteIntValue(output, (uint16_t)value, rowPart);
				} else {
					WriteIntValue(output, (uint8_t)value, rowPart);
				}
			} else {
				output += "= ";
			}
		}
	}
	void GetStatusFlag(const char* activeStatusLetters, const char* inactiveStatusLetters, string& output, uint32_t ps, RowPart& part, int length = 8)
	{
		if(part.DisplayInHex) {
			WriteIntValue(output, ps, part);
		} else {
			string flags;
			for(int i = 0; i < length; i++) {
				if(ps & (1 << (length - 1))) {
					flags += activeStatusLetters[i];
				} else if(part.MinWidth >= length) {
					flags += inactiveStatusLetters[i];
				}
				ps <<= 1;
			}
			WriteStringValue(output, flags, part);
		}
	}
	void WriteAlign(int originalSize, RowPart& rowPart, string& output)
	{
		if((int)output.size() - originalSize < rowPart.MinWidth) {
			output.append(rowPart.MinWidth - (output.size() - originalSize), ' ');
		}
	}
	template<typename T>
	void WriteIntValue(string& output, T value, RowPart& rowPart)
	{
		string str = rowPart.DisplayInHex ? HexUtilities::ToHex(value) : std::to_string(value);
		if(rowPart.MinWidth > (int)str.size()) {
			if(rowPart.DisplayInHex) {
				str = std::string(rowPart.MinWidth - str.size(), '0') + str;
			} else {
				str += std::string(rowPart.MinWidth - str.size(), ' ');
			}
		}
		output += str;
	}
	void WriteStringValue(string& output, string value, RowPart& rowPart)
	{
		output += value;
		if(rowPart.MinWidth > (int)value.size()) {
			output += std::string(rowPart.MinWidth - value.size(), ' ');
		}
	}
	void AddRow(CpuStateType& cpuState, DisassemblyInfo& disassemblyInfo)
	{
		_disassemblyCache[_currentPos] = disassemblyInfo;
		_cpuState[_currentPos] = cpuState;
		((TraceLoggerType*)this)->LogPpuState();
		_rowIds[_currentPos] = ITraceLogger::NextRowId;
		ITraceLogger::NextRowId++;
		_pendingLog = false;
		if(_debugger->GetTraceLogFileSaver()->IsEnabled()) {
			string row;
			row.reserve(300);
			RowPart rowPart = {};
			rowPart.DisplayInHex = true;
			rowPart.MinWidth = DebugUtilities::GetProgramCounterSize(_cpuType);
			WriteIntValue(row, ((TraceLoggerType*)this)->GetProgramCounter(cpuState), rowPart);
			row += "  ";
			((TraceLoggerType*)this)->GetTraceRow(row, cpuState, _ppuState[_currentPos], disassemblyInfo);
			_debugger->GetTraceLogFileSaver()->Log(row);
		}
		_currentPos = (_currentPos + 1) % ExecutionLogSize;
	}
	void ParseFormatString(string format)
	{
		_rowParts.clear();
		std::regex formatRegex = std::regex("(\\[\\s*([^[]*?)\\s*(,\\s*([\\d]*)\\s*(h){0,1}){0,1}\\s*\\])|([^[]*)", std::regex_constants::icase);
		std::sregex_iterator start = std::sregex_iterator(format.cbegin(), format.cend(), formatRegex);
		std::sregex_iterator end = std::sregex_iterator();
		for(std::sregex_iterator it = start; it != end; it++) {
			const std::smatch& match = *it;
			if(match.str(1) == "") {
				RowPart part = {};
				part.DataType = RowDataType::Text;
				part.Text = match.str(6);
				_rowParts.push_back(part);
			} else {
				RowPart part = {};
				string tag = match.str(2);
				part.DataType = InternalGetFormatTagType(tag);
				if(part.DataType == RowDataType::Text) {
					part.Text = "[Invalid tag]";
				}
				if(!match.str(4).empty()) {
					try {
						part.MinWidth = std::stoi(match.str(4));
					} catch(std::exception&) {
					}
				}
				part.DisplayInHex = match.str(5) == "h";
				_rowParts.push_back(part);
			}
		}
	}
	RowDataType InternalGetFormatTagType(string& tag)
	{
		if(tag == "ByteCode") {
			return RowDataType::ByteCode;
		} else if(tag == "Disassembly") {
			return RowDataType::Disassembly;
		} else if(tag == "EffectiveAddress") {
			return RowDataType::EffectiveAddress;
		} else if(tag == "MemoryValue") {
			return RowDataType::MemoryValue;
		} else if(tag == "Align") {
			return RowDataType::Align;
		} else if(tag == "PC") {
			return RowDataType::PC;
		} else if(tag == "Cycle") {
			return RowDataType::Cycle;
		} else if(tag == "HClock") {
			return RowDataType::HClock;
		} else if(tag == "Scanline") {
			return RowDataType::Scanline;
		} else if(tag == "FrameCount") {
			return RowDataType::FrameCount;
		} else if(tag == "CycleCount") {
			return RowDataType::CycleCount;
		}
		return GetFormatTagType(tag);
	}
	virtual RowDataType GetFormatTagType(string& tag) = 0;
	void ProcessSharedTag(RowPart& rowPart, string& output, CpuStateType& cpuState, TraceLogPpuState& ppuState, DisassemblyInfo& disassemblyInfo)
	{
		switch(rowPart.DataType) {
			case RowDataType::Text: output += rowPart.Text; break;
			case RowDataType::ByteCode: WriteByteCode(disassemblyInfo, rowPart, output); break;
			case RowDataType::Disassembly: WriteDisassembly(disassemblyInfo, rowPart, ((TraceLoggerType*)this)->GetStackPointer(cpuState), ((TraceLoggerType*)this)->GetProgramCounter(cpuState), output); break;
			case RowDataType::EffectiveAddress: WriteEffectiveAddress(disassemblyInfo, rowPart, &cpuState, output, _cpuMemoryType, _cpuType); break;
			case RowDataType::MemoryValue: WriteMemoryValue(disassemblyInfo, rowPart, &cpuState, output, _cpuMemoryType, _cpuType); break;
			case RowDataType::Align: WriteAlign(0, rowPart, output); break;
			case RowDataType::Cycle: WriteIntValue(output, ppuState.Cycle, rowPart); break;
			case RowDataType::Scanline: WriteIntValue(output, ppuState.Scanline, rowPart); break;
			case RowDataType::HClock: WriteIntValue(output, ppuState.HClock, rowPart); break;
			case RowDataType::FrameCount: WriteIntValue(output, ppuState.FrameCount, rowPart); break;
			case RowDataType::CycleCount: WriteIntValue(output, (uint64_t)((TraceLoggerType*)this)->GetCycleCount(cpuState), rowPart); break;
			case RowDataType::PC: WriteStringValue(output, HexUtilities::ToHex(((TraceLoggerType*)this)->GetProgramCounter(cpuState)), rowPart); break;
		}
	}
public:
	BaseTraceLogger(Debugger* debugger, IDebugger* cpuDebugger, CpuType cpuType)
	{
		_debugger = debugger;
		_console = debugger->GetConsole();
		_settings = debugger->GetEmulator()->GetSettings();
		_labelManager = debugger->GetLabelManager();
		_memoryDumper = debugger->GetMemoryDumper();
		_options = {};
		_currentPos = 0;
		_pendingLog = false;
		_disassemblyCache = new DisassemblyInfo[BaseTraceLogger::ExecutionLogSize];
		_rowIds = new uint64_t[BaseTraceLogger::ExecutionLogSize];
		memset(_disassemblyCache, 0, sizeof(DisassemblyInfo) * BaseTraceLogger::ExecutionLogSize);
		memset(_rowIds, 0, sizeof(uint64_t) * BaseTraceLogger::ExecutionLogSize);
		_ppuState = new TraceLogPpuState[BaseTraceLogger::ExecutionLogSize];
		memset(_ppuState, 0, sizeof(TraceLogPpuState) * BaseTraceLogger::ExecutionLogSize);
		_cpuState = new CpuStateType[BaseTraceLogger::ExecutionLogSize];
		memset(_cpuState, 0, sizeof(CpuStateType) * BaseTraceLogger::ExecutionLogSize);
		_cpuType = cpuType;
		_cpuMemoryType = DebugUtilities::GetCpuMemoryType(cpuType);
		_expEvaluator.reset(new ExpressionEvaluator(debugger, cpuDebugger, cpuType));
	}
	virtual ~BaseTraceLogger()
	{
		delete[] _disassemblyCache;
		delete[] _rowIds;
		delete[] _ppuState;
		delete[] _cpuState;
	}
	void Clear() override
	{
		_currentPos = 0;
		memset(_rowIds, 0, sizeof(uint64_t) * BaseTraceLogger::ExecutionLogSize);
	}
	void LogNonExec(MemoryOperationInfo& operation, AddressInfo& addressInfo)
	{
		if(_pendingLog) {
			int pos = _currentPos - 1;
			if(pos < 0) {
				pos = BaseTraceLogger::ExecutionLogSize - 1;
			}
			if(ConditionMatches(_lastDisassemblyInfo, operation, addressInfo)) {
				AddRow(_lastState, _lastDisassemblyInfo);
				_pendingLog = false;
			}
		}
	}
	void Log(CpuStateType& cpuState, DisassemblyInfo& disassemblyInfo, MemoryOperationInfo& operation, AddressInfo& addressInfo)
	{
		if(_enabled) {
			if(ConditionMatches(disassemblyInfo, operation, addressInfo)) {
				AddRow(cpuState, disassemblyInfo);
			} else {
				_pendingLog = true;
				_lastState = cpuState;
				_lastDisassemblyInfo = disassemblyInfo;
			}
		}
	}
	void SetOptions(TraceLoggerOptions options) override
	{
		DebugBreakHelper helper(_debugger);
		_options = options;
		_enabled = options.Enabled;
		string condition = _options.Condition;
		string format = _options.Format;
		_conditionData = ExpressionData();
		if(!condition.empty()) {
			bool success = false;
			ExpressionData rpnList = _expEvaluator->GetRpnList(condition, success);
			if(success) {
				_conditionData = rpnList;
			}
		}
		ParseFormatString(format);
		_debugger->ProcessConfigChange();
	}
	int64_t GetRowId(uint32_t offset) override
	{
		int32_t pos = ((int32_t)_currentPos - (int32_t)offset);
		int32_t i = (pos > 0 ? pos : BaseTraceLogger::ExecutionLogSize + pos) - 1;
		if(!_disassemblyCache[i].IsInitialized()) {
			return -1;
		}
		return _rowIds[i];
	}
	bool ConditionMatches(DisassemblyInfo &disassemblyInfo, MemoryOperationInfo &operationInfo, AddressInfo& addressInfo)
	{
		if(!_conditionData.RpnQueue.empty()) {
			EvalResultType type;
			if(!_expEvaluator->Evaluate(_conditionData, type, operationInfo, addressInfo)) {
				return false;
			}
		}
		return true;
	}
	void GetExecutionTrace(TraceRow& row, uint32_t offset) override
	{
		int pos = ((int)_currentPos - offset);
		int index = (pos > 0 ? pos : BaseTraceLogger::ExecutionLogSize + pos) - 1;
		CpuStateType& state = _cpuState[index];
		string logOutput;
		logOutput.reserve(300);
		((TraceLoggerType*)this)->GetTraceRow(logOutput, state, _ppuState[index], _disassemblyCache[index]);
		row.Type = _cpuType;
		_disassemblyCache[index].GetByteCode(row.ByteCode);
		row.ByteCodeSize = _disassemblyCache[index].GetOpSize();
		row.ProgramCounter = ((TraceLoggerType*)this)->GetProgramCounter(state);
		row.LogSize = std::min<uint32_t>(499, (uint32_t)logOutput.size());
		memcpy(row.LogOutput, logOutput.c_str(), row.LogSize);
		row.LogOutput[row.LogSize] = 0;
	}
};
```

## File: Core/Debugger/Breakpoint.cpp
```cpp
#include "pch.h"
#include "Debugger/Breakpoint.h"
#include "Debugger/DebugTypes.h"
#include "Debugger/DebugUtilities.h"
template<uint8_t accessWidth>
bool Breakpoint::Matches(MemoryOperationInfo& operation, AddressInfo &info)
{
	if(operation.MemType == _memoryType && DebugUtilities::IsRelativeMemory(_memoryType)) {
		for(int i = 0; i < accessWidth; i++) {
			if((int32_t)operation.Address + i >= _startAddr && (int32_t)operation.Address + i <= _endAddr) {
				return true;
			}
		}
		return false;
	} else if(_memoryType == info.Type) {
		for(int i = 0; i < accessWidth; i++) {
			if(info.Address + i >= _startAddr && info.Address + i <= _endAddr) {
				return true;
			}
		}
		return false;
	}
	return false;
}
bool Breakpoint::HasBreakpointType(BreakpointType type)
{
	switch(type) {
		default:
		case BreakpointType::Execute: return ((uint8_t)_type & (uint8_t)BreakpointTypeFlags::Execute) != 0;
		case BreakpointType::Read: return ((uint8_t)_type & (uint8_t)BreakpointTypeFlags::Read) != 0;
		case BreakpointType::Write: return ((uint8_t)_type & (uint8_t)BreakpointTypeFlags::Write) != 0;
		case BreakpointType::Forbid: return ((uint8_t)_type & (uint8_t)BreakpointTypeFlags::Forbid) != 0;
	}
}
string Breakpoint::GetCondition()
{
	return _condition;
}
bool Breakpoint::HasCondition()
{
	return _condition[0] != 0;
}
uint32_t Breakpoint::GetId()
{
	return _id;
}
CpuType Breakpoint::GetCpuType()
{
	return _cpuType;
}
bool Breakpoint::IsEnabled()
{
	return _enabled;
}
bool Breakpoint::IsMarked()
{
	return _markEvent;
}
bool Breakpoint::IsAllowedForOpType(MemoryOperationType opType)
{
	if(_ignoreDummyOperations) {
		return opType != MemoryOperationType::DummyRead && opType != MemoryOperationType::DummyWrite;
	}
	return true;
}
template bool Breakpoint::Matches<1>(MemoryOperationInfo& operation, AddressInfo& info);
template bool Breakpoint::Matches<2>(MemoryOperationInfo& operation, AddressInfo& info);
template bool Breakpoint::Matches<4>(MemoryOperationInfo& operation, AddressInfo& info);
```

## File: Core/Debugger/Breakpoint.h
```
#pragma once
#include "pch.h"
enum class CpuType : uint8_t;
enum class MemoryType;
struct AddressInfo;
enum class BreakpointType;
enum class BreakpointTypeFlags;
enum class MemoryOperationType;
struct MemoryOperationInfo;
class Breakpoint
{
public:
	template<uint8_t accessWidth = 1> bool Matches(MemoryOperationInfo &opInfo, AddressInfo &info);
	bool HasBreakpointType(BreakpointType type);
	string GetCondition();
	bool HasCondition();
	uint32_t GetId();
	CpuType GetCpuType();
	bool IsEnabled();
	bool IsMarked();
	bool IsAllowedForOpType(MemoryOperationType opType);
private:
	uint32_t _id;
	CpuType _cpuType;
	MemoryType _memoryType;
	BreakpointTypeFlags _type;
	int32_t _startAddr;
	int32_t _endAddr;
	bool _enabled;
	bool _markEvent;
	bool _ignoreDummyOperations;
	char _condition[1000];
};
```

## File: Core/Debugger/BreakpointManager.cpp
```cpp
#include "pch.h"
#include "Debugger/BreakpointManager.h"
#include "Debugger/DebugTypes.h"
#include "Debugger/Debugger.h"
#include "Debugger/Breakpoint.h"
#include "Debugger/DebugUtilities.h"
#include "Debugger/ExpressionEvaluator.h"
#include "Debugger/BaseEventManager.h"
#include "Shared/MemoryOperationType.h"
BreakpointManager::BreakpointManager(Debugger *debugger, IDebugger* cpuDebugger, CpuType cpuType, BaseEventManager* eventManager)
{
	_debugger = debugger;
	_cpuDebugger = cpuDebugger;
	_cpuType = cpuType;
	_hasBreakpoint = false;
	_eventManager = eventManager;
}
void BreakpointManager::SetBreakpoints(Breakpoint breakpoints[], uint32_t count)
{
	_hasBreakpoint = false;
	for(int i = 0; i < BreakpointManager::BreakpointTypeCount; i++) {
		_breakpoints[i].clear();
		_rpnList[i].clear();
		_hasBreakpointType[i] = false;
	}
	_forbidBreakpoints.clear();
	_forbidRpn.clear();
	_bpExpEval.reset(new ExpressionEvaluator(_debugger, _cpuDebugger, _cpuType));
	for(uint32_t j = 0; j < count; j++) {
		Breakpoint &bp = breakpoints[j];
		if(bp.HasBreakpointType(BreakpointType::Forbid)) {
			if(_cpuType == bp.GetCpuType() && bp.IsEnabled()) {
				if(bp.HasCondition()) {
					bool success = true;
					ExpressionData data = _bpExpEval->GetRpnList(bp.GetCondition(), success);
					_forbidRpn.push_back(success ? data : ExpressionData());
				} else {
					_forbidRpn.push_back(ExpressionData());
				}
				_forbidBreakpoints.push_back(bp);
			}
			continue;
		}
		for(int i = 0; i < BreakpointManager::BreakpointTypeCount; i++) {
			MemoryOperationType opType = (MemoryOperationType)i;
			if((bp.IsMarked() || bp.IsEnabled()) && bp.HasBreakpointType(GetBreakpointType(opType))) {
				CpuType cpuType = bp.GetCpuType();
				if(_cpuType != cpuType) {
					continue;
				}
				if(bp.IsAllowedForOpType(opType)) {
					_breakpoints[i].push_back(bp);
				}
				if(bp.HasCondition()) {
					bool success = true;
					ExpressionData data = _bpExpEval->GetRpnList(bp.GetCondition(), success);
					_rpnList[i].push_back(success ? data : ExpressionData());
				} else {
					_rpnList[i].push_back(ExpressionData());
				}
				_hasBreakpoint = true;
				_hasBreakpointType[i] = true;
			}
		}
	}
}
bool BreakpointManager::IsForbidden(MemoryOperationInfo* memoryOpPtr, AddressInfo& relAddr, AddressInfo& absAddr)
{
	MemoryOperationInfo memoryOp = memoryOpPtr != nullptr ? *memoryOpPtr : MemoryOperationInfo {};
	MemoryOperationInfo op;
	op.Address = relAddr.Address;
	op.MemType = relAddr.Type;
	for(size_t i = 0, len = _forbidBreakpoints.size(); i < len; i++) {
		if(_forbidBreakpoints[i].Matches(op, absAddr)) {
			EvalResultType resultType;
			if(_forbidBreakpoints[i].HasCondition() && !_bpExpEval->Evaluate(_forbidRpn[i], resultType, memoryOp, absAddr)) {
				continue;
			}
			return true;
		}
	}
	return false;
}
BreakpointType BreakpointManager::GetBreakpointType(MemoryOperationType type)
{
	switch(type) {
		case MemoryOperationType::ExecOperand:
		case MemoryOperationType::ExecOpCode:
			return BreakpointType::Execute;
		case MemoryOperationType::DmaRead:
		case MemoryOperationType::Read:
		case MemoryOperationType::DummyRead:
		case MemoryOperationType::PpuRenderingRead:
			return BreakpointType::Read;
		case MemoryOperationType::DmaWrite:
		case MemoryOperationType::Write:
		case MemoryOperationType::DummyWrite:
			return BreakpointType::Write;
		default:
			throw std::runtime_error("Unsupported memory operation type");
	}
}
template<uint8_t accessWidth>
int BreakpointManager::InternalCheckBreakpoint(MemoryOperationInfo operationInfo, AddressInfo &address, bool processMarkedBreakpoints)
{
	EvalResultType resultType;
	vector<Breakpoint> &breakpoints = _breakpoints[(int)operationInfo.Type];
	for(size_t i = 0, len = breakpoints.size(); i < len; i++) {
		if(breakpoints[i].Matches<accessWidth>(operationInfo, address)) {
			if(breakpoints[i].HasCondition() && !_bpExpEval->Evaluate(_rpnList[(int)operationInfo.Type][i], resultType, operationInfo, address)) {
				continue;
			}
			if(breakpoints[i].IsMarked() && processMarkedBreakpoints) {
				_eventManager->AddEvent(DebugEventType::Breakpoint, operationInfo, breakpoints[i].GetId());
			}
			if(breakpoints[i].IsEnabled()) {
				return breakpoints[i].GetId();
			}
		}
	}
	return -1;
}
template int BreakpointManager::InternalCheckBreakpoint<1>(MemoryOperationInfo operationInfo, AddressInfo& address, bool processMarkedBreakpoints);
template int BreakpointManager::InternalCheckBreakpoint<2>(MemoryOperationInfo operationInfo, AddressInfo& address, bool processMarkedBreakpoints);
template int BreakpointManager::InternalCheckBreakpoint<4>(MemoryOperationInfo operationInfo, AddressInfo& address, bool processMarkedBreakpoints);
```

## File: Core/Debugger/BreakpointManager.h
```
#pragma once
#include "pch.h"
#include "Debugger/Breakpoint.h"
#include "Debugger/DebugTypes.h"
#include "Debugger/DebugUtilities.h"
class ExpressionEvaluator;
class Debugger;
class IDebugger;
class BaseEventManager;
struct ExpressionData;
enum class MemoryOperationType;
class BreakpointManager
{
private:
	static constexpr int BreakpointTypeCount = (int)MemoryOperationType::PpuRenderingRead + 1;
	Debugger* _debugger;
	IDebugger *_cpuDebugger;
	CpuType _cpuType;
	BaseEventManager *_eventManager;
	vector<Breakpoint> _breakpoints[BreakpointTypeCount];
	vector<ExpressionData> _rpnList[BreakpointTypeCount];
	bool _hasBreakpoint;
	bool _hasBreakpointType[BreakpointTypeCount] = {};
	vector<Breakpoint> _forbidBreakpoints;
	vector<ExpressionData> _forbidRpn;
	unique_ptr<ExpressionEvaluator> _bpExpEval;
	BreakpointType GetBreakpointType(MemoryOperationType type);
	template<uint8_t accessWidth> int InternalCheckBreakpoint(MemoryOperationInfo operationInfo, AddressInfo &address, bool processMarkedBreakpoints);
public:
	BreakpointManager(Debugger *debugger, IDebugger* cpuDebugger, CpuType cpuType, BaseEventManager* eventManager);
	void SetBreakpoints(Breakpoint breakpoints[], uint32_t count);
	bool IsForbidden(MemoryOperationInfo* memoryOpPtr, AddressInfo& relAddr, AddressInfo& absAddr);
	__forceinline bool HasBreakpoints() { return _hasBreakpoint; }
	__forceinline bool HasBreakpointForType(MemoryOperationType opType);
	template<uint8_t accessWidth = 1> __forceinline int CheckBreakpoint(MemoryOperationInfo operationInfo, AddressInfo &address, bool processMarkedBreakpoints);
};
__forceinline bool BreakpointManager::HasBreakpointForType(MemoryOperationType opType)
{
	return _hasBreakpointType[(int)opType];
}
template<uint8_t accessWidth>
__forceinline int BreakpointManager::CheckBreakpoint(MemoryOperationInfo operationInfo, AddressInfo &address, bool processMarkedBreakpoints)
{
	if(!_hasBreakpointType[(int)operationInfo.Type]) {
		return -1;
	}
	return InternalCheckBreakpoint<accessWidth>(operationInfo, address, processMarkedBreakpoints);
}
```

## File: Core/Debugger/CallstackManager.cpp
```cpp
#include "pch.h"
#include "Debugger/CallstackManager.h"
#include "Debugger/Debugger.h"
#include "Debugger/IDebugger.h"
#include "Debugger/DebugBreakHelper.h"
#include "Debugger/Profiler.h"
CallstackManager::CallstackManager(Debugger* debugger, IDebugger* cpuDebugger)
{
	_debugger = debugger;
	_profiler.reset(new Profiler(debugger, cpuDebugger));
}
CallstackManager::~CallstackManager()
{
}
void CallstackManager::Push(AddressInfo &src, uint32_t srcAddr, AddressInfo& dest, uint32_t destAddr, AddressInfo& ret, uint32_t returnAddress, uint32_t returnStackPointer, StackFrameFlags flags)
{
	if(_callstack.size() >= 511) {
		_callstack.pop_front();
	}
	StackFrameInfo stackFrame;
	stackFrame.Source = srcAddr;
	stackFrame.AbsSource = src;
	stackFrame.Target = destAddr;
	stackFrame.AbsTarget = dest;
	stackFrame.Return = returnAddress;
	stackFrame.ReturnStackPointer = returnStackPointer;
	stackFrame.AbsReturn = ret;
	stackFrame.Flags = flags;
	_callstack.push_back(stackFrame);
	_profiler->StackFunction(dest, flags);
}
void CallstackManager::Pop(AddressInfo& dest, uint32_t destAddress, uint32_t stackPointer)
{
	if(_callstack.empty()) {
		return;
	}
	StackFrameInfo prevFrame = _callstack.back();
	_callstack.pop_back();
	_profiler->UnstackFunction();
	uint32_t returnAddr = prevFrame.Return;
	if(!_callstack.empty() && destAddress != returnAddr) {
		bool foundMatch = false;
		for(int i = (int)_callstack.size() - 1; i >= 0; i--) {
			if(destAddress == _callstack[i].Return) {
				foundMatch = true;
				for(int j = (int)_callstack.size() - i - 1; j >= 0; j--) {
					_callstack.pop_back();
					_profiler->UnstackFunction();
				}
				break;
			}
		}
		if(!foundMatch) {
			if(_callstack.back().ReturnStackPointer != stackPointer) {
				Push(prevFrame.AbsReturn, returnAddr, dest, destAddress, prevFrame.AbsReturn, returnAddr, stackPointer, StackFrameFlags::None);
			}
		}
	}
}
void CallstackManager::GetCallstack(StackFrameInfo* callstackArray, uint32_t &callstackSize)
{
	DebugBreakHelper helper(_debugger);
	int i = 0;
	for(StackFrameInfo &info : _callstack) {
		callstackArray[i] = info;
		i++;
	}
	callstackSize = i;
}
int32_t CallstackManager::GetReturnAddress()
{
	DebugBreakHelper helper(_debugger);
	if(_callstack.empty()) {
		return -1;
	}
	return _callstack.back().Return;
}
int64_t CallstackManager::GetReturnStackPointer()
{
	DebugBreakHelper helper(_debugger);
	if(_callstack.empty()) {
		return -1;
	}
	return _callstack.back().ReturnStackPointer;
}
Profiler* CallstackManager::GetProfiler()
{
	return _profiler.get();
}
void CallstackManager::Clear()
{
	_callstack.clear();
	_profiler->ResetState();
}
```

## File: Core/Debugger/CallstackManager.h
```
#pragma once
#include "pch.h"
#include "Debugger/DebugTypes.h"
class Debugger;
class Profiler;
class IDebugger;
class CallstackManager
{
private:
	Debugger* _debugger;
	deque<StackFrameInfo> _callstack;
	unique_ptr<Profiler> _profiler;
public:
	CallstackManager(Debugger* debugger, IDebugger* cpuDebugger);
	~CallstackManager();
	void Push(AddressInfo& src, uint32_t srcAddr, AddressInfo& dest, uint32_t destAddr, AddressInfo& ret, uint32_t returnAddress, uint32_t returnStackPointer, StackFrameFlags flags);
	void Pop(AddressInfo& dest, uint32_t destAddr, uint32_t stackPointer);
	__forceinline bool IsReturnAddrMatch(uint32_t destAddr)
	{
		if(_callstack.empty()) {
			return false;
		}
		for(auto itt = _callstack.rbegin(); itt != _callstack.rend(); itt++) {
			if((*itt).Return == destAddr) {
				return true;
			}
		}
		return false;
	}
	void GetCallstack(StackFrameInfo* callstackArray, uint32_t &callstackSize);
	int32_t GetReturnAddress();
	int64_t GetReturnStackPointer();
	Profiler* GetProfiler();
	void Clear();
};
```

## File: Core/Debugger/CdlManager.cpp
```cpp
#include "pch.h"
#include "Debugger/CdlManager.h"
#include "Debugger/CodeDataLogger.h"
#include "Debugger/DebugBreakHelper.h"
#include "Debugger/Disassembler.h"
void CdlManager::SetCdlData(MemoryType memType, uint8_t* cdlData, uint32_t length)
{
	DebugBreakHelper helper(_debugger);
	CodeDataLogger* cdl = GetCodeDataLogger(memType);
	if(cdl) {
		cdl->SetCdlData(cdlData, length);
		RefreshCodeCache();
	}
}
void CdlManager::MarkBytesAs(MemoryType memType, uint32_t start, uint32_t end, uint8_t flags)
{
	DebugBreakHelper helper(_debugger);
	CodeDataLogger* cdl = GetCodeDataLogger(memType);
	if(cdl) {
		cdl->MarkBytesAs(start, end, flags);
		RefreshCodeCache();
	}
}
CdlStatistics CdlManager::GetCdlStatistics(MemoryType memType)
{
	CodeDataLogger* cdl = GetCodeDataLogger(memType);
	return cdl ? cdl->GetStatistics() : CdlStatistics {};
}
uint32_t CdlManager::GetCdlFunctions(MemoryType memType, uint32_t functions[], uint32_t maxSize)
{
	CodeDataLogger* cdl = GetCodeDataLogger(memType);
	return cdl ? cdl->GetFunctions(functions, maxSize) : 0;
}
void CdlManager::ResetCdl(MemoryType memType)
{
	DebugBreakHelper helper(_debugger);
	CodeDataLogger* cdl = GetCodeDataLogger(memType);
	if(cdl) {
		cdl->Reset();
		RefreshCodeCache();
	}
}
void CdlManager::LoadCdlFile(MemoryType memType, char* cdlFile)
{
	DebugBreakHelper helper(_debugger);
	CodeDataLogger* cdl = GetCodeDataLogger(memType);
	if(cdl) {
		cdl->LoadCdlFile(cdlFile, false);
		RefreshCodeCache();
	}
}
void CdlManager::SaveCdlFile(MemoryType memType, char* cdlFile)
{
	DebugBreakHelper helper(_debugger);
	CodeDataLogger* cdl = GetCodeDataLogger(memType);
	if(cdl) {
		cdl->SaveCdlFile(cdlFile);
	}
}
void CdlManager::RegisterCdl(MemoryType memType, CodeDataLogger* cdl)
{
	_codeDataLoggers[(int)memType] = cdl;
}
void CdlManager::RefreshCodeCache(bool resetPrgCache)
{
	if(resetPrgCache) {
		_disassembler->ResetPrgCache();
	}
	for(CodeDataLogger* cdl : _codeDataLoggers) {
		if(cdl) {
			cdl->RebuildPrgCache(_disassembler);
		}
	}
}
CdlManager::CdlManager(Debugger* debugger, Disassembler* disassembler)
{
	_debugger = debugger;
	_disassembler = disassembler;
}
void CdlManager::GetCdlData(uint32_t offset, uint32_t length, MemoryType memoryType, uint8_t* cdlData)
{
	CodeDataLogger* cdl = GetCodeDataLogger(memoryType);
	if(cdl) {
		cdl->GetCdlData(offset, length, cdlData);
	} else {
		AddressInfo relAddress;
		relAddress.Type = memoryType;
		for(uint32_t i = 0; i < length; i++) {
			relAddress.Address = offset + i;
			AddressInfo info = _debugger->GetAbsoluteAddress(relAddress);
			if(info.Address >= 0) {
				cdl = GetCodeDataLogger(info.Type);
				cdlData[i] = cdl ? cdl->GetFlags(info.Address) : 0;
			} else {
				cdlData[i] = 0;
			}
		}
	}
}
int16_t CdlManager::GetCdlFlags(MemoryType memType, uint32_t addr)
{
	CodeDataLogger* cdl = GetCodeDataLogger(memType);
	if(cdl) {
		return cdl->GetFlags(addr);
	} else {
		if(DebugUtilities::IsRelativeMemory(memType)) {
			AddressInfo info = _debugger->GetAbsoluteAddress({ (int32_t)addr, memType });
			if(info.Address >= 0) {
				cdl = GetCodeDataLogger(info.Type);
				return cdl ? cdl->GetFlags(info.Address) : -1;
			}
		}
	}
	return -1;
}
CodeDataLogger* CdlManager::GetCodeDataLogger(MemoryType memType)
{
	return _codeDataLoggers[(int)memType];
}
```

## File: Core/Debugger/CdlManager.h
```
#pragma once
#include "pch.h"
#include "Shared/MemoryType.h"
#include "Debugger/DebugTypes.h"
#include "Debugger/DebugUtilities.h"
class CodeDataLogger;
class Debugger;
class Disassembler;
class CdlManager
{
private:
	CodeDataLogger* _codeDataLoggers[DebugUtilities::GetMemoryTypeCount()] = {};
	Debugger* _debugger = nullptr;
	Disassembler* _disassembler = nullptr;
public:
	CdlManager(Debugger* debugger, Disassembler* disassembler);
	void GetCdlData(uint32_t offset, uint32_t length, MemoryType memoryType, uint8_t* cdlData);
	int16_t GetCdlFlags(MemoryType memType, uint32_t addr);
	void SetCdlData(MemoryType memType, uint8_t* cdlData, uint32_t length);
	void MarkBytesAs(MemoryType memType, uint32_t start, uint32_t end, uint8_t flags);
	CdlStatistics GetCdlStatistics(MemoryType memType);
	uint32_t GetCdlFunctions(MemoryType memType, uint32_t functions[], uint32_t maxSize);
	void ResetCdl(MemoryType memType);
	void LoadCdlFile(MemoryType memType, char* cdlFile);
	void SaveCdlFile(MemoryType memType, char* cdlFile);
	void RegisterCdl(MemoryType memType, CodeDataLogger* cdl);
	void RefreshCodeCache(bool resetPrgCache = true);
	CodeDataLogger* GetCodeDataLogger(MemoryType memType);
};
```

## File: Core/Debugger/CodeDataLogger.cpp
```cpp
#include "pch.h"
#include "Debugger/Debugger.h"
#include "Debugger/CodeDataLogger.h"
#include "Debugger/CdlManager.h"
#include "Debugger/Disassembler.h"
#include "Shared/Emulator.h"
#include "Shared/EmuSettings.h"
#include "Shared/MessageManager.h"
#include "Utilities/VirtualFile.h"
#include "Utilities/FolderUtilities.h"
CodeDataLogger::CodeDataLogger(Debugger* debugger, MemoryType memType, uint32_t memSize, CpuType cpuType, uint32_t romCrc32)
{
	_memType = memType;
	_cpuType = cpuType;
	_memSize = memSize;
	_romCrc32 = romCrc32;
	_cdlData = new uint8_t[memSize];
	Reset();
	debugger->GetCdlManager()->RegisterCdl(memType, this);
}
CodeDataLogger::~CodeDataLogger()
{
	delete[] _cdlData;
}
void CodeDataLogger::Reset()
{
	memset(_cdlData, 0, _memSize);
}
uint8_t* CodeDataLogger::GetRawData()
{
	return _cdlData;
}
uint32_t CodeDataLogger::GetSize()
{
	return _memSize;
}
MemoryType CodeDataLogger::GetMemoryType()
{
	return _memType;
}
bool CodeDataLogger::LoadCdlFile(string cdlFilepath, bool autoResetCdl)
{
	VirtualFile cdlFile = cdlFilepath;
	if(cdlFile.IsValid()) {
		vector<uint8_t>& cdlData = cdlFile.GetData();
		uint32_t fileSize = (uint32_t)cdlData.size();
		if(fileSize >= _memSize && fileSize >= CodeDataLogger::HeaderSize) {
			Reset();
			if(memcmp(cdlData.data(), "CDLv2", 5) == 0) {
				uint32_t savedCrc = cdlData[5] | (cdlData[6] << 8) | (cdlData[7] << 16) | (cdlData[8] << 24);
				if((!autoResetCdl || savedCrc == _romCrc32) && fileSize >= _memSize + CodeDataLogger::HeaderSize) {
					memcpy(_cdlData, cdlData.data() + CodeDataLogger::HeaderSize, _memSize);
					InternalLoadCdlFile(cdlData.data() + CodeDataLogger::HeaderSize, (uint32_t)cdlData.size() - CodeDataLogger::HeaderSize);
				}
			} else {
				MessageManager::Log("[Warning] CDL file doesn't contain header/CRC and may be incompatible.");
				memcpy(_cdlData, cdlData.data(), _memSize);
				InternalLoadCdlFile(cdlData.data(), (uint32_t)cdlData.size());
			}
			return true;
		}
	}
	return false;
}
bool CodeDataLogger::SaveCdlFile(string cdlFilepath)
{
	ofstream cdlFile(cdlFilepath, ios::out | ios::binary);
	if(cdlFile) {
		cdlFile.write("CDLv2", 5);
		cdlFile.put(_romCrc32 & 0xFF);
		cdlFile.put((_romCrc32 >> 8) & 0xFF);
		cdlFile.put((_romCrc32 >> 16) & 0xFF);
		cdlFile.put((_romCrc32 >> 24) & 0xFF);
		cdlFile.write((char*)_cdlData, _memSize);
		InternalSaveCdlFile(cdlFile);
		cdlFile.close();
		return true;
	}
	return false;
}
string CodeDataLogger::GetCdlFilePath(string romName)
{
	return FolderUtilities::CombinePath(FolderUtilities::GetDebuggerFolder(), FolderUtilities::GetFilename(romName, false) + ".cdl");
}
CdlStatistics CodeDataLogger::GetStatistics()
{
	uint32_t codeSize = 0;
	uint32_t dataSize = 0;
	uint32_t bothSize = 0;
	for(int i = 0, len = _memSize; i < len; i++) {
		uint32_t isCode = (uint32_t)(_cdlData[i] & CdlFlags::Code);
		uint32_t isData = (uint32_t)(_cdlData[i] & CdlFlags::Data) >> 1;
		codeSize += isCode;
		dataSize += isData;
		bothSize += isCode & isData;
	}
	dataSize -= bothSize;
	CdlStatistics stats = {};
	stats.CodeBytes = codeSize;
	stats.DataBytes = dataSize;
	stats.TotalBytes = _memSize;
	return stats;
}
bool CodeDataLogger::IsCode(uint32_t absoluteAddr)
{
	return (_cdlData[absoluteAddr] & CdlFlags::Code) != 0;
}
bool CodeDataLogger::IsJumpTarget(uint32_t absoluteAddr)
{
	return (_cdlData[absoluteAddr] & CdlFlags::JumpTarget) != 0;
}
bool CodeDataLogger::IsSubEntryPoint(uint32_t absoluteAddr)
{
	return (_cdlData[absoluteAddr] & CdlFlags::SubEntryPoint) != 0;
}
bool CodeDataLogger::IsData(uint32_t absoluteAddr)
{
	return (_cdlData[absoluteAddr] & CdlFlags::Data) != 0;
}
void CodeDataLogger::SetCdlData(uint8_t *cdlData, uint32_t length)
{
	if(length <= _memSize) {
		memcpy(_cdlData, cdlData, length);
	}
}
void CodeDataLogger::GetCdlData(uint32_t offset, uint32_t length, uint8_t *cdlData)
{
	memcpy(cdlData, _cdlData + offset, length);
}
uint8_t CodeDataLogger::GetFlags(uint32_t addr)
{
	return _cdlData[addr];
}
uint32_t CodeDataLogger::GetFunctions(uint32_t functions[], uint32_t maxSize)
{
	uint32_t count = 0;
	for(int i = 0, len = _memSize; i < len; i++) {
		if(IsSubEntryPoint(i)) {
			functions[count] = i;
			count++;
			if(count == maxSize) {
				break;
			}
		}
	}
	return count;
}
void CodeDataLogger::MarkBytesAs(uint32_t start, uint32_t end, uint8_t flags)
{
	for(uint32_t i = start; i <= end; i++) {
		_cdlData[i] = (_cdlData[i] & 0xFC) | (int)flags;
	}
}
void CodeDataLogger::StripData(uint8_t* romBuffer, CdlStripOption flag)
{
	if(flag == CdlStripOption::StripUnused) {
		for(uint32_t i = 0; i < _memSize; i++) {
			if(_cdlData[i] == 0) {
				romBuffer[i] = 0;
			}
		}
	} else if(flag == CdlStripOption::StripUsed) {
		for(uint32_t i = 0; i < _memSize; i++) {
			if(_cdlData[i] != 0) {
				romBuffer[i] = 0;
			}
		}
	}
}
void CodeDataLogger::RebuildPrgCache(Disassembler* dis)
{
	AddressInfo addrInfo;
	addrInfo.Type = _memType;
	for(uint32_t i = 0; i < _memSize; i++) {
		if(IsCode(i)) {
			addrInfo.Address = (int32_t)i;
			i += dis->BuildCache(addrInfo, 0, _cpuType) - 1;
		}
	}
}
```

## File: Core/Debugger/CodeDataLogger.h
```
#pragma once
#include "pch.h"
#include "Debugger/DebugTypes.h"
class Disassembler;
class Debugger;
class CodeDataLogger
{
protected:
	constexpr static int HeaderSize = 9;
	uint8_t* _cdlData = nullptr;
	CpuType _cpuType = CpuType::Snes;
	MemoryType _memType = {};
	uint32_t _memSize = 0;
	uint32_t _romCrc32 = 0;
	virtual void InternalLoadCdlFile(uint8_t* cdlData, uint32_t cdlSize) {}
	virtual void InternalSaveCdlFile(ofstream& cdlFile) {}
public:
	CodeDataLogger(Debugger* debugger, MemoryType memType, uint32_t memSize, CpuType cpuType, uint32_t romCrc32);
	virtual ~CodeDataLogger();
	virtual void Reset();
	uint8_t* GetRawData();
	uint32_t GetSize();
	MemoryType GetMemoryType();
	bool LoadCdlFile(string cdlFilepath, bool autoResetCdl);
	bool SaveCdlFile(string cdlFilepath);
	string GetCdlFilePath(string romName);
	template<uint8_t flags = 0, uint8_t accessWidth = 1>
	void SetCode(int32_t absoluteAddr)
	{
		for(int i = 0; i < accessWidth; i++) {
			_cdlData[absoluteAddr+i] |= CdlFlags::Code | flags;
		}
	}
	template<uint8_t accessWidth = 1>
	void SetCode(int32_t absoluteAddr, uint8_t flags)
	{
		_cdlData[absoluteAddr] |= CdlFlags::Code | flags;
		if constexpr(accessWidth > 1) {
			for(int i = 1; i < accessWidth; i++) {
				_cdlData[absoluteAddr+i] |= CdlFlags::Code;
			}
		}
	}
	template<uint8_t flags = 0, uint8_t accessWidth = 1>
	void SetData(int32_t absoluteAddr)
	{
		for(int i = 0; i < accessWidth; i++) {
			_cdlData[absoluteAddr+i] |= CdlFlags::Data | flags;
		}
	}
	virtual CdlStatistics GetStatistics();
	bool IsCode(uint32_t absoluteAddr);
	bool IsJumpTarget(uint32_t absoluteAddr);
	bool IsSubEntryPoint(uint32_t absoluteAddr);
	bool IsData(uint32_t absoluteAddr);
	void SetCdlData(uint8_t *cdlData, uint32_t length);
	void GetCdlData(uint32_t offset, uint32_t length, uint8_t *cdlData);
	uint8_t GetFlags(uint32_t addr);
	uint32_t GetFunctions(uint32_t functions[], uint32_t maxSize);
	void MarkBytesAs(uint32_t start, uint32_t end, uint8_t flags);
	virtual void StripData(uint8_t* romBuffer, CdlStripOption flag);
	virtual void RebuildPrgCache(Disassembler* dis);
};
```

## File: Core/Debugger/DebugBreakHelper.h
```
#pragma once
#include "pch.h"
#include "Debugger/Debugger.h"
#include "Shared/Emulator.h"
class DebugBreakHelper
{
private:
	Debugger * _debugger;
	bool _needBreak = false;
public:
	DebugBreakHelper(Debugger* debugger, bool breakBetweenInstructions = false)
	{
		_debugger = debugger;
		_needBreak = !debugger->GetEmulator()->IsEmulationThread();
		if(_needBreak) {
			while(true) {
				debugger->BreakRequest(false);
				while(!debugger->IsExecutionStopped()) {}
				if(breakBetweenInstructions) {
					if(debugger->GetDebuggerFeatures(debugger->GetMainCpuType()).ChangeProgramCounter) {
						break;
					} else {
						debugger->Step(debugger->GetMainCpuType(), 1, StepType::Step, BreakSource::InternalOperation);
						debugger->BreakRequest(true);
						std::this_thread::sleep_for(std::chrono::duration<int, std::milli>(15));
					}
				} else {
					break;
				}
			}
		}
	}
	~DebugBreakHelper()
	{
		if(_needBreak) {
			_debugger->BreakRequest(true);
		}
	}
};
```

## File: Core/Debugger/DebuggerFeatures.h
```
#pragma once
#include "pch.h"
enum class VectorType
{
	Indirect,
	Direct,
	x86,
	x86WithOffset
};
struct CpuVectorDefinition
{
	char Name[15] = {};
	uint32_t Address = 0;
	VectorType Type = VectorType::Indirect;
};
struct DebuggerFeatures
{
	bool RunToIrq;
	bool RunToNmi;
	bool StepOver;
	bool StepOut;
	bool StepBack;
	bool ChangeProgramCounter;
	bool CallStack;
	bool CpuCycleStep;
	uint8_t IrqVectorOffset;
	uint8_t CpuVectorCount;
	CpuVectorDefinition CpuVectors[16];
};
```

## File: Core/Debugger/DebugTypes.h
```
#pragma once
#include "pch.h"
#include "Shared/MemoryOperationType.h"
#include "Shared/CpuType.h"
#include "Debugger/DisassemblyInfo.h"
#include "Debugger/AddressInfo.h"
enum class MemoryType;
enum class CpuType : uint8_t;
struct MemoryOperationInfo
{
	uint32_t Address;
	int32_t Value;
	MemoryOperationType Type;
	MemoryType MemType;
	MemoryOperationInfo()
	{
		Address = 0;
		Value = 0;
		Type = (MemoryOperationType)0;
		MemType = (MemoryType)0;
	}
	MemoryOperationInfo(uint32_t addr, int32_t val, MemoryOperationType opType, MemoryType memType)
	{
		Address = addr;
		Value = val;
		Type = opType;
		MemType = memType;
	}
};
enum class BreakpointTypeFlags
{
	None = 0,
	Read = 1,
	Write = 2,
	Execute = 4,
	Forbid = 8,
};
enum class BreakpointType
{
	Execute = 0,
	Read = 1,
	Write = 2,
	Forbid = 3,
};
namespace CdlFlags
{
	enum CdlFlags : uint8_t
	{
		None = 0x00,
		Code = 0x01,
		Data = 0x02,
		JumpTarget = 0x04,
		SubEntryPoint = 0x08,
	};
}
enum class CdlStripOption
{
	StripNone = 0,
	StripUnused,
	StripUsed,
};
struct CdlStatistics
{
	uint32_t CodeBytes;
	uint32_t DataBytes;
	uint32_t TotalBytes;
	uint32_t JumpTargetCount;
	uint32_t FunctionCount;
	uint32_t DrawnChrBytes;
	uint32_t TotalChrBytes;
};
struct DisassemblyResult
{
	AddressInfo Address;
	int32_t CpuAddress;
	uint16_t Flags;
	int16_t CommentLine;
	DisassemblyResult(int32_t cpuAddress, uint16_t flags, int16_t commentLine = -1)
	{
		Flags = flags;
		CpuAddress = cpuAddress;
		Address.Address = -1;
		Address.Type = {};
		CommentLine = commentLine;
	}
	DisassemblyResult(AddressInfo address, int32_t cpuAddress, uint16_t flags = 0, int16_t commentLine = -1)
	{
		Address = address;
		CpuAddress = cpuAddress;
		Flags = flags;
		CommentLine = commentLine;
	}
	void SetByteCount(uint8_t byteCount)
	{
		CommentLine = byteCount;
	}
	uint8_t GetByteCount()
	{
		return (uint8_t)CommentLine;
	}
};
namespace LineFlags
{
	enum LineFlags : uint16_t
	{
		None = 0,
		PrgRom = 0x01,
		WorkRam = 0x02,
		SaveRam = 0x04,
		VerifiedData = 0x08,
		VerifiedCode = 0x10,
		BlockStart = 0x20,
		BlockEnd = 0x40,
		SubStart = 0x80,
		Label = 0x100,
		Comment = 0x200,
		ShowAsData = 0x400,
		UnexecutedCode = 0x800,
		UnmappedMemory = 0x1000,
		Empty = 0x2000
	};
}
struct CodeLineData
{
	int32_t Address;
	AddressInfo AbsoluteAddress;
	uint8_t OpSize;
	uint16_t Flags;
	EffectiveAddressInfo EffectiveAddress;
	uint32_t Value;
	CpuType LineCpuType;
	uint8_t ByteCode[8];
	char Text[1000];
	char Comment[1000];
};
enum class TilemapDisplayMode
{
	Default,
	Grayscale,
	AttributeView
};
struct AddressCounters;
enum class TilemapHighlightMode
{
	None,
	Changes,
	Writes
};
struct GetTilemapOptions
{
	uint8_t Layer;
	uint8_t* CompareVram;
	AddressCounters* AccessCounters;
	uint64_t MasterClock;
	TilemapHighlightMode TileHighlightMode;
	TilemapHighlightMode AttributeHighlightMode;
	TilemapDisplayMode DisplayMode;
};
enum class TileFormat
{
	Bpp2,
	Bpp4,
	Bpp8,
	DirectColor,
	Mode7,
	Mode7DirectColor,
	Mode7ExtBg,
	NesBpp2,
	PceSpriteBpp4,
	PceSpriteBpp2Sp01,
	PceSpriteBpp2Sp23,
	PceBackgroundBpp2Cg0,
	PceBackgroundBpp2Cg1,
	SmsBpp4,
	SmsSgBpp1,
	GbaBpp4,
	GbaBpp8,
	WsBpp4Packed
};
enum class TileLayout
{
	Normal,
	SingleLine8x16,
	SingleLine16x16
};
enum class TileBackground
{
	Default,
	Transparent,
	PaletteColor,
	Black,
	White,
	Magenta,
};
enum class TileFilter
{
	None,
	HideUnused,
	HideUsed
};
struct GetTileViewOptions
{
	MemoryType MemType;
	TileFormat Format;
	TileLayout Layout;
	TileFilter Filter;
	TileBackground Background;
	int32_t Width;
	int32_t Height;
	int32_t StartAddress;
	int32_t Palette;
	bool UseGrayscalePalette;
};
enum class SpriteBackground
{
	Gray,
	Background,
	Transparent,
	Black,
	White,
	Magenta,
};
struct GetSpritePreviewOptions
{
	SpriteBackground Background;
};
struct GetPaletteInfoOptions
{
	TileFormat Format;
};
enum class StackFrameFlags
{
	None = 0,
	Nmi = 1,
	Irq = 2
};
struct StackFrameInfo
{
	uint32_t Source;
	AddressInfo AbsSource;
	uint32_t Target;
	AddressInfo AbsTarget;
	uint32_t Return;
	uint32_t ReturnStackPointer;
	AddressInfo AbsReturn;
	StackFrameFlags Flags;
};
enum class DebugEventType
{
	Register,
	Nmi,
	Irq,
	Breakpoint,
	BgColorChange,
	SpriteZeroHit,
	DmcDmaRead,
	DmaRead
};
enum class BreakSource
{
	Unspecified = -1,
	Breakpoint = 0,
	Pause,
	CpuStep,
	PpuStep,
	Irq,
	Nmi,
	InternalOperation,
	BreakOnBrk,
	BreakOnCop,
	BreakOnWdm,
	BreakOnStp,
	BreakOnUninitMemoryRead,
	GbInvalidOamAccess,
	GbInvalidVramAccess,
	GbDisableLcdOutsideVblank,
	GbInvalidOpCode,
	GbNopLoad,
	GbOamCorruption,
	NesBreakOnDecayedOamRead,
	NesBreakOnPpuScrollGlitch,
	BreakOnUnofficialOpCode,
	BreakOnUnstableOpCode,
	NesBusConflict,
	NesBreakOnCpuCrash,
	NesBreakOnExtOutputMode,
	NesInvalidVramAccess,
	NesInvalidOamWrite,
	NesDmaInputRead,
	PceBreakOnInvalidVramAddress,
	SmsNopLoad,
	GbaInvalidOpCode,
	GbaNopLoad,
	GbaUnalignedMemoryAccess,
	SnesInvalidPpuAccess,
	SnesReadDuringAutoJoy,
	BreakOnUndefinedOpCode
};
struct BreakEvent
{
	BreakSource Source;
	CpuType SourceCpu;
	MemoryOperationInfo Operation;
	int32_t BreakpointId;
};
enum class StepType
{
	Step,
	StepOut,
	StepOver,
	CpuCycleStep,
	PpuStep,
	PpuScanline,
	PpuFrame,
	SpecificScanline,
	RunToNmi,
	RunToIrq,
	StepBack
};
enum class BreakType
{
	None = 0,
	User = 1,
	Exception = 2,
	Both = 3
};
struct StepRequest
{
	int64_t BreakAddress = -1;
	int64_t BreakStackPointer = -1;
	int32_t StepCount = -1;
	int32_t PpuStepCount = -1;
	int32_t CpuCycleStepCount = -1;
	int32_t BreakScanline = INT32_MIN;
	StepType Type = StepType::Step;
	bool HasRequest = false;
	BreakType BreakNeeded = BreakType::None;
	BreakSource Source = BreakSource::Unspecified;
	BreakSource ExSource = BreakSource::Unspecified;
	StepRequest()
	{
	}
	StepRequest(StepType type)
	{
		Type = type;
	}
	StepRequest(const StepRequest& obj)
	{
		Type = obj.Type;
		StepCount = obj.StepCount;
		PpuStepCount = obj.PpuStepCount;
		CpuCycleStepCount = obj.CpuCycleStepCount;
		BreakAddress = obj.BreakAddress;
		BreakStackPointer = obj.BreakStackPointer;
		BreakScanline = obj.BreakScanline;
		HasRequest = (StepCount != -1 || PpuStepCount != -1 || BreakAddress != -1 || BreakScanline != INT32_MIN || CpuCycleStepCount != -1);
	}
	void ClearException()
	{
		ExSource = BreakSource::Unspecified;
		ClearBreakType(BreakType::Exception);
	}
	__forceinline void SetBreakSource(BreakSource source, bool breakNeeded)
	{
		if(source > BreakSource::InternalOperation) {
			if(ExSource == BreakSource::Unspecified) {
				ExSource = source;
			}
			if(breakNeeded) {
				SetBreakType(BreakType::Exception);
			}
		} else {
			if(Source == BreakSource::Unspecified) {
				Source = source;
			}
			if(breakNeeded) {
				SetBreakType(BreakType::User);
			}
		}
	}
	BreakSource GetBreakSource()
	{
		if(ExSource != BreakSource::Unspecified) {
			return ExSource;
		}
		if(Source == BreakSource::Unspecified) {
			if(BreakScanline != INT32_MIN || PpuStepCount >= 0) {
				return BreakSource::PpuStep;
			}
		}
		return Source;
	}
	__forceinline void SetBreakType(BreakType type)
	{
		BreakNeeded = (BreakType)((int)BreakNeeded | (int)type);
	}
	__forceinline void ClearBreakType(BreakType type)
	{
		BreakNeeded = (BreakType)((int)BreakNeeded & ~(int)type);
	}
	__forceinline void Break(BreakSource src)
	{
		SetBreakSource(src, true);
	}
	__forceinline void ProcessCpuExec()
	{
		if(StepCount > 0) {
			StepCount--;
			if(StepCount == 0) {
				SetBreakSource(BreakSource::CpuStep, true);
			}
		}
	}
	__forceinline bool ProcessCpuCycle()
	{
		if(CpuCycleStepCount > 0) {
			CpuCycleStepCount--;
			if(CpuCycleStepCount == 0) {
				SetBreakSource(BreakSource::CpuStep, true);
				return true;
			}
		}
		return false;
	}
	__forceinline void ProcessNmiIrq(bool forNmi)
	{
		if(forNmi) {
			if(Type == StepType::RunToNmi) {
				SetBreakSource(BreakSource::Nmi, true);
			}
		} else {
			if(Type == StepType::RunToIrq) {
				SetBreakSource(BreakSource::Irq, true);
			}
		}
	}
	bool HasScanlineBreakRequest()
	{
		return BreakScanline != INT32_MIN;
	}
};
struct CpuInstructionProgress
{
	uint64_t StartCycle = 0;
	uint64_t CurrentCycle = 0;
	uint32_t LastOpCode = 0;
	MemoryOperationInfo LastMemOperation = {};
};
struct DebugControllerState
{
	bool A;
	bool B;
	bool X;
	bool Y;
	bool L;
	bool R;
	bool U;
	bool D;
	bool Up;
	bool Down;
	bool Left;
	bool Right;
	bool Select;
	bool Start;
	bool HasPressedButton()
	{
		return A || B || X || Y || L || R || U || D || Up || Down || Left || Right || Select || Start;
	}
};
```

## File: Core/Debugger/DebugUtilities.h
```
#pragma once
#include "pch.h"
#include "Debugger/DebugTypes.h"
#include "Shared/MemoryType.h"
#include "Utilities/HexUtilities.h"
class DebugUtilities
{
public:
	static constexpr MemoryType GetCpuMemoryType(CpuType type)
	{
		switch(type) {
			case CpuType::Snes: return MemoryType::SnesMemory;
			case CpuType::Spc: return MemoryType::SpcMemory;
			case CpuType::NecDsp: return MemoryType::NecDspMemory;
			case CpuType::Sa1: return MemoryType::Sa1Memory;
			case CpuType::Gsu: return MemoryType::GsuMemory;
			case CpuType::Cx4: return MemoryType::Cx4Memory;
			case CpuType::St018: return MemoryType::St018Memory;
			case CpuType::Gameboy: return MemoryType::GameboyMemory;
			case CpuType::Nes: return MemoryType::NesMemory;
			case CpuType::Pce: return MemoryType::PceMemory;
			case CpuType::Sms: return MemoryType::SmsMemory;
			case CpuType::Gba: return MemoryType::GbaMemory;
			case CpuType::Ws: return MemoryType::WsMemory;
		}
		throw std::runtime_error("Invalid CPU type");
	}
	static constexpr int GetProgramCounterSize(CpuType type)
	{
		switch(type) {
			case CpuType::Snes: return 6;
			case CpuType::Spc: return 4;
			case CpuType::NecDsp: return 6;
			case CpuType::Sa1: return 6;
			case CpuType::Gsu: return 6;
			case CpuType::Cx4: return 6;
			case CpuType::St018: return 8;
			case CpuType::Gameboy: return 4;
			case CpuType::Nes: return 4;
			case CpuType::Pce: return 4;
			case CpuType::Sms: return 4;
			case CpuType::Gba: return 8;
			case CpuType::Ws: return 5;
		}
		throw std::runtime_error("Invalid CPU type");
	}
	static constexpr CpuType ToCpuType(MemoryType type)
	{
		switch(type) {
			case MemoryType::SnesMemory:
			case MemoryType::SnesCgRam:
			case MemoryType::SnesPrgRom:
			case MemoryType::SnesSaveRam:
			case MemoryType::SnesSpriteRam:
			case MemoryType::SnesVideoRam:
			case MemoryType::SnesWorkRam:
			case MemoryType::BsxMemoryPack:
			case MemoryType::BsxPsRam:
			case MemoryType::SufamiTurboFirmware:
			case MemoryType::SufamiTurboSecondCart:
			case MemoryType::SufamiTurboSecondCartRam:
			case MemoryType::SnesRegister:
				return CpuType::Snes;
			case MemoryType::SpcMemory:
			case MemoryType::SpcRam:
			case MemoryType::SpcRom:
			case MemoryType::SpcDspRegisters:
				return CpuType::Spc;
			case MemoryType::GsuMemory:
			case MemoryType::GsuWorkRam:
				return CpuType::Gsu;
			case MemoryType::Sa1InternalRam:
			case MemoryType::Sa1Memory:
				return CpuType::Sa1;
			case MemoryType::NecDspMemory:
			case MemoryType::DspDataRam:
			case MemoryType::DspDataRom:
			case MemoryType::DspProgramRom:
				return CpuType::NecDsp;
			case MemoryType::Cx4DataRam:
			case MemoryType::Cx4Memory:
				return CpuType::Cx4;
			case MemoryType::St018Memory:
			case MemoryType::St018PrgRom:
			case MemoryType::St018DataRom:
			case MemoryType::St018WorkRam:
				return CpuType::St018;
			case MemoryType::GbPrgRom:
			case MemoryType::GbWorkRam:
			case MemoryType::GbCartRam:
			case MemoryType::GbHighRam:
			case MemoryType::GbBootRom:
			case MemoryType::GbVideoRam:
			case MemoryType::GbSpriteRam:
			case MemoryType::GameboyMemory:
				return CpuType::Gameboy;
			case MemoryType::NesChrRam:
			case MemoryType::NesChrRom:
			case MemoryType::NesInternalRam:
			case MemoryType::NesMemory:
			case MemoryType::NesNametableRam:
			case MemoryType::NesMapperRam:
			case MemoryType::NesPaletteRam:
			case MemoryType::NesPpuMemory:
			case MemoryType::NesPrgRom:
			case MemoryType::NesSaveRam:
			case MemoryType::NesSpriteRam:
			case MemoryType::NesSecondarySpriteRam:
			case MemoryType::NesWorkRam:
				return CpuType::Nes;
			case MemoryType::PceMemory:
			case MemoryType::PcePrgRom:
			case MemoryType::PceWorkRam:
			case MemoryType::PceSaveRam:
			case MemoryType::PceCdromRam:
			case MemoryType::PceCardRam:
			case MemoryType::PceAdpcmRam:
			case MemoryType::PceArcadeCardRam:
			case MemoryType::PceVideoRam:
			case MemoryType::PceVideoRamVdc2:
			case MemoryType::PcePaletteRam:
			case MemoryType::PceSpriteRam:
			case MemoryType::PceSpriteRamVdc2:
				return CpuType::Pce;
			case MemoryType::SmsMemory:
			case MemoryType::SmsPrgRom:
			case MemoryType::SmsWorkRam:
			case MemoryType::SmsCartRam:
			case MemoryType::SmsBootRom:
			case MemoryType::SmsVideoRam:
			case MemoryType::SmsPaletteRam:
			case MemoryType::SmsPort:
				return CpuType::Sms;
			case MemoryType::GbaMemory:
			case MemoryType::GbaPrgRom:
			case MemoryType::GbaBootRom:
			case MemoryType::GbaSaveRam:
			case MemoryType::GbaIntWorkRam:
			case MemoryType::GbaExtWorkRam:
			case MemoryType::GbaVideoRam:
			case MemoryType::GbaSpriteRam:
			case MemoryType::GbaPaletteRam:
				return CpuType::Gba;
			case MemoryType::WsMemory:
			case MemoryType::WsPrgRom:
			case MemoryType::WsWorkRam:
			case MemoryType::WsCartRam:
			case MemoryType::WsCartEeprom:
			case MemoryType::WsBootRom:
			case MemoryType::WsInternalEeprom:
			case MemoryType::WsPort:
				return CpuType::Ws;
			default:
				throw std::runtime_error("Invalid CPU type");
		}
	}
	static constexpr bool IsRelativeMemory(MemoryType memType)
	{
		return memType <= GetLastCpuMemoryType();
	}
	static constexpr MemoryType GetLastCpuMemoryType()
	{
		return MemoryType::WsMemory;
	}
	static constexpr bool IsPpuMemory(MemoryType memType)
	{
		switch(memType) {
			case MemoryType::SnesVideoRam:
			case MemoryType::SnesSpriteRam:
			case MemoryType::SnesCgRam:
			case MemoryType::GbVideoRam:
			case MemoryType::GbSpriteRam:
			case MemoryType::NesChrRam:
			case MemoryType::NesChrRom:
			case MemoryType::NesSpriteRam:
			case MemoryType::NesPaletteRam:
			case MemoryType::NesNametableRam:
			case MemoryType::NesSecondarySpriteRam:
			case MemoryType::NesPpuMemory:
				return true;
			case MemoryType::PceVideoRam:
			case MemoryType::PceVideoRamVdc2:
			case MemoryType::PcePaletteRam:
			case MemoryType::PceSpriteRam:
			case MemoryType::PceSpriteRamVdc2:
				return true;
			case MemoryType::SmsVideoRam:
			case MemoryType::SmsPaletteRam:
				return true;
			case MemoryType::GbaVideoRam:
			case MemoryType::GbaSpriteRam:
			case MemoryType::GbaPaletteRam:
				return true;
			default:
				return false;
		}
	}
	static constexpr bool IsRom(MemoryType memType)
	{
		switch(memType) {
			case MemoryType::SnesPrgRom:
			case MemoryType::GbPrgRom:
			case MemoryType::GbBootRom:
			case MemoryType::NesPrgRom:
			case MemoryType::NesChrRom:
			case MemoryType::PcePrgRom:
			case MemoryType::DspDataRom:
			case MemoryType::DspProgramRom:
			case MemoryType::St018PrgRom:
			case MemoryType::St018DataRom:
			case MemoryType::SufamiTurboFirmware:
			case MemoryType::SufamiTurboSecondCart:
			case MemoryType::SpcRom:
			case MemoryType::SmsPrgRom:
			case MemoryType::SmsBootRom:
			case MemoryType::GbaPrgRom:
			case MemoryType::GbaBootRom:
			case MemoryType::WsPrgRom:
				return true;
			default:
				return false;
		}
	}
	static constexpr bool IsVolatileRam(MemoryType memType)
	{
		if(IsRom(memType)) {
			return false;
		}
		switch(memType) {
			case MemoryType::NesSaveRam:
			case MemoryType::GbCartRam:
			case MemoryType::SnesSaveRam:
			case MemoryType::SufamiTurboSecondCartRam:
			case MemoryType::PceSaveRam:
			case MemoryType::SnesRegister:
			case MemoryType::SmsCartRam:
			case MemoryType::GbaSaveRam:
			case MemoryType::WsCartRam:
				return false;
			default:
				return true;
		}
	}
	static constexpr CpuType GetLastCpuType()
	{
		return CpuType::Ws;
	}
	static string AddressToHex(CpuType cpuType, int32_t address)
	{
		int size = GetProgramCounterSize(cpuType);
		if(size == 4) {
			return HexUtilities::ToHex((uint16_t)address);
		} else if(size == 5) {
			return HexUtilities::ToHex20(address);
		} else if(size == 6) {
			return HexUtilities::ToHex24(address);
		} else if(size == 8) {
			return HexUtilities::ToHex32(address);
		} else {
			return HexUtilities::ToHex(address);
		}
	}
	static constexpr int GetMemoryTypeCount()
	{
		return (int)MemoryType::None + 1;
	}
};
```

## File: Core/Debugger/Disassembler.h
```
#pragma once
#include "pch.h"
#include "Debugger/DisassemblyInfo.h"
#include "Debugger/DebugTypes.h"
#include "Debugger/DebugUtilities.h"
class IConsole;
class Debugger;
class LabelManager;
class CodeDataLogger;
class MemoryDumper;
class DisassemblySearch;
class EmuSettings;
struct SnesCpuState;
enum class CpuType : uint8_t;
struct DisassemblerSource
{
	vector<DisassemblyInfo> Cache;
	uint32_t Size = 0;
};
class Disassembler
{
private:
	friend class DisassemblySearch;
	IConsole *_console;
	EmuSettings* _settings;
	Debugger *_debugger;
	LabelManager* _labelManager;
	MemoryDumper *_memoryDumper;
	DisassemblerSource _sources[DebugUtilities::GetMemoryTypeCount()] = {};
	void InitSource(MemoryType type);
	DisassemblerSource& GetSource(MemoryType type);
	void GetLineData(DisassemblyResult& result, CpuType type, MemoryType memType, CodeLineData& data);
	int32_t GetMatchingRow(vector<DisassemblyResult>& rows, uint32_t address, bool returnFirstRow);
	vector<DisassemblyResult> Disassemble(CpuType cpuType, uint16_t bank);
	uint16_t GetMaxBank(CpuType cpuType);
public:
	Disassembler(IConsole* console, Debugger* debugger);
	uint32_t BuildCache(AddressInfo &addrInfo, uint8_t cpuFlags, CpuType type);
	void ResetPrgCache();
	void InvalidateCache(AddressInfo addrInfo, CpuType type);
	__forceinline DisassemblyInfo GetDisassemblyInfo(AddressInfo& info, uint32_t cpuAddress, uint8_t cpuFlags, CpuType type)
	{
		DisassemblyInfo disassemblyInfo;
		if(info.Address >= 0) {
			disassemblyInfo = GetSource(info.Type).Cache[info.Address];
		}
		if(!disassemblyInfo.IsInitialized()) {
			disassemblyInfo.Initialize(cpuAddress, cpuFlags, type, DebugUtilities::GetCpuMemoryType(type), _memoryDumper);
		}
		return disassemblyInfo;
	}
	uint32_t GetDisassemblyOutput(CpuType type, uint32_t address, CodeLineData output[], uint32_t rowCount);
	int32_t GetDisassemblyRowAddress(CpuType type, uint32_t address, int32_t rowOffset);
};
```

## File: Core/Debugger/DisassemblyInfo.cpp
```cpp
#include "pch.h"
#include <algorithm>
#include "Debugger/DisassemblyInfo.h"
#include "Debugger/MemoryDumper.h"
#include "Debugger/DebugUtilities.h"
#include "Utilities/HexUtilities.h"
#include "Utilities/FastString.h"
#include "SNES/SnesCpuTypes.h"
#include "SNES/SnesConsole.h"
#include "SNES/BaseCartridge.h"
#include "SNES/Debugger/SnesDisUtils.h"
#include "SNES/Debugger/SpcDisUtils.h"
#include "SNES/Debugger/GsuDisUtils.h"
#include "SNES/Debugger/NecDspDisUtils.h"
#include "SNES/Debugger/Cx4DisUtils.h"
#include "SNES/Debugger/St018DisUtils.h"
#include "Gameboy/Debugger/GameboyDisUtils.h"
#include "NES/Debugger/NesDisUtils.h"
#include "PCE/Debugger/PceDisUtils.h"
#include "SMS/Debugger/SmsDisUtils.h"
#include "GBA/Debugger/GbaDisUtils.h"
#include "WS/Debugger/WsDisUtils.h"
#include "Shared/EmuSettings.h"
DisassemblyInfo::DisassemblyInfo()
{
}
DisassemblyInfo::DisassemblyInfo(uint32_t cpuAddress, uint8_t cpuFlags, CpuType cpuType, MemoryType memType, MemoryDumper* memoryDumper)
{
	Initialize(cpuAddress, cpuFlags, cpuType, memType, memoryDumper);
}
void DisassemblyInfo::Initialize(uint32_t cpuAddress, uint8_t cpuFlags, CpuType cpuType, MemoryType memType, MemoryDumper* memoryDumper)
{
	_cpuType = cpuType;
	_flags = cpuFlags;
	_byteCode[0] = memoryDumper->GetMemoryValue(memType, cpuAddress);
	_opSize = GetOpSize(_byteCode[0], _flags, _cpuType, cpuAddress, memType, memoryDumper);
	for(int i = 1; i < _opSize && i < 8; i++) {
		_byteCode[i] = memoryDumper->GetMemoryValue(memType, cpuAddress+i);
	}
	_initialized = true;
}
bool DisassemblyInfo::IsInitialized()
{
	return _initialized;
}
bool DisassemblyInfo::IsValid(uint8_t cpuFlags)
{
	return _flags == cpuFlags;
}
void DisassemblyInfo::Reset()
{
	_initialized = false;
}
void DisassemblyInfo::GetDisassembly(string &out, uint32_t memoryAddr, LabelManager* labelManager, EmuSettings* settings)
{
	switch(_cpuType) {
		case CpuType::Sa1:
		case CpuType::Snes:
			SnesDisUtils::GetDisassembly(*this, out, memoryAddr, labelManager, settings);
			break;
		case CpuType::Spc: SpcDisUtils::GetDisassembly(*this, out, memoryAddr, labelManager, settings); break;
		case CpuType::NecDsp: NecDspDisUtils::GetDisassembly(*this, out, memoryAddr, labelManager, settings); break;
		case CpuType::Gsu: GsuDisUtils::GetDisassembly(*this, out, memoryAddr, labelManager, settings); break;
		case CpuType::Cx4: Cx4DisUtils::GetDisassembly(*this, out, memoryAddr, labelManager, settings); break;
		case CpuType::St018: GbaDisUtils::GetDisassembly(*this, out, memoryAddr, labelManager, settings); break;
		case CpuType::Gameboy: GameboyDisUtils::GetDisassembly(*this, out, memoryAddr, labelManager, settings); break;
		case CpuType::Nes: NesDisUtils::GetDisassembly(*this, out, memoryAddr, labelManager, settings); break;
		case CpuType::Pce: PceDisUtils::GetDisassembly(*this, out, memoryAddr, labelManager, settings); break;
		case CpuType::Sms: SmsDisUtils::GetDisassembly(*this, out, memoryAddr, labelManager, settings); break;
		case CpuType::Gba: GbaDisUtils::GetDisassembly(*this, out, memoryAddr, labelManager, settings); break;
		case CpuType::Ws: WsDisUtils::GetDisassembly(*this, out, memoryAddr, labelManager, settings); break;
		default:
			throw std::runtime_error("GetDisassembly - Unsupported CPU type");
	}
}
EffectiveAddressInfo DisassemblyInfo::GetEffectiveAddress(Debugger *debugger, void *cpuState, CpuType cpuType)
{
	switch(_cpuType) {
		case CpuType::Sa1:
		case CpuType::Snes:
			return SnesDisUtils::GetEffectiveAddress(*this, (SnesConsole*)debugger->GetConsole(), *(SnesCpuState*)cpuState, cpuType);
		case CpuType::Spc: return SpcDisUtils::GetEffectiveAddress(*this, (SnesConsole*)debugger->GetConsole(), *(SpcState*)cpuState);
		case CpuType::Gsu: return GsuDisUtils::GetEffectiveAddress(*this, (SnesConsole*)debugger->GetConsole(), *(GsuState*)cpuState);
		case CpuType::Cx4: return Cx4DisUtils::GetEffectiveAddress(*this, *(Cx4State*)cpuState, debugger->GetMemoryDumper());
		case CpuType::St018: return St018DisUtils::GetEffectiveAddress(*this, (SnesConsole*)debugger->GetConsole(), *(ArmV3CpuState*)cpuState);
		case CpuType::NecDsp:
			return {};
		case CpuType::Gameboy: {
			if(debugger->GetMainCpuType() == CpuType::Snes) {
				Gameboy* gb = ((SnesConsole*)debugger->GetConsole())->GetCartridge()->GetGameboy();
				return GameboyDisUtils::GetEffectiveAddress(*this, gb, *(GbCpuState*)cpuState);
			} else {
				return GameboyDisUtils::GetEffectiveAddress(*this, (Gameboy*)debugger->GetConsole(), *(GbCpuState*)cpuState);
			}
		}
		case CpuType::Nes: return NesDisUtils::GetEffectiveAddress(*this, *(NesCpuState*)cpuState, debugger->GetMemoryDumper());
		case CpuType::Pce: return PceDisUtils::GetEffectiveAddress(*this, (PceConsole*)debugger->GetConsole(), *(PceCpuState*)cpuState);
		case CpuType::Sms: return SmsDisUtils::GetEffectiveAddress(*this, (SmsConsole*)debugger->GetConsole(), *(SmsCpuState*)cpuState);
		case CpuType::Gba: return GbaDisUtils::GetEffectiveAddress(*this, (GbaConsole*)debugger->GetConsole(), *(GbaCpuState*)cpuState);
		case CpuType::Ws: return WsDisUtils::GetEffectiveAddress(*this, (WsConsole*)debugger->GetConsole(), *(WsCpuState*)cpuState);
	}
	throw std::runtime_error("GetEffectiveAddress - Unsupported CPU type");
}
CpuType DisassemblyInfo::GetCpuType()
{
	return _cpuType;
}
uint8_t DisassemblyInfo::GetOpCode()
{
	return _byteCode[0];
}
template<CpuType type>
uint32_t DisassemblyInfo::GetFullOpCode()
{
	switch(type) {
		default: return _byteCode[0];
		case CpuType::NecDsp: return _byteCode[0] | (_byteCode[1] << 8) | (_byteCode[2] << 16);
		case CpuType::Cx4: return _byteCode[1];
		case CpuType::St018: return _byteCode[0] | (_byteCode[1] << 8) | (_opSize == 4 ? ((_byteCode[2] << 16) | (_byteCode[3] << 24)) : 0);
		case CpuType::Gba: return _byteCode[0] | (_byteCode[1] << 8) | (_opSize == 4 ? ((_byteCode[2] << 16) | (_byteCode[3] << 24)) : 0);
		case CpuType::Ws: return WsDisUtils::GetFullOpCode(*this);
	}
}
uint8_t DisassemblyInfo::GetOpSize()
{
	return _opSize;
}
uint8_t DisassemblyInfo::GetFlags()
{
	return _flags;
}
uint8_t* DisassemblyInfo::GetByteCode()
{
	return _byteCode;
}
void DisassemblyInfo::GetByteCode(uint8_t copyBuffer[8])
{
	memcpy(copyBuffer, _byteCode, _opSize);
}
void DisassemblyInfo::GetByteCode(string &out)
{
	FastString str;
	for(int i = 0; i < _opSize; i++) {
		str.WriteAll('$', HexUtilities::ToHex(_byteCode[i]));
		if(i < _opSize - 1) {
			str.Write(' ');
		}
	}
	out += str.ToString();
}
uint8_t DisassemblyInfo::GetOpSize(uint32_t opCode, uint8_t flags, CpuType type, uint32_t cpuAddress, MemoryType memType, MemoryDumper* memoryDumper)
{
	switch(type) {
		case CpuType::Snes: return SnesDisUtils::GetOpSize(opCode, flags);
		case CpuType::Spc: return SpcDisUtils::GetOpSize(opCode);
		case CpuType::NecDsp: return NecDspDisUtils::GetOpSize();
		case CpuType::Sa1:return SnesDisUtils::GetOpSize(opCode, flags);
		case CpuType::Gsu: return GsuDisUtils::GetOpSize(opCode);
		case CpuType::Cx4: return Cx4DisUtils::GetOpSize();
		case CpuType::St018: return GbaDisUtils::GetOpSize(opCode, flags);
		case CpuType::Gameboy: return GameboyDisUtils::GetOpSize(opCode);
		case CpuType::Nes: return NesDisUtils::GetOpSize(opCode);
		case CpuType::Pce: return PceDisUtils::GetOpSize(opCode);
		case CpuType::Sms: return SmsDisUtils::GetOpSize(opCode, cpuAddress, memType, memoryDumper);
		case CpuType::Gba: return GbaDisUtils::GetOpSize(opCode, flags);
		case CpuType::Ws: return WsDisUtils::GetOpSize(cpuAddress, memType, memoryDumper);
	}
	throw std::runtime_error("GetOpSize - Unsupported CPU type");
}
bool DisassemblyInfo::IsJumpToSub()
{
	switch(_cpuType) {
		case CpuType::Snes: return SnesDisUtils::IsJumpToSub(GetOpCode());
		case CpuType::Spc: return SpcDisUtils::IsJumpToSub(GetOpCode());
		case CpuType::NecDsp: return NecDspDisUtils::IsJumpToSub(GetFullOpCode<CpuType::NecDsp>());
		case CpuType::Sa1: return SnesDisUtils::IsJumpToSub(GetOpCode());
		case CpuType::Gsu: return false;
		case CpuType::Cx4: return Cx4DisUtils::IsJumpToSub(GetFullOpCode<CpuType::Cx4>());
		case CpuType::St018: return GbaDisUtils::IsJumpToSub(GetFullOpCode<CpuType::St018>(), _flags);
		case CpuType::Gameboy: return GameboyDisUtils::IsJumpToSub(GetOpCode());
		case CpuType::Nes: return NesDisUtils::IsJumpToSub(GetOpCode());
		case CpuType::Pce: return PceDisUtils::IsJumpToSub(GetOpCode());
		case CpuType::Sms: return SmsDisUtils::IsJumpToSub(GetOpCode());
		case CpuType::Gba: return GbaDisUtils::IsJumpToSub(GetFullOpCode<CpuType::Gba>(), _flags);
		case CpuType::Ws: return WsDisUtils::IsJumpToSub(GetFullOpCode<CpuType::Ws>());
	}
	throw std::runtime_error("IsJumpToSub - Unsupported CPU type");
}
bool DisassemblyInfo::IsReturnInstruction()
{
	switch(_cpuType) {
		case CpuType::Snes: return SnesDisUtils::IsReturnInstruction(GetOpCode());
		case CpuType::Spc: return SpcDisUtils::IsReturnInstruction(GetOpCode());
		case CpuType::NecDsp: return NecDspDisUtils::IsReturnInstruction(GetFullOpCode<CpuType::NecDsp>());
		case CpuType::Sa1: return SnesDisUtils::IsReturnInstruction(GetOpCode());
		case CpuType::Gsu: return false;
		case CpuType::Cx4: return Cx4DisUtils::IsReturnInstruction(GetFullOpCode<CpuType::Cx4>());
		case CpuType::St018: return GbaDisUtils::IsReturnInstruction(GetFullOpCode<CpuType::St018>(), _flags);
		case CpuType::Gameboy: return GameboyDisUtils::IsReturnInstruction(GetOpCode());
		case CpuType::Nes: return NesDisUtils::IsReturnInstruction(GetOpCode());
		case CpuType::Pce: return PceDisUtils::IsReturnInstruction(GetOpCode());
		case CpuType::Sms: return SmsDisUtils::IsReturnInstruction(_byteCode[0] | (_byteCode[1] << 8));
		case CpuType::Gba: return GbaDisUtils::IsReturnInstruction(GetFullOpCode<CpuType::Gba>(), _flags);
		case CpuType::Ws: return WsDisUtils::IsReturnInstruction(GetFullOpCode<CpuType::Ws>());
	}
	throw std::runtime_error("IsReturnInstruction - Unsupported CPU type");
}
bool DisassemblyInfo::CanDisassembleNextOp()
{
	if(IsUnconditionalJump()) {
		return false;
	}
	switch(_cpuType) {
		case CpuType::Snes: return SnesDisUtils::CanDisassembleNextOp(GetOpCode());
		case CpuType::Sa1: return SnesDisUtils::CanDisassembleNextOp(GetOpCode());
		case CpuType::Gsu: return GsuDisUtils::CanDisassembleNextOp(GetOpCode());
		case CpuType::Cx4: return Cx4DisUtils::CanDisassembleNextOp(GetByteCode()[1]);
		default: return true;
	}
}
bool DisassemblyInfo::IsUnconditionalJump()
{
	switch(_cpuType) {
		case CpuType::Snes: return SnesDisUtils::IsUnconditionalJump(GetOpCode());
		case CpuType::Spc: return SpcDisUtils::IsUnconditionalJump(GetOpCode());
		case CpuType::NecDsp: return NecDspDisUtils::IsUnconditionalJump(GetFullOpCode<CpuType::NecDsp>());
		case CpuType::Sa1: return SnesDisUtils::IsUnconditionalJump(GetOpCode());
		case CpuType::Gsu: return GsuDisUtils::IsUnconditionalJump(GetOpCode());
		case CpuType::Cx4: return Cx4DisUtils::IsUnconditionalJump(GetFullOpCode<CpuType::Cx4>());
		case CpuType::St018: return GbaDisUtils::IsUnconditionalJump(GetFullOpCode<CpuType::St018>(), _flags);
		case CpuType::Gameboy: return GameboyDisUtils::IsUnconditionalJump(GetOpCode());
		case CpuType::Nes: return NesDisUtils::IsUnconditionalJump(GetOpCode());
		case CpuType::Pce: return PceDisUtils::IsUnconditionalJump(GetOpCode());
		case CpuType::Sms: return SmsDisUtils::IsUnconditionalJump(GetOpCode());
		case CpuType::Gba: return GbaDisUtils::IsUnconditionalJump(GetFullOpCode<CpuType::Gba>(), _flags);
		case CpuType::Ws: return WsDisUtils::IsUnconditionalJump(GetFullOpCode<CpuType::Ws>());
	}
	throw std::runtime_error("IsUnconditionalJump - Unsupported CPU type");
}
bool DisassemblyInfo::IsJump()
{
	if(IsUnconditionalJump()) {
		return true;
	}
	switch(_cpuType) {
		case CpuType::Snes: return SnesDisUtils::IsConditionalJump(GetOpCode());
		case CpuType::Spc: return SpcDisUtils::IsConditionalJump(GetOpCode());
		case CpuType::NecDsp: return NecDspDisUtils::IsConditionalJump(GetFullOpCode<CpuType::NecDsp>());
		case CpuType::Sa1: return SnesDisUtils::IsConditionalJump(GetOpCode());
		case CpuType::Gsu: return GsuDisUtils::IsConditionalJump(GetOpCode());
		case CpuType::Cx4: return Cx4DisUtils::IsConditionalJump(GetFullOpCode<CpuType::Cx4>(), GetByteCode()[0]);
		case CpuType::St018: return GbaDisUtils::IsConditionalJump(GetFullOpCode<CpuType::St018>(), GetByteCode()[0]);
		case CpuType::Gameboy: return GameboyDisUtils::IsConditionalJump(GetOpCode());
		case CpuType::Nes: return NesDisUtils::IsConditionalJump(GetOpCode());
		case CpuType::Pce: return PceDisUtils::IsConditionalJump(GetOpCode());
		case CpuType::Sms: return SmsDisUtils::IsConditionalJump(GetOpCode());
		case CpuType::Gba: return GbaDisUtils::IsConditionalJump(GetFullOpCode<CpuType::Gba>(), _flags);
		case CpuType::Ws: return WsDisUtils::IsConditionalJump(GetFullOpCode<CpuType::Ws>());
	}
	throw std::runtime_error("IsJump - Unsupported CPU type");
}
void DisassemblyInfo::UpdateCpuFlags(uint8_t& cpuFlags)
{
	switch(_cpuType) {
		case CpuType::Snes: SnesDisUtils::UpdateCpuFlags(GetOpCode(), GetByteCode(), cpuFlags); break;
		case CpuType::Sa1: SnesDisUtils::UpdateCpuFlags(GetOpCode(), GetByteCode(), cpuFlags); break;
		case CpuType::Gsu: GsuDisUtils::UpdateCpuFlags(GetOpCode(), cpuFlags); break;
		default: break;
	}
}
uint32_t DisassemblyInfo::GetMemoryValue(EffectiveAddressInfo effectiveAddress, MemoryDumper *memoryDumper, MemoryType memType)
{
	MemoryType effectiveMemType = effectiveAddress.Type == MemoryType::None ? memType : effectiveAddress.Type;
	switch(effectiveAddress.ValueSize) {
		default:
		case 1: return memoryDumper->GetMemoryValue(effectiveMemType, effectiveAddress.Address);
		case 2: return memoryDumper->GetMemoryValue16(effectiveMemType, effectiveAddress.Address);
		case 4: return memoryDumper->GetMemoryValue32(effectiveMemType, effectiveAddress.Address);
	}
}
```

## File: Core/Debugger/DisassemblyInfo.h
```
#pragma once
#include "pch.h"
#include "Debugger/AddressInfo.h"
#include "Shared/MemoryType.h"
class IConsole;
class MemoryDumper;
class LabelManager;
class Debugger;
class EmuSettings;
enum class MemoryType;
enum class CpuType : uint8_t;
struct EffectiveAddressInfo
{
	int64_t Address = -1;
	MemoryType Type = MemoryType::None;
	uint8_t ValueSize = 0;
	bool ShowAddress = false;
	EffectiveAddressInfo(int64_t address = -1, uint8_t valueSize = 1, bool showAddress = true, MemoryType memType = MemoryType::None)
	{
		if(address >= 0) {
			Address = address;
			Type = memType;
			ValueSize = valueSize;
			ShowAddress = showAddress;
		}
	}
};
class DisassemblyInfo
{
private:
	uint8_t _byteCode[8];
	uint8_t _opSize;
	uint8_t _flags;
	CpuType _cpuType;
	bool _initialized = false;
	template<CpuType type> uint32_t GetFullOpCode();
public:
	DisassemblyInfo();
	DisassemblyInfo(uint32_t cpuAddress, uint8_t cpuFlags, CpuType cpuType, MemoryType memType, MemoryDumper* memoryDumper);
	void Initialize(uint32_t cpuAddress, uint8_t cpuFlags, CpuType cpuType, MemoryType memType, MemoryDumper* memoryDumper);
	bool IsInitialized();
	bool IsValid(uint8_t cpuFlags);
	void Reset();
	void GetDisassembly(string &out, uint32_t memoryAddr, LabelManager *labelManager, EmuSettings* settings);
	CpuType GetCpuType();
	uint8_t GetOpCode();
	uint8_t GetOpSize();
	uint8_t GetFlags();
	uint8_t* GetByteCode();
	void GetByteCode(uint8_t copyBuffer[8]);
	void GetByteCode(string &out);
	static uint8_t GetOpSize(uint32_t opCode, uint8_t flags, CpuType type, uint32_t cpuAddress, MemoryType memType, MemoryDumper* memoryDumper);
	bool IsJumpToSub();
	bool IsReturnInstruction();
	bool CanDisassembleNextOp();
	bool IsUnconditionalJump();
	bool IsJump();
	void UpdateCpuFlags(uint8_t& cpuFlags);
	EffectiveAddressInfo GetEffectiveAddress(Debugger* debugger, void *cpuState, CpuType type);
	uint32_t GetMemoryValue(EffectiveAddressInfo effectiveAddress, MemoryDumper *memoryDumper, MemoryType memType);
};
```

## File: Core/Debugger/DisassemblySearch.cpp
```cpp
#include "pch.h"
#include "Debugger/Disassembler.h"
#include "Debugger/DisassemblySearch.h"
#include "Debugger/LabelManager.h"
DisassemblySearch::DisassemblySearch(Disassembler* disassembler, LabelManager* labelManager)
{
	_disassembler = disassembler;
	_labelManager = labelManager;
}
int32_t DisassemblySearch::SearchDisassembly(CpuType cpuType, const char* searchString, int32_t startAddress, DisassemblySearchOptions options)
{
	CodeLineData results[1] = {};
	uint32_t resultCount = SearchDisassembly(cpuType, searchString, startAddress, options, results, 1);
	return resultCount > 0 ? results[0].Address : -1;
}
uint32_t DisassemblySearch::FindOccurrences(CpuType cpuType, const char* searchString, DisassemblySearchOptions options, CodeLineData output[], uint32_t maxResultCount)
{
	return SearchDisassembly(cpuType, searchString, 0, options, output, maxResultCount);
}
uint32_t DisassemblySearch::SearchDisassembly(CpuType cpuType, const char* searchString, int32_t startAddress, DisassemblySearchOptions options, CodeLineData searchResults[], uint32_t maxResultCount)
{
	MemoryType memType = DebugUtilities::GetCpuMemoryType(cpuType);
	uint16_t bank = startAddress >> 16;
	uint16_t maxBank = _disassembler->GetMaxBank(cpuType);
	vector<DisassemblyResult> rows = _disassembler->Disassemble(cpuType, bank);
	if(rows.empty()) {
		return -1;
	}
	int step = options.SearchBackwards ? -1 : 1;
	string searchStr = searchString;
	int32_t startRow = _disassembler->GetMatchingRow(rows, startAddress, options.SearchBackwards);
	if(options.SearchBackwards) {
		startRow--;
	} else if(options.SkipFirstLine) {
		startRow++;
	}
	if(startRow >= 0 && startRow < rows.size()) {
		startAddress = rows[startRow].CpuAddress;
	}
	uint32_t resultCount = 0;
	int32_t prevAddress = -1;
	CodeLineData lineData = {};
	int rowCounter = 0;
	string txt;
	do {
		for(int i = startRow; i >= 0 && i < rows.size(); i += step) {
			if(rows[i].CpuAddress < 0) {
				continue;
			}
			if(
				(!options.SearchBackwards && prevAddress < startAddress && rows[i].CpuAddress >= startAddress) ||
				(options.SearchBackwards && prevAddress > startAddress && rows[i].CpuAddress <= startAddress) ||
				rowCounter > 500000
			) {
				if(rowCounter > 0) {
					return resultCount;
				}
			}
			rowCounter++;
			prevAddress = rows[i].CpuAddress;
			_disassembler->GetLineData(rows[i], cpuType, memType, lineData);
			if(TextContains(searchStr, lineData.Text, 1000, options)) {
				searchResults[resultCount] = lineData;
				if(maxResultCount == ++resultCount) {
					return resultCount;
				}
				continue;
			}
			if(TextContains(searchStr, lineData.Comment, 1000, options)) {
				searchResults[resultCount] = lineData;
				if(maxResultCount == ++resultCount) {
					return resultCount;
				}
				continue;
			}
			if(lineData.EffectiveAddress.ShowAddress && lineData.EffectiveAddress.Address >= 0) {
				txt = _labelManager->GetLabel({ (int32_t)lineData.EffectiveAddress.Address, lineData.EffectiveAddress.Type });
				if(txt.empty()) {
					txt = "[$" + DebugUtilities::AddressToHex(lineData.LineCpuType, lineData.EffectiveAddress.Address) + "]";
				} else {
					txt = "[" + txt + "]";
				}
				if(TextContains(searchStr, txt.c_str(), (int)txt.size(), options)) {
					searchResults[resultCount] = lineData;
					if(maxResultCount == ++resultCount) {
						return resultCount;
					}
					continue;
				}
			}
			if(maxResultCount == 1 && lineData.EffectiveAddress.ValueSize > 0) {
				txt = "$" + (lineData.EffectiveAddress.ValueSize == 2 ? HexUtilities::ToHex((uint16_t)lineData.Value) : HexUtilities::ToHex((uint8_t)lineData.Value));
				if(TextContains(searchStr, txt.c_str(), (int)txt.size(), options)) {
					searchResults[resultCount] = lineData;
					if(maxResultCount == ++resultCount) {
						return resultCount;
					}
					continue;
				}
			}
		}
		int nextBank = (int)bank + step;
		if(nextBank < 0) {
			nextBank = maxBank;
		} else if(nextBank > maxBank) {
			if(startAddress == 0) {
				return resultCount;
			}
			nextBank = 0;
		}
		bank = (uint16_t)nextBank;
		rows = _disassembler->Disassemble(cpuType, bank);
		if(rows.empty()) {
			return resultCount;
		}
		startRow = options.SearchBackwards ? (int32_t)rows.size() - 1 : 0;
	} while(true);
	return resultCount;
}
bool DisassemblySearch::TextContains(string& needle, const char* hay, int size, DisassemblySearchOptions& options)
{
	if(options.MatchCase) {
		return TextContains<true>(needle, hay, size, options);
	} else {
		return TextContains<false>(needle, hay, size, options);
	}
}
template<bool matchCase>
bool DisassemblySearch::TextContains(string& needle, const char* hay, int size, DisassemblySearchOptions& options)
{
	int pos = 0;
	for(int j = 0; j < size; j++) {
		char c = hay[j];
		if(c <= 0) {
			break;
		}
		if(needle[pos] == (matchCase ? c : tolower(c))) {
			if(options.MatchWholeWord && pos == 0 && j > 0 && !IsWordSeparator(hay[j - 1])) {
				continue;
			}
			pos++;
			if(pos == (int)needle.size()) {
				if(options.MatchWholeWord && j < size - 1 && !IsWordSeparator(hay[j + 1])) {
					j -= pos - 1;
					pos = 0;
					continue;
				}
				return true;
			}
		} else {
			j -= pos;
			pos = 0;
		}
	}
	return false;
}
bool DisassemblySearch::IsWordSeparator(char c)
{
	return !((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') || c == '_' || c == '@' || c == '$' || c == '#');
}
```

## File: Core/Debugger/DisassemblySearch.h
```
#pragma once
#include "pch.h"
#include "Debugger/DisassemblyInfo.h"
#include "Debugger/DebugTypes.h"
#include "Debugger/DebugUtilities.h"
class Disassembler;
class LabelManager;
enum class CpuType : uint8_t;
struct DisassemblySearchOptions
{
	bool MatchCase;
	bool MatchWholeWord;
	bool SearchBackwards;
	bool SkipFirstLine;
};
class DisassemblySearch
{
private:
	Disassembler* _disassembler;
	LabelManager* _labelManager;
	uint32_t SearchDisassembly(CpuType cpuType, const char* searchString, int32_t startAddress, DisassemblySearchOptions options, CodeLineData searchResults[], uint32_t maxResultCount);
	template<bool matchCase> bool TextContains(string& needle, const char* hay, int size, DisassemblySearchOptions& options);
	bool TextContains(string& needle, const char* hay, int size, DisassemblySearchOptions& options);
	bool IsWordSeparator(char c);
public:
	DisassemblySearch(Disassembler* disassembler, LabelManager* labelManager);
	int32_t SearchDisassembly(CpuType cpuType, const char* searchString, int32_t startAddress, DisassemblySearchOptions options);
	uint32_t FindOccurrences(CpuType cpuType, const char* searchString, DisassemblySearchOptions options, CodeLineData output[], uint32_t maxResultCount);
};
```

## File: Core/Debugger/ExpressionEvaluator.cpp
```cpp
#include "pch.h"
#include <climits>
#include <algorithm>
#include "Debugger/DebugTypes.h"
#include "Debugger/ExpressionEvaluator.h"
#include "SNES/SnesConsole.h"
#include "Debugger/Debugger.h"
#include "Debugger/IDebugger.h"
#include "Debugger/MemoryDumper.h"
#include "Debugger/Disassembler.h"
#include "Debugger/LabelManager.h"
#include "Debugger/DebugUtilities.h"
#include "Utilities/HexUtilities.h"
const vector<string> ExpressionEvaluator::_binaryOperators = { { "*", "/", "%", "+", "-", "<<", ">>", "<", "<=", ">", ">=", "==", "!=", "&", "^", "|", "&&", "||" } };
const vector<int> ExpressionEvaluator::_binaryPrecedence = { { 10,  10,  10,   9,   9,    8,    8,   7,   7,    7,    7,    6,    6,   5,   4,   3,    2,    1 } };
const vector<string> ExpressionEvaluator::_unaryOperators = { { "+", "-", "~", "!", ":", "#" } };
const vector<int> ExpressionEvaluator::_unaryPrecedence = { { 11,  11,  11,  11, 11, 11 } };
const std::unordered_set<string> ExpressionEvaluator::_operators = { { "*", "/", "%", "+", "-", "<<", ">>", "<", "<=", ">", ">=", "==", "!=", "&", "^", "|", "&&", "||", "~", "!", "(", ")", "{", "}", "[", "]", ":", "#" } };
bool ExpressionEvaluator::IsOperator(string token, int &precedence, bool unaryOperator)
{
	if(unaryOperator) {
		for(size_t i = 0, len = _unaryOperators.size(); i < len; i++) {
			if(token.compare(_unaryOperators[i]) == 0) {
				precedence = _unaryPrecedence[i];
				return true;
			}
		}
	} else {
		for(size_t i = 0, len = _binaryOperators.size(); i < len; i++) {
			if(token.compare(_binaryOperators[i]) == 0) {
				precedence = _binaryPrecedence[i];
				return true;
			}
		}
	}
	return false;
}
EvalOperators ExpressionEvaluator::GetOperator(string token, bool unaryOperator)
{
	if(unaryOperator) {
		for(size_t i = 0, len = _unaryOperators.size(); i < len; i++) {
			if(token.compare(_unaryOperators[i]) == 0) {
				return (EvalOperators)(EvalOperators::Plus + i);
			}
		}
	} else {
		for(size_t i = 0, len = _binaryOperators.size(); i < len; i++) {
			if(token.compare(_binaryOperators[i]) == 0) {
				return (EvalOperators)(EvalOperators::Multiplication + i);
			}
		}
	}
	return EvalOperators::Addition;
}
unordered_map<string, int64_t>* ExpressionEvaluator::GetAvailableTokens()
{
	switch(_cpuType) {
		case CpuType::Snes: return &GetSnesTokens();
		case CpuType::Spc: return &GetSpcTokens();
		case CpuType::NecDsp: return &GetNecDspTokens();
		case CpuType::Sa1: return &GetSnesTokens();
		case CpuType::Gsu: return &GetGsuTokens();
		case CpuType::Cx4: return &GetCx4Tokens();
		case CpuType::St018: return &GetSt018Tokens();
		case CpuType::Gameboy: return &GetGameboyTokens();
		case CpuType::Nes: return &GetNesTokens();
		case CpuType::Pce: return &GetPceTokens();
		case CpuType::Sms: return &GetSmsTokens();
		case CpuType::Gba: return &GetGbaTokens();
		case CpuType::Ws: return &GetWsTokens();
	}
	return nullptr;
}
bool ExpressionEvaluator::CheckSpecialTokens(string expression, size_t &pos, string &output, ExpressionData &data)
{
	string token;
	size_t initialPos = pos;
	size_t len = expression.size();
	do {
		char c = std::tolower(expression[pos]);
		if((c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') || c == '_' || c == '@' || c == '\'') {
			token += c;
			pos++;
		} else {
			break;
		}
	} while(pos < len);
	int64_t tokenValue = -1;
	unordered_map<string, int64_t>* availableTokens = GetAvailableTokens();
	if(availableTokens) {
		auto result = availableTokens->find(token);
		if(result != availableTokens->end()) {
			tokenValue = result->second;
		}
	}
	if(tokenValue != -1) {
		output += std::to_string(tokenValue);
		return true;
	}
	int64_t sharedToken = ProcessSharedTokens(token);
	if(sharedToken != -1) {
		output += std::to_string(sharedToken);
		return true;
	}
	string originalExpression = expression.substr(initialPos, pos - initialPos);
	bool validLabel = _labelManager->ContainsLabel(originalExpression);
	if(!validLabel) {
		string label = originalExpression + "+0";
		validLabel = _labelManager->ContainsLabel(label);
	}
	if(validLabel) {
		data.Labels.push_back(originalExpression);
		output += std::to_string(EvalValues::FirstLabelIndex + data.Labels.size() - 1);
		return true;
	} else {
		return false;
	}
}
int64_t ExpressionEvaluator::ProcessSharedTokens(string token)
{
	if(token == "value") {
		return EvalValues::Value;
	} else if(token == "address") {
		return EvalValues::Address;
	} else if(token == "memaddress") {
		return EvalValues::MemoryAddress;
	} else if(token == "iswrite") {
		return EvalValues::IsWrite;
	} else if(token == "isread") {
		return EvalValues::IsRead;
	} else if(token == "isdma") {
		return EvalValues::IsDma;
	} else if(token == "isdummy") {
		return EvalValues::IsDummy;
	} else if(token == "oppc") {
		return EvalValues::OpProgramCounter;
	}
	return -1;
}
string ExpressionEvaluator::GetNextToken(string expression, size_t &pos, ExpressionData &data, bool &success, bool previousTokenIsOp)
{
	string output;
	success = true;
	if(expression.empty()) {
		success = false;
		return "";
	}
	char c = std::tolower(expression[pos]);
	char nextChar = (pos + 1 < expression.size()) ? std::tolower(expression[pos + 1]) : '\0';
	if(c == '$' || (c == '0' && nextChar == 'x')) {
		//Hex numbers
		pos++;
		if(c == '0') {
			//Skip over 'x' in '0x' prefix
			pos++;
		}
		for(size_t len = expression.size(); pos < len; pos++) {
			c = std::tolower(expression[pos]);
			if((c >= '0' && c <= '9') || (c >= 'a' && c <= 'f')) {
				output += c;
			} else {
				break;
			}
		}
		if(output.empty()) {
			//No numbers followed the hex mark, this isn't a valid expression
			success = false;
		}
		output = std::to_string((uint32_t)HexUtilities::FromHex(output));
	} else if(c == '%' && previousTokenIsOp) {
		//Binary numbers
		pos++;
		for(size_t len = expression.size(); pos < len; pos++) {
			c = std::tolower(expression[pos]);
			if(c == '0' || c == '1') {
				output += c;
			} else {
				break;
			}
		}
		if(output.empty()) {
			//No numbers followed the binary mark, this isn't a valid expression
			success = false;
		}
		uint32_t value = 0;
		for(size_t i = 0; i < output.size(); i++) {
			value <<= 1;
			value |= output[i] == '1' ? 1 : 0;
		}
		output = std::to_string(value);
	} else if(c >= '0' && c <= '9') {
		//Regular numbers
		for(size_t len = expression.size(); pos < len; pos++) {
			c = std::tolower(expression[pos]);
			if(c >= '0' && c <= '9') {
				output += c;
			} else {
				break;
			}
		}
	} else if((c < 'a' || c > 'z') && c != '_' && c != '@' && c != '\'') {
		//Operators
		string operatorToken;
		for(size_t len = expression.size(); pos < len; pos++) {
			c = std::tolower(expression[pos]);
			operatorToken += c;
			if(output.empty() || _operators.find(operatorToken) != _operators.end()) {
				//If appending the next char results in a valid operator, append it (or if this is the first character)
				output += c;
			} else {
				//Reached the end of the operator, return
				break;
			}
		}
	} else {
		//Special tokens and labels
		success = CheckSpecialTokens(expression, pos, output, data);
	}
	return output;
}
bool ExpressionEvaluator::ProcessSpecialOperator(EvalOperators evalOp, std::stack<EvalOperators> &opStack, std::stack<int> &precedenceStack, vector<int64_t> &outputQueue)
{
	if(opStack.empty()) {
		return false;
	}
	while(opStack.top() != evalOp) {
		outputQueue.push_back(opStack.top());
		opStack.pop();
		precedenceStack.pop();
		if(opStack.empty()) {
			return false;
		}
	}
	if(evalOp != EvalOperators::Parenthesis) {
		outputQueue.push_back(opStack.top());
	}
	opStack.pop();
	precedenceStack.pop();
	return true;
}
bool ExpressionEvaluator::ToRpn(string expression, ExpressionData &data)
{
	std::stack<EvalOperators> opStack = std::stack<EvalOperators>();
	std::stack<int> precedenceStack;
	size_t position = 0;
	int parenthesisCount = 0;
	int bracketCount = 0;
	int braceCount = 0;
	bool previousTokenIsOp = true;
	bool operatorExpected = false;
	bool operatorOrEndTokenExpected = false;
	while(true) {
		bool success = true;
		string token = GetNextToken(expression, position, data, success, previousTokenIsOp);
		if(!success) {
			return false;
		}
		if(token.empty()) {
			break;
		}
		bool requireOperator = operatorExpected;
		bool requireOperatorOrEndToken = operatorOrEndTokenExpected;
		bool unaryOperator = previousTokenIsOp;
		operatorExpected = false;
		operatorOrEndTokenExpected = false;
		previousTokenIsOp = false;
		int precedence = 0;
		if(IsOperator(token, precedence, unaryOperator)) {
			EvalOperators op = GetOperator(token, unaryOperator);
			bool rightAssociative = unaryOperator;
			while(!opStack.empty() && ((rightAssociative && precedence < precedenceStack.top()) || (!rightAssociative && precedence <= precedenceStack.top()))) {
				//Pop operators from the stack until we find something with higher priority (or empty the stack)
				data.RpnQueue.push_back(opStack.top());
				opStack.pop();
				precedenceStack.pop();
			}
			opStack.push(op);
			precedenceStack.push(precedence);
			previousTokenIsOp = true;
		} else if(requireOperator) {
			//We needed an operator, and got something else, this isn't a valid expression (e.g "(3)4" or "[$00]22")
			return false;
		} else if(requireOperatorOrEndToken && token[0] != ')' && token[0] != ']' && token[0] != '}') {
			return false;
		} else if(token[0] == '(') {
			parenthesisCount++;
			opStack.push(EvalOperators::Parenthesis);
			precedenceStack.push(0);
			previousTokenIsOp = true;
		} else if(token[0] == ')') {
			parenthesisCount--;
			if(!ProcessSpecialOperator(EvalOperators::Parenthesis, opStack, precedenceStack, data.RpnQueue)) {
				return false;
			}
			operatorOrEndTokenExpected = true;
		} else if(token[0] == '[') {
			bracketCount++;
			opStack.push(EvalOperators::Bracket);
			precedenceStack.push(0);
		} else if(token[0] == ']') {
			bracketCount--;
			if(!ProcessSpecialOperator(EvalOperators::Bracket, opStack, precedenceStack, data.RpnQueue)) {
				return false;
			}
			operatorOrEndTokenExpected = true;
		} else if(token[0] == '{') {
			braceCount++;
			opStack.push(EvalOperators::Braces);
			precedenceStack.push(0);
		} else if(token[0] == '}') {
			braceCount--;
			if(!ProcessSpecialOperator(EvalOperators::Braces, opStack, precedenceStack, data.RpnQueue)){
				return false;
			}
			operatorOrEndTokenExpected = true;
		} else {
			if(token[0] < '0' || token[0] > '9') {
				return false;
			} else {
				data.RpnQueue.push_back(std::stoll(token));
				operatorOrEndTokenExpected = true;
			}
		}
	}
	if(braceCount || bracketCount || parenthesisCount) {
		return false;
	}
	while(!opStack.empty()) {
		data.RpnQueue.push_back(opStack.top());
		opStack.pop();
	}
	return true;
}
int64_t ExpressionEvaluator::Evaluate(ExpressionData &data, EvalResultType &resultType, MemoryOperationInfo &operationInfo, AddressInfo& addressInfo)
{
	if(data.RpnQueue.empty()) {
		resultType = EvalResultType::Invalid;
		return 0;
	}
	int pos = 0;
	int64_t right = 0;
	int64_t left = 0;
	int64_t operandStack[100];
	resultType = EvalResultType::Numeric;
	for(size_t i = 0, len = data.RpnQueue.size(); i < len; i++) {
		int64_t token = data.RpnQueue[i];
		if(token >= EvalValues::RegA) {
			if(token >= EvalValues::FirstLabelIndex) {
				int64_t labelIndex = token - EvalValues::FirstLabelIndex;
				if((size_t)labelIndex < data.Labels.size()) {
					token = _labelManager->GetLabelRelativeAddress(data.Labels[(uint32_t)labelIndex], _cpuType);
				} else {
					token = -2;
				}
				if(token < 0) {
					resultType = token == -1 ? EvalResultType::OutOfScope : EvalResultType::Invalid;
					return 0;
				}
			} else {
				switch(token) {
					case EvalValues::Value: token = operationInfo.Value; break;
					case EvalValues::Address: token = operationInfo.Address; break;
					case EvalValues::MemoryAddress: token = addressInfo.Address; break;
					case EvalValues::IsWrite: token = operationInfo.Type == MemoryOperationType::Write || operationInfo.Type == MemoryOperationType::DmaWrite || operationInfo.Type == MemoryOperationType::DummyWrite; break;
					case EvalValues::IsRead: token = operationInfo.Type != MemoryOperationType::Write && operationInfo.Type != MemoryOperationType::DmaWrite && operationInfo.Type != MemoryOperationType::DummyWrite; break;
					case EvalValues::IsDma: token = operationInfo.Type == MemoryOperationType::DmaRead || operationInfo.Type == MemoryOperationType::DmaWrite; break;
					case EvalValues::IsDummy: token = operationInfo.Type == MemoryOperationType::DummyRead|| operationInfo.Type == MemoryOperationType::DummyWrite; break;
					case EvalValues::OpProgramCounter: token = _cpuDebugger->GetProgramCounter(true); break;
					default:
						if(!_cpuDebugger) {
							token = 0;
						} else {
							switch(_cpuType) {
								case CpuType::Snes: token = GetSnesTokenValue(token, resultType); break;
								case CpuType::Spc: token = GetSpcTokenValue(token, resultType); break;
								case CpuType::NecDsp: token = GetNecDspTokenValue(token, resultType); break;
								case CpuType::Sa1: token = GetSnesTokenValue(token, resultType); break;
								case CpuType::Gsu: token = GetGsuTokenValue(token, resultType); break;
								case CpuType::Cx4: token = GetCx4TokenValue(token, resultType); break;
								case CpuType::St018: token = GetSt018TokenValue(token, resultType); break;
								case CpuType::Gameboy: token = GetGameboyTokenValue(token, resultType); break;
								case CpuType::Nes: token = GetNesTokenValue(token, resultType); break;
								case CpuType::Pce: token = GetPceTokenValue(token, resultType); break;
								case CpuType::Sms: token = GetSmsTokenValue(token, resultType); break;
								case CpuType::Gba: token = GetGbaTokenValue(token, resultType); break;
								case CpuType::Ws: token = GetWsTokenValue(token, resultType); break;
							}
						}
						break;
				}
			}
		} else if(token >= EvalOperators::Multiplication) {
			if(pos <= 0) {
				resultType = EvalResultType::Invalid;
				return 0;
			}
			right = operandStack[--pos];
			if(pos > 0 && token <= EvalOperators::LogicalOr) {
				left = operandStack[--pos];
			}
			resultType = EvalResultType::Numeric;
			switch(token) {
				case EvalOperators::Multiplication: token = left * right; break;
				case EvalOperators::Division:
					if(right == 0) {
						resultType = EvalResultType::DivideBy0;
						return 0;
					}
					token = left / right; break;
				case EvalOperators::Modulo:
					if(right == 0) {
						resultType = EvalResultType::DivideBy0;
						return 0;
					}
					token = left % right;
					break;
				case EvalOperators::Addition: token = left + right; break;
				case EvalOperators::Substration: token = left - right; break;
				case EvalOperators::ShiftLeft: token = left << right; break;
				case EvalOperators::ShiftRight: token = left >> right; break;
				case EvalOperators::SmallerThan: token = left < right; resultType = EvalResultType::Boolean; break;
				case EvalOperators::SmallerOrEqual: token = left <= right; resultType = EvalResultType::Boolean; break;
				case EvalOperators::GreaterThan: token = left > right; resultType = EvalResultType::Boolean; break;
				case EvalOperators::GreaterOrEqual: token = left >= right; resultType = EvalResultType::Boolean; break;
				case EvalOperators::Equal: token = left == right; resultType = EvalResultType::Boolean; break;
				case EvalOperators::NotEqual: token = left != right; resultType = EvalResultType::Boolean; break;
				case EvalOperators::BinaryAnd: token = left & right; break;
				case EvalOperators::BinaryXor: token = left ^ right; break;
				case EvalOperators::BinaryOr: token = left | right; break;
				case EvalOperators::LogicalAnd: token = (bool)(left && right); resultType = EvalResultType::Boolean; break;
				case EvalOperators::LogicalOr: token = (bool)(left || right); resultType = EvalResultType::Boolean; break;
				case EvalOperators::Plus: token = right; break;
				case EvalOperators::Minus: token = -right; break;
				case EvalOperators::BinaryNot: token = ~right; break;
				case EvalOperators::LogicalNot: token = (bool)!right; break;
				case EvalOperators::AbsoluteAddress: token = right >= 0 ? _debugger->GetAbsoluteAddress({ (int32_t)right, _cpuMemory }).Address : -1; break;
				case EvalOperators::ReadDword: token = _debugger->GetMemoryDumper()->GetMemoryValue32(_cpuMemory, (uint32_t)right); break;
				case EvalOperators::Bracket: token = _debugger->GetMemoryDumper()->GetMemoryValue(_cpuMemory, (uint32_t)right); break;
				case EvalOperators::Braces: token = _debugger->GetMemoryDumper()->GetMemoryValue16(_cpuMemory, (uint32_t)right); break;
				default: throw std::runtime_error("Invalid operator");
			}
		}
		operandStack[pos++] = token;
		if(pos >= 100) {
			resultType = EvalResultType::Invalid;
			return 0;
		}
	}
	return std::clamp<int64_t>(operandStack[0], INT32_MIN, UINT32_MAX);
}
ExpressionEvaluator::ExpressionEvaluator(Debugger* debugger, IDebugger* cpuDebugger, CpuType cpuType)
{
	_debugger = debugger;
	_cpuDebugger = cpuDebugger;
	_labelManager = debugger->GetLabelManager();
	_cpuType = cpuType;
	_cpuMemory = DebugUtilities::GetCpuMemoryType(cpuType);
}
bool ExpressionEvaluator::ReturnBool(int64_t value, EvalResultType& resultType)
{
	resultType = EvalResultType::Boolean;
	return value != 0;
}
ExpressionData ExpressionEvaluator::GetRpnList(string expression, bool &success)
{
	ExpressionData* cachedData = PrivateGetRpnList(expression, success);
	if(cachedData) {
		return *cachedData;
	} else {
		return ExpressionData();
	}
}
void ExpressionEvaluator::GetTokenList(char* tokenList)
{
	unordered_map<string, int64_t>* availableTokens = GetAvailableTokens();
	vector<std::pair<string, int64_t>> entries;
	int pos = 0;
	if(availableTokens) {
		for(auto entry : *availableTokens) {
			entries.push_back(entry);
		}
	}
	std::sort(entries.begin(), entries.end(), [&](const auto& a, const auto& b) -> bool {
		return a.second < b.second;
	});
	for(auto entry : entries) {
		if(pos + entry.first.size() + 1 >= 1000) {
			break;
		}
		memcpy(tokenList + pos, entry.first.c_str(), entry.first.size());
		pos += (int)entry.first.size();
		tokenList[pos] = '|';
		pos++;
	}
}
ExpressionData* ExpressionEvaluator::PrivateGetRpnList(string expression, bool& success)
{
	ExpressionData *cachedData = nullptr;
	{
		LockHandler lock = _cacheLock.AcquireSafe();
		auto result = _cache.find(expression);
		if(result != _cache.end()) {
			cachedData = &(result->second);
		}
	}
	if(cachedData == nullptr) {
		string fixedExp = expression;
		fixedExp.erase(std::remove(fixedExp.begin(), fixedExp.end(), ' '), fixedExp.end());
		ExpressionData data;
		success = ToRpn(fixedExp, data);
		if(success) {
			LockHandler lock = _cacheLock.AcquireSafe();
			_cache[expression] = data;
			cachedData = &_cache[expression];
		}
	} else {
		success = true;
	}
	return cachedData;
}
int64_t ExpressionEvaluator::PrivateEvaluate(string expression, EvalResultType &resultType, MemoryOperationInfo &operationInfo, AddressInfo& addressInfo, bool& success)
{
	success = true;
	ExpressionData *cachedData = PrivateGetRpnList(expression, success);
	if(!success) {
		resultType = EvalResultType::Invalid;
		return 0;
	}
	return Evaluate(*cachedData, resultType, operationInfo, addressInfo);
}
int64_t ExpressionEvaluator::Evaluate(string expression, EvalResultType &resultType, MemoryOperationInfo &operationInfo, AddressInfo& addressInfo)
{
	try {
		bool success;
		int64_t result = PrivateEvaluate(expression, resultType, operationInfo, addressInfo, success);
		if(success) {
			return result;
		}
	} catch(std::exception&) {
	}
	resultType = EvalResultType::Invalid;
	return 0;
}
bool ExpressionEvaluator::Validate(string expression)
{
	try {
		EvalResultType type;
		MemoryOperationInfo operationInfo = {};
		AddressInfo addressInfo = {};
		bool success;
		PrivateEvaluate(expression, type, operationInfo, addressInfo, success);
		return success;
	} catch(std::exception&) {
		return false;
	}
}
#if _DEBUG
#include <assert.h>
#include "SNES/SnesCpuTypes.h"
#include "SNES/SnesPpuTypes.h"
void ExpressionEvaluator::RunTests()
{
	auto test = [=](string expr, EvalResultType expectedType, int64_t expectedResult) {
		MemoryOperationInfo opInfo = {};
		AddressInfo addrInfo = {};
		EvalResultType type;
		int64_t result = Evaluate(expr, type, opInfo, addrInfo);
		assert(type == expectedType);
		assert(result == expectedResult);
	};
	test("1 - -1", EvalResultType::Numeric, 2);
	test("1 - (-1)", EvalResultType::Numeric, 2);
	test("1 - -(-1)", EvalResultType::Numeric, 0);
	test("(0 - 1) == -1 && 5 < 10", EvalResultType::Boolean, true);
	test("(0 - 1) == 0 || 5 < 10", EvalResultType::Boolean, true);
	test("(0 - 1) == 0 || 5 < -10", EvalResultType::Boolean, false);
	test("(0 - 1) == 0 || 15 < 10", EvalResultType::Boolean, false);
	test("10 != $10", EvalResultType::Boolean, true);
	test("10 == $A", EvalResultType::Boolean, true);
	test("10 == $0A", EvalResultType::Boolean, true);
	test("(0 - 1 == 0 || 15 < 10", EvalResultType::Invalid, 0);
	test("10 / 0", EvalResultType::DivideBy0, 0);
	uint8_t byte4500 = _debugger->GetMemoryDumper()->GetMemoryValue(_cpuMemory, 0x4500);
	uint16_t word4500 = _debugger->GetMemoryDumper()->GetMemoryValue16(_cpuMemory, 0x4500);
	uint32_t dword4500 = _debugger->GetMemoryDumper()->GetMemoryValue32(_cpuMemory, 0x4500);
	uint32_t dword4501 = _debugger->GetMemoryDumper()->GetMemoryValue32(_cpuMemory, 0x4501);
	uint8_t indirectByte = _debugger->GetMemoryDumper()->GetMemoryValue(_cpuMemory, 0x4500 + byte4500);
	SnesCpuState& state = (SnesCpuState&)_cpuDebugger->GetState();
	SnesPpuState ppu;
	_cpuDebugger->GetPpuState(ppu);
	test("x + 5", EvalResultType::Numeric, state.X + 5);
	test("x == 0", EvalResultType::Boolean, state.X == 0);
	test("x == y", EvalResultType::Boolean, state.X == state.Y);
	test("x == y == scanline", EvalResultType::Boolean, state.X == state.Y == ppu.Scanline);
	test("x == y && !(a == x)", EvalResultType::Boolean, state.X == state.Y && !(state.A == state.X));
	test("(~0 & ~1) & $FFF == $FFE", EvalResultType::Numeric, 0);
	test("((~0 & ~1) & $FFF) == $FFE", EvalResultType::Boolean, true);
	test("1+3*3+10/(3+4)", EvalResultType::Numeric, 11);
	test("(1+3*3+10)/(3+4)", EvalResultType::Numeric, 2);
	test("(1+3*3+10)/3+4", EvalResultType::Numeric, 10);
	test("{$4500}", EvalResultType::Numeric, word4500);
	test("[$4500]", EvalResultType::Numeric, byte4500);
	test("[$45]3", EvalResultType::Invalid, 0);
	test("($45)3", EvalResultType::Invalid, 0);
	test("($45]", EvalResultType::Invalid, 0);
	test("%11", EvalResultType::Numeric, 3);
	test("%011", EvalResultType::Numeric, 3);
	test("%1011", EvalResultType::Numeric, 11);
	test("%12", EvalResultType::Invalid, 0);
	test("10 % 5", EvalResultType::Numeric, 0);
	test("%100 % 5", EvalResultType::Numeric, 4);
	test("%100%5", EvalResultType::Numeric, 4);
	test("%10(10)", EvalResultType::Invalid, 0);
	test("10%4*10", EvalResultType::Numeric, 20);
	test("(5+5)%3", EvalResultType::Numeric, 1);
	test("11%%10", EvalResultType::Numeric, 1);
	test("[$4500+[$4500]]", EvalResultType::Numeric, indirectByte);
	test("-($10+[$4500])", EvalResultType::Numeric, -(0x10 + byte4500));
	test("#$4500", EvalResultType::Numeric, dword4500);
	test("#$4500+1", EvalResultType::Numeric, dword4500 + 1);
	test("#($4500+1)", EvalResultType::Numeric, dword4501);
}
#endif
```

## File: Core/Debugger/ExpressionEvaluator.Cx4.cpp
```cpp
#include "pch.h"
#include "Debugger/ExpressionEvaluator.h"
#include "SNES/Debugger/Cx4Debugger.h"
#include "SNES/Coprocessors/CX4/Cx4Types.h"
unordered_map<string, int64_t>& ExpressionEvaluator::GetCx4Tokens()
{
	static unordered_map<string, int64_t> supportedTokens = {
		{ "r0", EvalValues::R0 },
		{ "r1", EvalValues::R1 },
		{ "r2", EvalValues::R2 },
		{ "r3", EvalValues::R3 },
		{ "r4", EvalValues::R4 },
		{ "r5", EvalValues::R5 },
		{ "r6", EvalValues::R6 },
		{ "r7", EvalValues::R7 },
		{ "r8", EvalValues::R8 },
		{ "r9", EvalValues::R9 },
		{ "r10", EvalValues::R10 },
		{ "r11", EvalValues::R11 },
		{ "r12", EvalValues::R12 },
		{ "r13", EvalValues::R13 },
		{ "r14", EvalValues::R14 },
		{ "r15", EvalValues::R15 },
		{ "pb", EvalValues::RegPB },
		{ "pc", EvalValues::RegPC },
		{ "a", EvalValues::RegA },
		{ "p", EvalValues::RegP },
		{ "sp", EvalValues::RegSP },
		{ "mult", EvalValues::RegMult },
		{ "negative", EvalValues::RegPS_Negative },
		{ "zero", EvalValues::RegPS_Zero },
		{ "carry", EvalValues::RegPS_Carry },
		{ "overflow", EvalValues::RegPS_Overflow },
		{ "irq", EvalValues::RegPS_Interrupt },
		{ "mdr", EvalValues::RegMDR },
		{ "mar", EvalValues::RegMAR },
		{ "dpr", EvalValues::RegDPR },
	};
	return supportedTokens;
}
int64_t ExpressionEvaluator::GetCx4TokenValue(int64_t token, EvalResultType& resultType)
{
	Cx4State& s = (Cx4State&)((Cx4Debugger*)_cpuDebugger)->GetState();
	switch(token) {
		case EvalValues::R0: return s.Regs[0];
		case EvalValues::R1: return s.Regs[1];
		case EvalValues::R2: return s.Regs[2];
		case EvalValues::R3: return s.Regs[3];
		case EvalValues::R4: return s.Regs[4];
		case EvalValues::R5: return s.Regs[5];
		case EvalValues::R6: return s.Regs[6];
		case EvalValues::R7: return s.Regs[7];
		case EvalValues::R8: return s.Regs[8];
		case EvalValues::R9: return s.Regs[9];
		case EvalValues::R10: return s.Regs[10];
		case EvalValues::R11: return s.Regs[11];
		case EvalValues::R12: return s.Regs[12];
		case EvalValues::R13: return s.Regs[13];
		case EvalValues::R14: return s.Regs[14];
		case EvalValues::R15: return s.Regs[15];
		case EvalValues::RegPB: return s.PB;
		case EvalValues::RegPC: return s.PC;
		case EvalValues::RegA: return s.A;
		case EvalValues::RegP: return s.P;
		case EvalValues::RegSP: return s.SP;
		case EvalValues::RegMult: return s.Mult;
		case EvalValues::RegPS_Negative: return ReturnBool(s.Negative, resultType);
		case EvalValues::RegPS_Zero: return ReturnBool(s.Zero, resultType);
		case EvalValues::RegPS_Carry: return ReturnBool(s.Carry, resultType);
		case EvalValues::RegPS_Overflow: return ReturnBool(s.Overflow, resultType);
		case EvalValues::RegPS_Interrupt: return ReturnBool(s.IrqFlag, resultType);
		case EvalValues::RegMDR: return s.MemoryDataReg;
		case EvalValues::RegMAR: return s.MemoryAddressReg;
		case EvalValues::RegDPR: return s.DataPointerReg;
		default: return 0;
	}
}
```

## File: Core/Debugger/ExpressionEvaluator.Gameboy.cpp
```cpp
#include "pch.h"
#include "Debugger/ExpressionEvaluator.h"
#include "Gameboy/Debugger/GbDebugger.h"
#include "Gameboy/GbTypes.h"
unordered_map<string, int64_t>& ExpressionEvaluator::GetGameboyTokens()
{
	static unordered_map<string, int64_t> supportedTokens = {
		{ "a", EvalValues::RegA },
		{ "b", EvalValues::RegB },
		{ "c", EvalValues::RegC },
		{ "d", EvalValues::RegD },
		{ "e", EvalValues::RegE },
		{ "f", EvalValues::RegF },
		{ "h", EvalValues::RegH },
		{ "l", EvalValues::RegL },
		{ "af", EvalValues::RegAF },
		{ "bc", EvalValues::RegBC },
		{ "de", EvalValues::RegDE },
		{ "hl", EvalValues::RegHL },
		{ "sp", EvalValues::RegSP },
		{ "pc", EvalValues::RegPC },
		{ "frame", EvalValues::PpuFrameCount },
		{ "cycle", EvalValues::PpuCycle },
		{ "scanline", EvalValues::PpuScanline },
	};
	return supportedTokens;
}
int64_t ExpressionEvaluator::GetGameboyTokenValue(int64_t token, EvalResultType& resultType)
{
	auto ppu = [this]() -> GbPpuState {
		GbPpuState ppu;
		((GbDebugger*)_cpuDebugger)->GetPpuState(ppu);
		return ppu;
	};
	GbCpuState& s = (GbCpuState&)((GbDebugger*)_cpuDebugger)->GetState();
	switch(token) {
		case EvalValues::RegA: return s.A;
		case EvalValues::RegB: return s.B;
		case EvalValues::RegC: return s.C;
		case EvalValues::RegD: return s.D;
		case EvalValues::RegE: return s.E;
		case EvalValues::RegF: return s.Flags;
		case EvalValues::RegH: return s.H;
		case EvalValues::RegL: return s.L;
		case EvalValues::RegAF: return (s.A << 8) | s.Flags;
		case EvalValues::RegBC: return (s.B << 8) | s.C;
		case EvalValues::RegDE: return (s.D << 8) | s.E;
		case EvalValues::RegHL: return (s.H << 8) | s.L;
		case EvalValues::RegSP: return s.SP;
		case EvalValues::RegPC: return s.PC;
		case EvalValues::PpuFrameCount: return ppu().FrameCount;
		case EvalValues::PpuCycle: return ppu().Cycle;
		case EvalValues::PpuScanline: return ppu().Scanline;
		default: return 0;
	}
}
```

## File: Core/Debugger/ExpressionEvaluator.Gba.cpp
```cpp
#include "pch.h"
#include "Debugger/ExpressionEvaluator.h"
#include "GBA/Debugger/GbaDebugger.h"
#include "GBA/GbaTypes.h"
unordered_map<string, int64_t>& ExpressionEvaluator::GetGbaTokens()
{
	static unordered_map<string, int64_t> supportedTokens = {
		{ "r0", EvalValues::R0 },
		{ "r1", EvalValues::R1 },
		{ "r2", EvalValues::R2 },
		{ "r3", EvalValues::R3 },
		{ "r4", EvalValues::R4 },
		{ "r5", EvalValues::R5 },
		{ "r6", EvalValues::R6 },
		{ "r7", EvalValues::R7 },
		{ "r8", EvalValues::R8 },
		{ "r9", EvalValues::R9 },
		{ "r10", EvalValues::R10 },
		{ "r11", EvalValues::R11 },
		{ "r12", EvalValues::R12 },
		{ "r13", EvalValues::R13 },
		{ "r14", EvalValues::R14 },
		{ "r15", EvalValues::R15 },
		{ "sp", EvalValues::R13 },
		{ "lr", EvalValues::R14 },
		{ "pc", EvalValues::R15 },
		{ "cpsr", EvalValues::CPSR },
		{ "cycle", EvalValues::PpuCycle },
		{ "scanline", EvalValues::PpuScanline },
		{ "frame", EvalValues::PpuFrameCount },
	};
	return supportedTokens;
}
int64_t ExpressionEvaluator::GetGbaTokenValue(int64_t token, EvalResultType& resultType)
{
	auto ppu = [this]() -> GbaPpuState {
		GbaPpuState ppu;
		((GbaDebugger*)_cpuDebugger)->GetPpuState(ppu);
		return ppu;
	};
	GbaCpuState& s = (GbaCpuState&)((GbaDebugger*)_cpuDebugger)->GetState();
	switch(token) {
		case EvalValues::R0: return s.R[0];
		case EvalValues::R1: return s.R[1];
		case EvalValues::R2: return s.R[2];
		case EvalValues::R3: return s.R[3];
		case EvalValues::R4: return s.R[4];
		case EvalValues::R5: return s.R[5];
		case EvalValues::R6: return s.R[6];
		case EvalValues::R7: return s.R[7];
		case EvalValues::R8: return s.R[8];
		case EvalValues::R9: return s.R[9];
		case EvalValues::R10: return s.R[10];
		case EvalValues::R11: return s.R[11];
		case EvalValues::R12: return s.R[12];
		case EvalValues::R13: return s.R[13];
		case EvalValues::R14: return s.R[14];
		case EvalValues::R15: return s.R[15];
		case EvalValues::CPSR: return s.CPSR.ToInt32();
		case EvalValues::PpuFrameCount: return ppu().FrameCount;
		case EvalValues::PpuCycle: return ppu().Cycle;
		case EvalValues::PpuScanline: return ppu().Scanline;
		default: return 0;
	}
}
```

## File: Core/Debugger/ExpressionEvaluator.Gsu.cpp
```cpp
#include "pch.h"
#include "Debugger/ExpressionEvaluator.h"
#include "SNES/Debugger/GsuDebugger.h"
#include "SNES/Coprocessors/GSU/GsuTypes.h"
unordered_map<string, int64_t>& ExpressionEvaluator::GetGsuTokens()
{
	static unordered_map<string, int64_t> supportedTokens = {
		{ "r0", EvalValues::R0 },
		{ "r1", EvalValues::R1 },
		{ "r2", EvalValues::R2 },
		{ "r3", EvalValues::R3 },
		{ "r4", EvalValues::R4 },
		{ "r5", EvalValues::R5 },
		{ "r6", EvalValues::R6 },
		{ "r7", EvalValues::R7 },
		{ "r8", EvalValues::R8 },
		{ "r9", EvalValues::R9 },
		{ "r10", EvalValues::R10 },
		{ "r11", EvalValues::R11 },
		{ "r12", EvalValues::R12 },
		{ "r13", EvalValues::R13 },
		{ "r14", EvalValues::R14 },
		{ "r15", EvalValues::R15 },
		{ "srcreg", EvalValues::SrcReg },
		{ "dstreg", EvalValues::DstReg },
		{ "sfr", EvalValues::SFR },
		{ "pbr", EvalValues::PBR },
		{ "rombr", EvalValues::RomBR },
		{ "rambr", EvalValues::RamBR },
	};
	return supportedTokens;
}
int64_t ExpressionEvaluator::GetGsuTokenValue(int64_t token, EvalResultType& resultType)
{
	GsuState& s = (GsuState&)((GsuDebugger*)_cpuDebugger)->GetState();
	switch(token) {
		case EvalValues::R0: return s.R[0];
		case EvalValues::R1: return s.R[1];
		case EvalValues::R2: return s.R[2];
		case EvalValues::R3: return s.R[3];
		case EvalValues::R4: return s.R[4];
		case EvalValues::R5: return s.R[5];
		case EvalValues::R6: return s.R[6];
		case EvalValues::R7: return s.R[7];
		case EvalValues::R8: return s.R[8];
		case EvalValues::R9: return s.R[9];
		case EvalValues::R10: return s.R[10];
		case EvalValues::R11: return s.R[11];
		case EvalValues::R12: return s.R[12];
		case EvalValues::R13: return s.R[13];
		case EvalValues::R14: return s.R[14];
		case EvalValues::R15: return s.R[15];
		case EvalValues::SrcReg: return s.SrcReg;
		case EvalValues::DstReg: return s.DestReg;
		case EvalValues::SFR: return (s.SFR.GetFlagsHigh() << 8) | s.SFR.GetFlagsLow();
		case EvalValues::PBR: return s.ProgramBank;
		case EvalValues::RomBR: return s.RomBank;
		case EvalValues::RamBR: return s.RamBank;
		default: return 0;
	}
}
```

## File: Core/Debugger/ExpressionEvaluator.h
```
#pragma once
#include "pch.h"
#include <stack>
#include <deque>
#include <unordered_map>
#include <unordered_set>
#include "Debugger/DebugTypes.h"
#include "Utilities/SimpleLock.h"
class Debugger;
class LabelManager;
class IDebugger;
enum EvalOperators : int64_t
{
	Multiplication = 2000000000000,
	Division,
	Modulo,
	Addition,
	Substration,
	ShiftLeft,
	ShiftRight,
	SmallerThan,
	SmallerOrEqual,
	GreaterThan,
	GreaterOrEqual,
	Equal,
	NotEqual,
	BinaryAnd,
	BinaryXor,
	BinaryOr,
	LogicalAnd,
	LogicalOr,
	Plus,
	Minus,
	BinaryNot,
	LogicalNot,
	AbsoluteAddress,
	ReadDword,
	Bracket,
	Braces,
	Parenthesis,
};
enum EvalValues : int64_t
{
	RegA = 3000000000000,
	RegX,
	RegY,
	R0,
	R1,
	R2,
	R3,
	R4,
	R5,
	R6,
	R7,
	R8,
	R9,
	R10,
	R11,
	R12,
	R13,
	R14,
	R15,
	SrcReg,
	DstReg,
	SFR,
	PBR,
	RomBR,
	RamBR,
	RegB,
	RegC,
	RegD,
	RegE,
	RegF,
	RegH,
	RegL,
	RegAF,
	RegBC,
	RegDE,
	RegHL,
	RegIX,
	RegIY,
	RegAltA,
	RegAltB,
	RegAltC,
	RegAltD,
	RegAltE,
	RegAltF,
	RegAltH,
	RegAltL,
	RegAltAF,
	RegAltBC,
	RegAltDE,
	RegAltHL,
	RegI,
	RegR,
	RegTR,
	RegTRB,
	RegRP,
	RegDP,
	RegDR,
	RegSR,
	RegK,
	RegM,
	RegN,
	RegPB,
	RegP,
	RegMult,
	RegMDR,
	RegMAR,
	RegDPR,
	RegSP,
	RegDB,
	RegPS,
	RegPC,
	PpuFrameCount,
	PpuCycle,
	PpuHClock,
	PpuScanline,
	PpuVramAddress,
	PpuTmpVramAddress,
	Nmi,
	Irq,
	Value,
	Address,
	MemoryAddress,
	IsWrite,
	IsRead,
	IsDma,
	IsDummy,
	OpProgramCounter,
	RegPS_Carry,
	RegPS_Zero,
	RegPS_Interrupt,
	RegPS_Memory,
	RegPS_Index,
	RegPS_Decimal,
	RegPS_Overflow,
	RegPS_Negative,
	Sprite0Hit,
	VerticalBlank,
	SpriteOverflow,
	SpriteCollision,
	SpcDspReg,
	PceVramTransferDone,
	PceSatbTransferDone,
	PceScanlineDetected,
	PceIrqVdc2,
	PceSelectedPsgChannel,
	PceSelectedVdcRegister,
	SmsVdpAddressReg,
	SmsVdpCodeReg,
	CPSR,
	RegAX,
	RegBX,
	RegCX,
	RegDX,
	RegAL,
	RegBL,
	RegCL,
	RegDL,
	RegAH,
	RegBH,
	RegCH,
	RegDH,
	RegCS,
	RegDS,
	RegES,
	RegSS,
	RegSI,
	RegDI,
	RegBP,
	RegIP,
	FirstLabelIndex,
};
enum class EvalResultType : int32_t
{
	Numeric = 0,
	Boolean = 1,
	Invalid = 2,
	DivideBy0 = 3,
	OutOfScope = 4
};
class StringHasher
{
public:
	size_t operator()(const std::string& t) const
	{
		return t.size();
	}
};
struct ExpressionData
{
	vector<int64_t> RpnQueue;
	vector<string> Labels;
};
class ExpressionEvaluator
{
private:
	static const vector<string> _binaryOperators;
	static const vector<int> _binaryPrecedence;
	static const vector<string> _unaryOperators;
	static const vector<int> _unaryPrecedence;
	static const unordered_set<string> _operators;
	unordered_map<string, ExpressionData, StringHasher> _cache;
	SimpleLock _cacheLock;
	Debugger* _debugger;
	IDebugger* _cpuDebugger;
	LabelManager* _labelManager;
	CpuType _cpuType;
	MemoryType _cpuMemory;
	bool IsOperator(string token, int &precedence, bool unaryOperator);
	EvalOperators GetOperator(string token, bool unaryOperator);
	unordered_map<string, int64_t>* GetAvailableTokens();
	bool CheckSpecialTokens(string expression, size_t &pos, string &output, ExpressionData &data);
	unordered_map<string, int64_t>& GetSnesTokens();
	int64_t GetSnesTokenValue(int64_t token, EvalResultType& resultType);
	unordered_map<string, int64_t>& GetSpcTokens();
	int64_t GetSpcTokenValue(int64_t token, EvalResultType& resultType);
	unordered_map<string, int64_t>& GetGsuTokens();
	int64_t GetGsuTokenValue(int64_t token, EvalResultType& resultType);
	unordered_map<string, int64_t>& GetCx4Tokens();
	int64_t GetCx4TokenValue(int64_t token, EvalResultType& resultType);
	unordered_map<string, int64_t>& GetNecDspTokens();
	int64_t GetNecDspTokenValue(int64_t token, EvalResultType& resultType);
	unordered_map<string, int64_t>& GetSt018Tokens();
	int64_t GetSt018TokenValue(int64_t token, EvalResultType& resultType);
	unordered_map<string, int64_t>& GetGameboyTokens();
	int64_t GetGameboyTokenValue(int64_t token, EvalResultType& resultType);
	unordered_map<string, int64_t>& GetNesTokens();
	int64_t GetNesTokenValue(int64_t token, EvalResultType& resultType);
	unordered_map<string, int64_t>& GetPceTokens();
	int64_t GetPceTokenValue(int64_t token, EvalResultType& resultType);
	unordered_map<string, int64_t>& GetSmsTokens();
	int64_t GetSmsTokenValue(int64_t token, EvalResultType& resultType);
	unordered_map<string, int64_t>& GetGbaTokens();
	int64_t GetGbaTokenValue(int64_t token, EvalResultType& resultType);
	unordered_map<string, int64_t>& GetWsTokens();
	int64_t GetWsTokenValue(int64_t token, EvalResultType& resultType);
	bool ReturnBool(int64_t value, EvalResultType& resultType);
	int64_t ProcessSharedTokens(string token);
	string GetNextToken(string expression, size_t &pos, ExpressionData &data, bool &success, bool previousTokenIsOp);
	bool ProcessSpecialOperator(EvalOperators evalOp, std::stack<EvalOperators> &opStack, std::stack<int> &precedenceStack, vector<int64_t> &outputQueue);
	bool ToRpn(string expression, ExpressionData &data);
	int64_t PrivateEvaluate(string expression, EvalResultType &resultType, MemoryOperationInfo &operationInfo, AddressInfo& addressInfo, bool &success);
	ExpressionData* PrivateGetRpnList(string expression, bool& success);
protected:
public:
	ExpressionEvaluator(Debugger* debugger, IDebugger* cpuDebugger, CpuType cpuType);
	int64_t Evaluate(ExpressionData &data, EvalResultType &resultType, MemoryOperationInfo &operationInfo, AddressInfo& addressInfo);
	int64_t Evaluate(string expression, EvalResultType &resultType, MemoryOperationInfo &operationInfo, AddressInfo& addressInfo);
	ExpressionData GetRpnList(string expression, bool &success);
	void GetTokenList(char* tokenList);
	bool Validate(string expression);
#if _DEBUG
	void RunTests();
#endif
};
```

## File: Core/Debugger/ExpressionEvaluator.NecDsp.cpp
```cpp
#include "pch.h"
#include "Debugger/ExpressionEvaluator.h"
#include "SNES/Coprocessors/DSP/NecDspTypes.h"
#include "SNES/Debugger/NecDspDebugger.h"
unordered_map<string, int64_t>& ExpressionEvaluator::GetNecDspTokens()
{
	static unordered_map<string, int64_t> supportedTokens = {
		{ "a", EvalValues::RegA },
		{ "b", EvalValues::RegB },
		{ "tr", EvalValues::RegTR },
		{ "trb", EvalValues::RegTRB },
		{ "rp", EvalValues::RegRP },
		{ "dp", EvalValues::RegDP },
		{ "dr", EvalValues::RegDR },
		{ "sr", EvalValues::RegSR },
		{ "k", EvalValues::RegK },
		{ "l", EvalValues::RegL },
		{ "m", EvalValues::RegM },
		{ "n", EvalValues::RegN },
		{ "sp", EvalValues::RegSP },
		{ "pc", EvalValues::RegPC },
	};
	return supportedTokens;
}
int64_t ExpressionEvaluator::GetNecDspTokenValue(int64_t token, EvalResultType& resultType)
{
	NecDspState& s = (NecDspState&)((NecDspDebugger*)_cpuDebugger)->GetState();
	switch(token) {
		case EvalValues::RegA: return s.A;
		case EvalValues::RegB: return s.B;
		case EvalValues::RegTR: return s.TR;
		case EvalValues::RegTRB: return s.TRB;
		case EvalValues::RegRP: return s.RP;
		case EvalValues::RegDP: return s.DP;
		case EvalValues::RegDR: return s.DR;
		case EvalValues::RegSR: return s.SR;
		case EvalValues::RegK: return s.K;
		case EvalValues::RegL: return s.L;
		case EvalValues::RegM: return s.M;
		case EvalValues::RegN: return s.N;
		case EvalValues::RegSP: return s.SP;
		case EvalValues::RegPC: return s.PC;
		default: return 0;
	}
}
```

## File: Core/Debugger/ExpressionEvaluator.Nes.cpp
```cpp
#include "pch.h"
#include "Debugger/ExpressionEvaluator.h"
#include "NES/NesTypes.h"
#include "NES/Debugger/NesDebugger.h"
unordered_map<string, int64_t>& ExpressionEvaluator::GetNesTokens()
{
	static unordered_map<string, int64_t> supportedTokens = {
		{ "a", EvalValues::RegA },
		{ "x", EvalValues::RegX },
		{ "y", EvalValues::RegY },
		{ "ps", EvalValues::RegPS },
		{ "sp", EvalValues::RegSP },
		{ "pc", EvalValues::RegPC },
		{ "irq", EvalValues::Irq },
		{ "nmi", EvalValues::Nmi },
		{ "frame", EvalValues::PpuFrameCount },
		{ "cycle", EvalValues::PpuCycle },
		{ "scanline", EvalValues::PpuScanline },
		{ "v", EvalValues::PpuVramAddress },
		{ "t", EvalValues::PpuTmpVramAddress },
		{ "sprite0hit", EvalValues::Sprite0Hit },
		{ "verticalblank", EvalValues::VerticalBlank },
		{ "spriteoverflow", EvalValues::SpriteOverflow },
		{ "pscarry", EvalValues::RegPS_Carry },
		{ "pszero", EvalValues::RegPS_Zero },
		{ "psinterrupt", EvalValues::RegPS_Interrupt },
		{ "psdecimal", EvalValues::RegPS_Decimal },
		{ "psoverflow", EvalValues::RegPS_Overflow },
		{ "psnegative", EvalValues::RegPS_Negative },
	};
	return supportedTokens;
}
int64_t ExpressionEvaluator::GetNesTokenValue(int64_t token, EvalResultType& resultType)
{
	auto ppu = [this]() -> NesPpuState {
		NesPpuState ppu;
		((NesDebugger*)_cpuDebugger)->GetPpuState(ppu);
		return ppu;
	};
	NesCpuState& s = (NesCpuState&)((NesDebugger*)_cpuDebugger)->GetState();
	switch(token) {
		case EvalValues::RegA: return s.A;
		case EvalValues::RegX: return s.X;
		case EvalValues::RegY: return s.Y;
		case EvalValues::RegSP: return s.SP;
		case EvalValues::RegPS: return s.PS;
		case EvalValues::RegPC: return s.PC;
		case EvalValues::Nmi: return ReturnBool(s.NmiFlag, resultType);
		case EvalValues::Irq:  return ReturnBool(s.IrqFlag, resultType);
		case EvalValues::PpuFrameCount: return ppu().FrameCount;
		case EvalValues::PpuCycle: return ppu().Cycle;
		case EvalValues::PpuScanline: return ppu().Scanline;
		case EvalValues::PpuVramAddress: return ppu().VideoRamAddr;
		case EvalValues::PpuTmpVramAddress: return ppu().TmpVideoRamAddr;
		case EvalValues::Sprite0Hit: return ReturnBool(ppu().StatusFlags.Sprite0Hit, resultType);
		case EvalValues::SpriteOverflow: return ReturnBool(ppu().StatusFlags.SpriteOverflow, resultType);
		case EvalValues::VerticalBlank: return ReturnBool(ppu().StatusFlags.VerticalBlank, resultType);
		case EvalValues::RegPS_Carry: return ReturnBool(s.PS & PSFlags::Carry, resultType);
		case EvalValues::RegPS_Zero: return ReturnBool(s.PS & PSFlags::Zero, resultType);
		case EvalValues::RegPS_Interrupt: return ReturnBool(s.PS & PSFlags::Interrupt, resultType);
		case EvalValues::RegPS_Decimal: return ReturnBool(s.PS & PSFlags::Decimal, resultType);
		case EvalValues::RegPS_Overflow: return ReturnBool(s.PS & PSFlags::Overflow, resultType);
		case EvalValues::RegPS_Negative: return ReturnBool(s.PS & PSFlags::Negative, resultType);
		default: return 0;
	}
}
```

## File: Core/Debugger/ExpressionEvaluator.Pce.cpp
```cpp
#include "pch.h"
#include "Debugger/ExpressionEvaluator.h"
#include "PCE/PceTypes.h"
#include "PCE/PceConsole.h"
#include "PCE/PcePsg.h"
#include "PCE/Debugger/PceDebugger.h"
unordered_map<string, int64_t>& ExpressionEvaluator::GetPceTokens()
{
	static unordered_map<string, int64_t> supportedTokens = {
		{ "a", EvalValues::RegA },
		{ "x", EvalValues::RegX },
		{ "y", EvalValues::RegY },
		{ "ps", EvalValues::RegPS },
		{ "sp", EvalValues::RegSP },
		{ "pc", EvalValues::RegPC },
		{ "irq", EvalValues::Irq },
		{ "frame", EvalValues::PpuFrameCount },
		{ "cycle", EvalValues::PpuCycle },
		{ "scanline", EvalValues::PpuScanline },
		{ "sprite0hit", EvalValues::Sprite0Hit },
		{ "verticalblank", EvalValues::VerticalBlank },
		{ "spriteoverflow", EvalValues::SpriteOverflow },
		{ "pscarry", EvalValues::RegPS_Carry },
		{ "pszero", EvalValues::RegPS_Zero },
		{ "psinterrupt", EvalValues::RegPS_Interrupt },
		{ "psdecimal", EvalValues::RegPS_Decimal },
		{ "psmemory", EvalValues::RegPS_Memory },
		{ "psoverflow", EvalValues::RegPS_Overflow },
		{ "psnegative", EvalValues::RegPS_Negative },
		{ "vramtransferdone", EvalValues::PceVramTransferDone },
		{ "satbtransferdone", EvalValues::PceSatbTransferDone },
		{ "scanlinedetected", EvalValues::PceScanlineDetected },
		{ "irqvdc2", EvalValues::PceIrqVdc2 },
		{ "psgchannel", EvalValues::PceSelectedPsgChannel },
		{ "vdcreg", EvalValues::PceSelectedVdcRegister }
	};
	return supportedTokens;
}
int64_t ExpressionEvaluator::GetPceTokenValue(int64_t token, EvalResultType& resultType)
{
	auto ppu = [this]() -> PceVideoState {
		PceVideoState ppu;
		((PceDebugger*)_cpuDebugger)->GetPpuState(ppu);
		return ppu;
	};
	auto psg = [this]() -> PcePsgState& {
		return ((PceDebugger*)_cpuDebugger)->GetConsole()->GetPsg()->GetState();
	};
	PceCpuState& s = (PceCpuState&)((PceDebugger*)_cpuDebugger)->GetState();
	switch(token) {
		case EvalValues::RegA: return s.A;
		case EvalValues::RegX: return s.X;
		case EvalValues::RegY: return s.Y;
		case EvalValues::RegSP: return s.SP;
		case EvalValues::RegPS: return s.PS;
		case EvalValues::RegPC: return s.PC;
		case EvalValues::Irq: return ReturnBool(ppu().Vpc.HasIrqVdc1, resultType);
		case EvalValues::PceIrqVdc2: return ReturnBool(ppu().Vpc.HasIrqVdc2, resultType);
		case EvalValues::PpuFrameCount: return ppu().Vdc.FrameCount;
		case EvalValues::PpuCycle: return ppu().Vdc.HClock;
		case EvalValues::PpuScanline: return ppu().Vdc.Scanline;
		case EvalValues::Sprite0Hit: return ReturnBool(ppu().Vdc.Sprite0Hit, resultType);
		case EvalValues::SpriteOverflow: return ReturnBool(ppu().Vdc.SpriteOverflow, resultType);
		case EvalValues::VerticalBlank: return ReturnBool(ppu().Vdc.VerticalBlank, resultType);
		case EvalValues::PceVramTransferDone: return ReturnBool(ppu().Vdc.VramTransferDone, resultType);
		case EvalValues::PceSatbTransferDone: return ReturnBool(ppu().Vdc.SatbTransferDone, resultType);
		case EvalValues::PceScanlineDetected: return ReturnBool(ppu().Vdc.ScanlineDetected, resultType);
		case EvalValues::PceSelectedPsgChannel: return psg().ChannelSelect;
		case EvalValues::PceSelectedVdcRegister: return ppu().Vdc.CurrentReg;
		case EvalValues::RegPS_Carry: return ReturnBool(s.PS & PceCpuFlags::Carry, resultType);
		case EvalValues::RegPS_Zero: return ReturnBool(s.PS & PceCpuFlags::Zero, resultType);
		case EvalValues::RegPS_Interrupt: return ReturnBool(s.PS & PceCpuFlags::Interrupt, resultType);
		case EvalValues::RegPS_Decimal: return ReturnBool(s.PS & PceCpuFlags::Decimal, resultType);
		case EvalValues::RegPS_Memory: return ReturnBool(s.PS & PceCpuFlags::Memory, resultType);
		case EvalValues::RegPS_Overflow: return ReturnBool(s.PS & PceCpuFlags::Overflow, resultType);
		case EvalValues::RegPS_Negative: return ReturnBool(s.PS & PceCpuFlags::Negative, resultType);
		default: return 0;
	}
}
```

## File: Core/Debugger/ExpressionEvaluator.Sms.cpp
```cpp
#include "pch.h"
#include "Debugger/ExpressionEvaluator.h"
#include "SMS/Debugger/SmsDebugger.h"
#include "SMS/SmsTypes.h"
unordered_map<string, int64_t>& ExpressionEvaluator::GetSmsTokens()
{
	static unordered_map<string, int64_t> supportedTokens = {
		{ "a", EvalValues::RegA },
		{ "b", EvalValues::RegB },
		{ "c", EvalValues::RegC },
		{ "d", EvalValues::RegD },
		{ "e", EvalValues::RegE },
		{ "f", EvalValues::RegF },
		{ "h", EvalValues::RegH },
		{ "l", EvalValues::RegL },
		{ "af", EvalValues::RegAF },
		{ "bc", EvalValues::RegBC },
		{ "de", EvalValues::RegDE },
		{ "hl", EvalValues::RegHL },
		{ "a'", EvalValues::RegAltA },
		{ "b'", EvalValues::RegAltB },
		{ "c'", EvalValues::RegAltC },
		{ "d'", EvalValues::RegAltD },
		{ "e'", EvalValues::RegAltE },
		{ "f'", EvalValues::RegAltF },
		{ "h'", EvalValues::RegAltH },
		{ "l'", EvalValues::RegAltL },
		{ "af'", EvalValues::RegAltAF },
		{ "bc'", EvalValues::RegAltBC },
		{ "de'", EvalValues::RegAltDE },
		{ "hl'", EvalValues::RegAltHL },
		{ "i", EvalValues::RegI },
		{ "r", EvalValues::RegR },
		{ "ix", EvalValues::RegIX },
		{ "iy", EvalValues::RegIY },
		{ "sp", EvalValues::RegSP },
		{ "pc", EvalValues::RegPC },
		{ "addressreg", EvalValues::SmsVdpAddressReg },
		{ "codereg", EvalValues::SmsVdpCodeReg },
		{ "spritecollision", EvalValues::SpriteCollision },
		{ "spriteoverflow", EvalValues::SpriteOverflow },
		{ "frame", EvalValues::PpuFrameCount },
		{ "cycle", EvalValues::PpuCycle },
		{ "scanline", EvalValues::PpuScanline },
	};
	return supportedTokens;
}
int64_t ExpressionEvaluator::GetSmsTokenValue(int64_t token, EvalResultType& resultType)
{
	auto ppu = [this]() -> SmsVdpState {
		SmsVdpState ppu;
		((SmsDebugger*)_cpuDebugger)->GetPpuState(ppu);
		return ppu;
	};
	SmsCpuState& s = (SmsCpuState&)((SmsDebugger*)_cpuDebugger)->GetState();
	switch(token) {
		case EvalValues::RegA: return s.A;
		case EvalValues::RegB: return s.B;
		case EvalValues::RegC: return s.C;
		case EvalValues::RegD: return s.D;
		case EvalValues::RegE: return s.E;
		case EvalValues::RegF: return s.Flags;
		case EvalValues::RegH: return s.H;
		case EvalValues::RegL: return s.L;
		case EvalValues::RegAF: return (s.A << 8) | s.Flags;
		case EvalValues::RegBC: return (s.B << 8) | s.C;
		case EvalValues::RegDE: return (s.D << 8) | s.E;
		case EvalValues::RegHL: return (s.H << 8) | s.L;
		case EvalValues::RegAltA: return s.AltA;
		case EvalValues::RegAltB: return s.AltB;
		case EvalValues::RegAltC: return s.AltC;
		case EvalValues::RegAltD: return s.AltD;
		case EvalValues::RegAltE: return s.AltE;
		case EvalValues::RegAltF: return s.AltFlags;
		case EvalValues::RegAltH: return s.AltH;
		case EvalValues::RegAltL: return s.AltL;
		case EvalValues::RegAltAF: return (s.AltA << 8) | s.AltFlags;
		case EvalValues::RegAltBC: return (s.AltB << 8) | s.AltC;
		case EvalValues::RegAltDE: return (s.AltD << 8) | s.AltE;
		case EvalValues::RegAltHL: return (s.AltH << 8) | s.AltL;
		case EvalValues::RegIX: return (s.IXH << 8) | s.IXL;
		case EvalValues::RegIY: return (s.IYH << 8) | s.IYL;
		case EvalValues::RegI: return s.I;
		case EvalValues::RegR: return s.R;
		case EvalValues::RegSP: return s.SP;
		case EvalValues::RegPC: return s.PC;
		case EvalValues::SmsVdpAddressReg: return ppu().AddressReg;
		case EvalValues::SmsVdpCodeReg: return ppu().CodeReg;
		case EvalValues::SpriteCollision: return ReturnBool(ppu().SpriteCollision, resultType);
		case EvalValues::SpriteOverflow: return ReturnBool(ppu().SpriteOverflow, resultType);
		case EvalValues::PpuFrameCount: return ppu().FrameCount;
		case EvalValues::PpuCycle: return ppu().Cycle;
		case EvalValues::PpuScanline: return ppu().Scanline;
		default: return 0;
	}
}
```

## File: Core/Debugger/ExpressionEvaluator.Snes.cpp
```cpp
#include "pch.h"
#include "Debugger/ExpressionEvaluator.h"
#include "SNES/SnesCpuTypes.h"
#include "SNES/SnesPpuTypes.h"
#include "SNES/Debugger/SnesDebugger.h"
unordered_map<string, int64_t>& ExpressionEvaluator::GetSnesTokens()
{
	static unordered_map<string, int64_t> supportedTokens = {
		{ "a", EvalValues::RegA },
		{ "x", EvalValues::RegX },
		{ "y", EvalValues::RegY },
		{ "ps", EvalValues::RegPS },
		{ "sp", EvalValues::RegSP },
		{ "pc", EvalValues::RegPC },
		{ "db", EvalValues::RegDB },
		{ "d", EvalValues::RegD },
		{ "irq", EvalValues::Irq },
		{ "nmi", EvalValues::Nmi },
		{ "frame", EvalValues::PpuFrameCount },
		{ "hclock", EvalValues::PpuHClock },
		{ "cycle", EvalValues::PpuCycle },
		{ "scanline", EvalValues::PpuScanline },
		{ "pscarry", EvalValues::RegPS_Carry },
		{ "pszero", EvalValues::RegPS_Zero },
		{ "psinterrupt", EvalValues::RegPS_Interrupt },
		{ "psindex", EvalValues::RegPS_Index },
		{ "psmemory", EvalValues::RegPS_Memory },
		{ "psdecimal", EvalValues::RegPS_Decimal },
		{ "psoverflow", EvalValues::RegPS_Overflow },
		{ "psnegative", EvalValues::RegPS_Negative },
	};
	return supportedTokens;
}
int64_t ExpressionEvaluator::GetSnesTokenValue(int64_t token, EvalResultType& resultType)
{
	auto getPpuState = [this]() -> SnesPpuState {
		SnesPpuState ppu;
		((SnesDebugger*)_cpuDebugger)->GetPpuState(ppu);
		return ppu;
	};
	SnesCpuState& s = (SnesCpuState&)((SnesDebugger*)_cpuDebugger)->GetState();
	switch(token) {
		case EvalValues::RegA: return s.A;
		case EvalValues::RegX: return s.X;
		case EvalValues::RegY: return s.Y;
		case EvalValues::RegSP: return s.SP;
		case EvalValues::RegPS: return s.PS;
		case EvalValues::RegDB: return s.DBR;
		case EvalValues::RegD: return s.D;
		case EvalValues::RegPC: return (s.K << 16) | s.PC;
		case EvalValues::Nmi: return ReturnBool(s.NmiFlagCounter > 0 || s.NeedNmi, resultType);
		case EvalValues::Irq: return ReturnBool(s.IrqSource, resultType);
		case EvalValues::PpuFrameCount: return getPpuState().FrameCount;
		case EvalValues::PpuCycle: return getPpuState().Cycle;
		case EvalValues::PpuHClock: return getPpuState().HClock;
		case EvalValues::PpuScanline: return getPpuState().Scanline;
		case EvalValues::RegPS_Carry: return ReturnBool(s.PS & ProcFlags::Carry, resultType);
		case EvalValues::RegPS_Zero: return ReturnBool(s.PS & ProcFlags::Zero, resultType);
		case EvalValues::RegPS_Interrupt: return ReturnBool(s.PS & ProcFlags::IrqDisable, resultType);
		case EvalValues::RegPS_Memory: return ReturnBool(s.PS & ProcFlags::MemoryMode8, resultType);
		case EvalValues::RegPS_Index: return ReturnBool(s.PS & ProcFlags::IndexMode8, resultType);
		case EvalValues::RegPS_Decimal: return ReturnBool(s.PS & ProcFlags::Decimal, resultType);
		case EvalValues::RegPS_Overflow: return ReturnBool(s.PS & ProcFlags::Overflow, resultType);
		case EvalValues::RegPS_Negative: return ReturnBool(s.PS & ProcFlags::Negative, resultType);
		default: return 0;
	}
}
```

## File: Core/Debugger/ExpressionEvaluator.Spc.cpp
```cpp
#include "pch.h"
#include "Debugger/ExpressionEvaluator.h"
#include "SNES/SpcTypes.h"
#include "SNES/Debugger/SpcDebugger.h"
unordered_map<string, int64_t>& ExpressionEvaluator::GetSpcTokens()
{
	static unordered_map<string, int64_t> supportedTokens = {
		{ "a", EvalValues::RegA },
		{ "x", EvalValues::RegX },
		{ "y", EvalValues::RegY },
		{ "ps", EvalValues::RegPS },
		{ "sp", EvalValues::RegSP },
		{ "pc", EvalValues::RegPC },
		{ "dspreg", EvalValues::SpcDspReg },
	};
	return supportedTokens;
}
int64_t ExpressionEvaluator::GetSpcTokenValue(int64_t token, EvalResultType& resultType)
{
	SpcState& s = (SpcState&)((SpcDebugger*)_cpuDebugger)->GetState();
	switch(token) {
		case EvalValues::RegA: return s.A;
		case EvalValues::RegX: return s.X;
		case EvalValues::RegY: return s.Y;
		case EvalValues::RegSP: return s.SP;
		case EvalValues::RegPS: return s.PS;
		case EvalValues::RegPC: return s.PC;
		case EvalValues::SpcDspReg: return s.DspReg;
		default: return 0;
	}
}
```

## File: Core/Debugger/ExpressionEvaluator.St018.cpp
```cpp
#include "pch.h"
#include "Debugger/ExpressionEvaluator.h"
#include "SNES/Debugger/St018Debugger.h"
#include "SNES/Coprocessors/ST018/ArmV3Types.h"
unordered_map<string, int64_t>& ExpressionEvaluator::GetSt018Tokens()
{
	static unordered_map<string, int64_t> supportedTokens = {
		{ "r0", EvalValues::R0 },
		{ "r1", EvalValues::R1 },
		{ "r2", EvalValues::R2 },
		{ "r3", EvalValues::R3 },
		{ "r4", EvalValues::R4 },
		{ "r5", EvalValues::R5 },
		{ "r6", EvalValues::R6 },
		{ "r7", EvalValues::R7 },
		{ "r8", EvalValues::R8 },
		{ "r9", EvalValues::R9 },
		{ "r10", EvalValues::R10 },
		{ "r11", EvalValues::R11 },
		{ "r12", EvalValues::R12 },
		{ "r13", EvalValues::R13 },
		{ "r14", EvalValues::R14 },
		{ "r15", EvalValues::R15 },
		{ "sp", EvalValues::R13 },
		{ "lr", EvalValues::R14 },
		{ "pc", EvalValues::R15 },
		{ "cpsr", EvalValues::CPSR }
	};
	return supportedTokens;
}
int64_t ExpressionEvaluator::GetSt018TokenValue(int64_t token, EvalResultType& resultType)
{
	ArmV3CpuState& s = (ArmV3CpuState&)((St018Debugger*)_cpuDebugger)->GetState();
	switch(token) {
		case EvalValues::R0: return s.R[0];
		case EvalValues::R1: return s.R[1];
		case EvalValues::R2: return s.R[2];
		case EvalValues::R3: return s.R[3];
		case EvalValues::R4: return s.R[4];
		case EvalValues::R5: return s.R[5];
		case EvalValues::R6: return s.R[6];
		case EvalValues::R7: return s.R[7];
		case EvalValues::R8: return s.R[8];
		case EvalValues::R9: return s.R[9];
		case EvalValues::R10: return s.R[10];
		case EvalValues::R11: return s.R[11];
		case EvalValues::R12: return s.R[12];
		case EvalValues::R13: return s.R[13];
		case EvalValues::R14: return s.R[14];
		case EvalValues::R15: return s.R[15];
		case EvalValues::CPSR: return s.CPSR.ToInt32();
		default: return 0;
	}
}
```

## File: Core/Debugger/ExpressionEvaluator.Ws.cpp
```cpp
#include "pch.h"
#include "Debugger/ExpressionEvaluator.h"
#include "WS/Debugger/WsDebugger.h"
#include "WS/WsTypes.h"
unordered_map<string, int64_t>& ExpressionEvaluator::GetWsTokens()
{
	static unordered_map<string, int64_t> supportedTokens = {
		{ "ax", EvalValues::RegAX },
		{ "bx", EvalValues::RegBX },
		{ "cx", EvalValues::RegCX },
		{ "dx", EvalValues::RegDX },
		{ "al", EvalValues::RegAL },
		{ "bl", EvalValues::RegBL },
		{ "cl", EvalValues::RegCL },
		{ "dl", EvalValues::RegDL },
		{ "ah", EvalValues::RegAH },
		{ "bh", EvalValues::RegBH },
		{ "ch", EvalValues::RegCH },
		{ "dh", EvalValues::RegDH },
		{ "cs", EvalValues::RegCS },
		{ "ds", EvalValues::RegDS },
		{ "es", EvalValues::RegES },
		{ "ss", EvalValues::RegSS },
		{ "si", EvalValues::RegSI },
		{ "di", EvalValues::RegDI },
		{ "bp", EvalValues::RegBP },
		{ "ip", EvalValues::RegIP },
		{ "f", EvalValues::RegF },
		{ "sp", EvalValues::RegSP },
		{ "pc", EvalValues::RegPC },
		{ "frame", EvalValues::PpuFrameCount },
		{ "cycle", EvalValues::PpuCycle },
		{ "scanline", EvalValues::PpuScanline },
	};
	return supportedTokens;
}
int64_t ExpressionEvaluator::GetWsTokenValue(int64_t token, EvalResultType& resultType)
{
	auto ppu = [this]() -> WsPpuState {
		WsPpuState ppu;
		((WsDebugger*)_cpuDebugger)->GetPpuState(ppu);
		return ppu;
	};
	WsCpuState& s = (WsCpuState&)((WsDebugger*)_cpuDebugger)->GetState();
	switch(token) {
		case EvalValues::RegAX: return s.AX;
		case EvalValues::RegBX: return s.BX;
		case EvalValues::RegCX: return s.CX;
		case EvalValues::RegDX: return s.DX;
		case EvalValues::RegAL: return s.AX & 0xFF;
		case EvalValues::RegBL: return s.BX & 0xFF;
		case EvalValues::RegCL: return s.CX & 0xFF;
		case EvalValues::RegDL: return s.DX & 0xFF;
		case EvalValues::RegAH: return s.AX >> 8;
		case EvalValues::RegBH: return s.BX >> 8;
		case EvalValues::RegCH: return s.CX >> 8;
		case EvalValues::RegDH: return s.DX >> 8;
		case EvalValues::RegCS: return s.CS;
		case EvalValues::RegDS: return s.DS;
		case EvalValues::RegES: return s.ES;
		case EvalValues::RegSS: return s.SS;
		case EvalValues::RegSI: return s.SI;
		case EvalValues::RegDI: return s.DI;
		case EvalValues::RegBP: return s.BP;
		case EvalValues::RegIP: return s.IP;
		case EvalValues::RegF: return s.Flags.Get();
		case EvalValues::RegSP: return s.SP;
		case EvalValues::RegPC: return (s.CS << 4) + s.IP;
		case EvalValues::PpuFrameCount: return ppu().FrameCount;
		case EvalValues::PpuCycle: return ppu().Cycle;
		case EvalValues::PpuScanline: return ppu().Scanline;
		default: return 0;
	}
}
```

## File: Core/Debugger/FrozenAddressManager.h
```
#pragma once
#include "pch.h"
class FrozenAddressManager
{
protected:
	unordered_set<uint32_t> _frozenAddresses;
public:
	void UpdateFrozenAddresses(uint32_t start, uint32_t end, bool freeze)
	{
		if(freeze) {
			for(uint32_t i = start; i <= end; i++) {
				_frozenAddresses.emplace(i);
			}
		} else {
			for(uint32_t i = start; i <= end; i++) {
				_frozenAddresses.erase(i);
			}
		}
	}
	bool IsFrozenAddress(uint32_t addr)
	{
		return _frozenAddresses.size() > 0 && _frozenAddresses.find(addr) != _frozenAddresses.end();
	}
	void GetFrozenState(uint32_t start, uint32_t end, bool* outState)
	{
		for(uint32_t i = start; i <= end; i++) {
			outState[i - start] = _frozenAddresses.find(i) != _frozenAddresses.end();
		}
	}
};
```

## File: Core/Debugger/IAssembler.h
```
#pragma once
#include "pch.h"
class IAssembler
{
public:
	virtual ~IAssembler() {}
	virtual uint32_t AssembleCode(string code, uint32_t startAddress, int16_t* assembledCode) = 0;
};
enum AssemblerSpecialCodes
{
	OK = 0,
	EndOfLine = -1,
	ParsingError = -2,
	OutOfRangeJump = -3,
	LabelRedefinition = -4,
	MissingOperand = -5,
	OperandOutOfRange = -6,
	InvalidHex = -7,
	InvalidSpaces = -8,
	TrailingText = -9,
	UnknownLabel = -10,
	InvalidInstruction = -11,
	InvalidBinaryValue = -12,
	InvalidOperands = -13,
	InvalidLabel = -14,
};
```

## File: Core/Debugger/ITraceLogger.h
```
#pragma once
#include "pch.h"
#include "Debugger/DebugTypes.h"
struct TraceRow
{
	uint32_t ProgramCounter;
	CpuType Type;
	uint8_t ByteCode[8];
	uint8_t ByteCodeSize;
	uint32_t LogSize;
	char LogOutput[500];
};
struct TraceLoggerOptions
{
	bool Enabled;
	bool IndentCode;
	bool UseLabels;
	char Condition[1000];
	char Format[1000];
};
class ITraceLogger
{
protected:
	bool _enabled = false;
public:
	static uint64_t NextRowId;
	virtual int64_t GetRowId(uint32_t offset) = 0;
	virtual void GetExecutionTrace(TraceRow& row, uint32_t offset) = 0;
	virtual void Clear() = 0;
	virtual void SetOptions(TraceLoggerOptions options) = 0;
	__forceinline bool IsEnabled() { return _enabled; }
};
```

## File: Core/Debugger/LabelManager.cpp
```cpp
#include "pch.h"
#include "Debugger/LabelManager.h"
#include "Debugger/Debugger.h"
#include "Debugger/DebugUtilities.h"
#include "Debugger/DebugBreakHelper.h"
LabelManager::LabelManager(Debugger *debugger)
{
	_debugger = debugger;
}
void LabelManager::ClearLabels()
{
	DebugBreakHelper helper(_debugger);
	_codeLabels.clear();
	_codeLabelReverseLookup.clear();
}
void LabelManager::SetLabel(uint32_t address, MemoryType memType, string label, string comment)
{
	DebugBreakHelper helper(_debugger);
	uint64_t key = GetLabelKey(address, memType);
	auto existingLabel = _codeLabels.find(key);
	if(existingLabel != _codeLabels.end()) {
		_codeLabelReverseLookup.erase(existingLabel->second.Label);
	}
	_codeLabels.erase(key);
	if(!label.empty() || !comment.empty()) {
		if(label.size() > 400) {
			label = label.substr(0, 400);
		}
		LabelInfo labelInfo;
		labelInfo.Label = label;
		labelInfo.Comment = comment;
		_codeLabels.emplace(key, labelInfo);
		_codeLabelReverseLookup.emplace(label, key);
	}
}
int64_t LabelManager::GetLabelKey(uint32_t absoluteAddr, MemoryType memType)
{
	return absoluteAddr | ((uint64_t)memType << 32);
}
MemoryType LabelManager::GetKeyMemoryType(uint64_t key)
{
	return (MemoryType)(key >> 32);
}
string LabelManager::GetLabel(AddressInfo address, bool checkRegisterLabels)
{
	string label;
	if(DebugUtilities::IsRelativeMemory(address.Type)) {
		if(checkRegisterLabels && InternalGetLabel(address, label)) {
			return label;
		}
		address = _debugger->GetAbsoluteAddress(address);
	}
	if(address.Address >= 0) {
		InternalGetLabel(address, label);
	}
	return label;
}
bool LabelManager::InternalGetLabel(AddressInfo address, string &label)
{
	int64_t key = GetLabelKey(address.Address, address.Type);
	if(key >= 0) {
		auto result = _codeLabels.find(key);
		if(result != _codeLabels.end()) {
			label = result->second.Label;
			return true;
		}
	}
	return false;
}
string LabelManager::GetComment(AddressInfo absAddress)
{
	uint64_t key = GetLabelKey(absAddress.Address, absAddress.Type);
	if(key >= 0) {
		auto result = _codeLabels.find(key);
		if(result != _codeLabels.end()) {
			return result->second.Comment;
		}
	}
	return "";
}
bool LabelManager::GetLabelAndComment(AddressInfo address, LabelInfo &labelInfo)
{
	if(DebugUtilities::IsRelativeMemory(address.Type)) {
		address = _debugger->GetAbsoluteAddress(address);
	}
	if(address.Address >= 0) {
		int64_t key = GetLabelKey(address.Address, address.Type);
		if(key >= 0) {
			auto result = _codeLabels.find(key);
			if(result != _codeLabels.end()) {
				labelInfo = result->second;
				return true;
			}
		}
	}
	return false;
}
bool LabelManager::ContainsLabel(string &label)
{
	return _codeLabelReverseLookup.find(label) != _codeLabelReverseLookup.end();
}
AddressInfo LabelManager::GetLabelAbsoluteAddress(string& label)
{
	AddressInfo addr = { -1, MemoryType::None };
	auto result = _codeLabelReverseLookup.find(label);
	if(result != _codeLabelReverseLookup.end()) {
		uint64_t key = result->second;
		addr.Type = GetKeyMemoryType(key);
		addr.Address = (int32_t)(key & 0xFFFFFFFF);
	}
	return addr;
}
int32_t LabelManager::GetLabelRelativeAddress(string &label, CpuType cpuType)
{
	auto result = _codeLabelReverseLookup.find(label);
	if(result == _codeLabelReverseLookup.end()) {
		//Label doesn't exist, try to find a matching multi-byte label
		result = _codeLabelReverseLookup.find(label + "+0");
	}
	if(result != _codeLabelReverseLookup.end()) {
		uint64_t key = result->second;
		MemoryType type = GetKeyMemoryType(key);
		AddressInfo addr { (int32_t)(key & 0xFFFFFFFF), type };
		if(DebugUtilities::IsRelativeMemory(type)) {
			return addr.Address;
		}
		return _debugger->GetRelativeAddress(addr, cpuType).Address;
	}
	return -2;
}
bool LabelManager::HasLabelOrComment(AddressInfo address)
{
	if(DebugUtilities::IsRelativeMemory(address.Type)) {
		address = _debugger->GetAbsoluteAddress(address);
	}
	if(address.Address >= 0) {
		uint64_t key = GetLabelKey(address.Address, address.Type);
		if(key >= 0) {
			return _codeLabels.find(key) != _codeLabels.end();
		}
	}
	return false;
}
```

## File: Core/Debugger/LabelManager.h
```
#pragma once
#include "pch.h"
#include <unordered_map>
#include <functional>
#include "Debugger/DebugTypes.h"
class Debugger;
class AddressHasher
{
public:
	size_t operator()(const uint64_t& addr) const
	{
		return addr;
	}
};
struct LabelInfo
{
	string Label;
	string Comment;
};
class LabelManager
{
private:
	unordered_map<uint64_t, LabelInfo, AddressHasher> _codeLabels;
	unordered_map<string, uint64_t> _codeLabelReverseLookup;
	Debugger *_debugger;
	int64_t GetLabelKey(uint32_t absoluteAddr, MemoryType memType);
	MemoryType GetKeyMemoryType(uint64_t key);
	bool InternalGetLabel(AddressInfo address, string& label);
public:
	LabelManager(Debugger *debugger);
	void SetLabel(uint32_t address, MemoryType memType, string label, string comment);
	void ClearLabels();
	AddressInfo GetLabelAbsoluteAddress(string& label);
	int32_t GetLabelRelativeAddress(string &label, CpuType cpuType);
	string GetLabel(AddressInfo address, bool checkRegisterLabels = true);
	string GetComment(AddressInfo absAddress);
	bool GetLabelAndComment(AddressInfo address, LabelInfo &label);
	bool ContainsLabel(string &label);
	bool HasLabelOrComment(AddressInfo address);
};
```

## File: Core/Debugger/LuaApi.h
```
#pragma once
#include "pch.h"
#include "Shared/CpuType.h"
#include "Shared/SettingTypes.h"
#include "Shared/MemoryType.h"
struct lua_State;
class ScriptingContext;
class Debugger;
class Emulator;
class MemoryDumper;
class DebugHud;
class BaseVideoFilter;
class LuaApi
{
public:
	static void SetContext(ScriptingContext *context);
	static int GetLibrary(lua_State *lua);
	static void LuaPushIntValue(lua_State* lua, string name, int value);
	static DebugHud* GetHud();
	static int SelectDrawSurface(lua_State* lua);
	static int GetMemorySize(lua_State* lua);
	static int ReadMemory(lua_State *lua);
	static int WriteMemory(lua_State *lua);
	static int ReadMemory16(lua_State *lua);
	static int WriteMemory16(lua_State *lua);
	static int ReadMemory32(lua_State* lua);
	static int WriteMemory32(lua_State* lua);
	static int GetLabelAddress(lua_State* lua);
	static int ConvertAddress(lua_State *lua);
	static int RegisterMemoryCallback(lua_State *lua);
	static int UnregisterMemoryCallback(lua_State *lua);
	static int RegisterEventCallback(lua_State *lua);
	static int UnregisterEventCallback(lua_State *lua);
	static int MeasureString(lua_State* lua);
	static int DrawString(lua_State *lua);
	static int DrawLine(lua_State *lua);
	static int DrawPixel(lua_State *lua);
	static int DrawRectangle(lua_State *lua);
	static int ClearScreen(lua_State *lua);
	static int GetScreenSize(lua_State* lua);
	static int GetDrawSurfaceSize(lua_State* lua);
	static int GetScreenBuffer(lua_State *lua);
	static int SetScreenBuffer(lua_State *lua);
	static int GetPixel(lua_State *lua);
	static int GetMouseState(lua_State *lua);
	static int Log(lua_State *lua);
	static int DisplayMessage(lua_State *lua);
	static int Reset(lua_State *lua);
	static int Stop(lua_State *lua);
	static int BreakExecution(lua_State *lua);
	static int Resume(lua_State *lua);
	static int Step(lua_State *lua);
	static int Rewind(lua_State *lua);
	static int TakeScreenshot(lua_State *lua);
	static int CreateSavestate(lua_State *lua);
	static int LoadSavestate(lua_State *lua);
	static int IsKeyPressed(lua_State *lua);
	static int GetInput(lua_State *lua);
	static int SetInput(lua_State *lua);
	static int AddCheat(lua_State *lua);
	static int ClearCheats(lua_State *lua);
	static int GetScriptDataFolder(lua_State *lua);
	static int GetRomInfo(lua_State *lua);
	static int GetLogWindowLog(lua_State *lua);
	static int SetState(lua_State *lua);
	static int GetState(lua_State *lua);
	static int GetAccessCounters(lua_State *lua);
	static int ResetAccessCounters(lua_State *lua);
	static int GetCdlData(lua_State* lua);
private:
	static FrameInfo InternalGetScreenSize();
	static Emulator* _emu;
	static Debugger* _debugger;
	static MemoryDumper* _memoryDumper;
	static ScriptingContext* _context;
	static std::pair<unique_ptr<BaseVideoFilter>, FrameInfo> GetRenderedFrame();
	template<typename T> static void GenerateEnumDefinition(lua_State* lua, string enumName, unordered_set<T> excludedValues = {});
};
```

## File: Core/Debugger/LuaCallHelper.cpp
```cpp
#include "pch.h"
#include "LuaCallHelper.h"
LuaCallHelper::LuaCallHelper(lua_State *lua) : _lua(lua)
{
	_stackSize = lua_gettop(lua);
}
void LuaCallHelper::ForceParamCount(int paramCount)
{
	while(lua_gettop(_lua) < paramCount) {
		lua_pushnil(_lua);
	}
}
bool LuaCallHelper::CheckParamCount(int minParamCount)
{
	if(minParamCount >= 0 && _stackSize < _paramCount && _stackSize >= minParamCount) {
		return true;
	}
	if(_stackSize != _paramCount) {
		string message = string("too ") + (_stackSize < _paramCount ? "few" : "many") + " parameters.  expected " + std::to_string(_paramCount) + " got " + std::to_string(_stackSize);
		luaL_error(_lua, message.c_str());
		return false;
	}
	return true;
}
double LuaCallHelper::ReadDouble()
{
	_paramCount++;
	double value = 0;
	if(lua_isnumber(_lua, -1)) {
		value = lua_tonumber(_lua, -1);
	}
	lua_pop(_lua, 1);
	return value;
}
bool LuaCallHelper::ReadBool(bool defaultValue)
{
	_paramCount++;
	bool value = defaultValue;
	if(lua_isboolean(_lua, -1)) {
		value = lua_toboolean(_lua, -1) != 0;
	} else if(lua_isnumber(_lua, -1)) {
		value = lua_tonumber(_lua, -1) != 0;
	}
	lua_pop(_lua, 1);
	return value;
}
Nullable<bool> LuaCallHelper::ReadOptionalBool()
{
	_paramCount++;
	Nullable<bool> result;
	if(lua_isboolean(_lua, -1)) {
		result.HasValue = true;
		result.Value = lua_toboolean(_lua, -1) != 0;
	} else if(lua_isnumber(_lua, -1)) {
		result.HasValue = true;
		result.Value = lua_tonumber(_lua, -1) != 0;
	}
	lua_pop(_lua, 1);
	return result;
}
Nullable<int32_t> LuaCallHelper::ReadOptionalInteger()
{
	_paramCount++;
	Nullable<int32_t> result;
	if(lua_isinteger(_lua, -1)) {
		result.HasValue = true;
		result.Value = (int32_t)lua_tointeger(_lua, -1);
	} else if(lua_isnumber(_lua, -1)) {
		result.HasValue = true;
		result.Value = (int32_t)lua_tonumber(_lua, -1);
	}
	lua_pop(_lua, 1);
	return result;
}
uint32_t LuaCallHelper::ReadInteger(uint32_t defaultValue)
{
	_paramCount++;
	uint32_t value = defaultValue;
	if(lua_isinteger(_lua, -1)) {
		value = (uint32_t)lua_tointeger(_lua, -1);
	} else if(lua_isnumber(_lua, -1)) {
		value = (uint32_t)lua_tonumber(_lua, -1);
	}
	lua_pop(_lua, 1);
	return value;
}
string LuaCallHelper::ReadString()
{
	_paramCount++;
	size_t len;
	string str;
	if(lua_isstring(_lua, -1)) {
		const char* cstr = lua_tolstring(_lua, -1, &len);
		str = string(cstr, len);
	}
	lua_pop(_lua, 1);
	return str;
}
int LuaCallHelper::GetReference()
{
	_paramCount++;
	if(lua_isfunction(_lua, -1)) {
		return luaL_ref(_lua, LUA_REGISTRYINDEX);
	} else {
		lua_pop(_lua, 1);
		return LUA_NOREF;
	}
}
void LuaCallHelper::Return(bool value)
{
	lua_pushboolean(_lua, value);
	_returnCount++;
}
void LuaCallHelper::Return(int value)
{
	lua_pushinteger(_lua, value);
	_returnCount++;
}
void LuaCallHelper::Return(uint32_t value)
{
	lua_pushinteger(_lua, value);
	_returnCount++;
}
void LuaCallHelper::Return(string value)
{
	lua_pushlstring(_lua, value.c_str(), value.size());
	_returnCount++;
}
int LuaCallHelper::ReturnCount()
{
	return _returnCount;
}
```

## File: Core/Debugger/LuaCallHelper.h
```
#pragma once
#include "pch.h"
#include "Lua/lua.hpp"
template<typename T>
struct Nullable
{
	bool HasValue = false;
	T Value = {};
};
class LuaCallHelper
{
private:
	int _stackSize = 0;
	int _paramCount = 0;
	int _returnCount = 0;
	lua_State* _lua;
public:
	LuaCallHelper(lua_State* lua);
	void ForceParamCount(int paramCount);
	bool CheckParamCount(int minParamCount = -1);
	double ReadDouble();
	bool ReadBool(bool defaultValue = false);
	uint32_t ReadInteger(uint32_t defaultValue = 0);
	string ReadString();
	int GetReference();
	Nullable<bool> ReadOptionalBool();
	Nullable<int32_t> ReadOptionalInteger();
	void Return(bool value);
	void Return(int value);
	void Return(uint32_t value);
	void Return(string value);
	int ReturnCount();
};
```

## File: Core/Debugger/MemoryAccessCounter.cpp
```cpp
#include "pch.h"
#include "Debugger/MemoryAccessCounter.h"
#include "Debugger/DebugBreakHelper.h"
#include "Debugger/Debugger.h"
#include "Debugger/DebugUtilities.h"
#include "Debugger/MemoryDumper.h"
#include "Shared/Interfaces/IConsole.h"
MemoryAccessCounter::MemoryAccessCounter(Debugger* debugger)
{
	_debugger = debugger;
	_enableBreakOnUninitRead = _debugger->GetConsole()->GetMasterClock() < 1000;
	for(int i = (int)DebugUtilities::GetLastCpuMemoryType() + 1; i < DebugUtilities::GetMemoryTypeCount(); i++) {
		uint32_t memSize = _debugger->GetMemoryDumper()->GetMemorySize((MemoryType)i);
		if(memSize > 0) {
			_counters[i] = vector<AddressCounters>(memSize);
		}
	}
}
template<uint8_t accessWidth>
ReadResult MemoryAccessCounter::ProcessMemoryRead(AddressInfo &addressInfo, uint64_t masterClock)
{
	if(addressInfo.Address < 0) {
		return ReadResult::Normal;
	}
	ReadResult result = ReadResult::Normal;
	for(int i = 0; i < accessWidth; i++) {
		AddressCounters& counts = _counters[(int)addressInfo.Type][addressInfo.Address+i];
		if(_enableBreakOnUninitRead && counts.WriteStamp == 0 && DebugUtilities::IsVolatileRam(addressInfo.Type)) {
			result = (ReadResult)((int)result | (int)(counts.ReadStamp == 0 ? ReadResult::FirstUninitRead : ReadResult::UninitRead));
		}
		counts.ReadStamp = masterClock;
		counts.ReadCounter++;
	}
	return result;
}
template<uint8_t accessWidth>
void MemoryAccessCounter::ProcessMemoryWrite(AddressInfo& addressInfo, uint64_t masterClock)
{
	if(addressInfo.Address < 0) {
		return;
	}
	for(int i = 0; i < accessWidth; i++) {
		AddressCounters& counts = _counters[(int)addressInfo.Type][addressInfo.Address+i];
		counts.WriteStamp = masterClock;
		counts.WriteCounter++;
	}
}
template<uint8_t accessWidth>
void MemoryAccessCounter::ProcessMemoryExec(AddressInfo& addressInfo, uint64_t masterClock)
{
	if(addressInfo.Address < 0) {
		return;
	}
	for(int i = 0; i < accessWidth; i++) {
		AddressCounters& counts = _counters[(int)addressInfo.Type][addressInfo.Address+i];
		counts.ExecStamp = masterClock;
		counts.ExecCounter++;
	}
}
void MemoryAccessCounter::ResetCounts()
{
	DebugBreakHelper helper(_debugger);
	for(int i = 0; i < DebugUtilities::GetMemoryTypeCount(); i++) {
		memset(_counters[i].data(), 0, _counters[i].size() * sizeof(AddressCounters));
	}
	_enableBreakOnUninitRead = _debugger->GetConsole()->GetMasterClock() < 1000;
}
void MemoryAccessCounter::GetAccessCounts(uint32_t offset, uint32_t length, MemoryType memoryType, AddressCounters counts[])
{
	if(DebugUtilities::IsRelativeMemory(memoryType)) {
		AddressInfo addr = {};
		addr.Type = memoryType;
		for(uint32_t i = 0; i < length; i++) {
			addr.Address = offset + i;
			AddressInfo info = _debugger->GetAbsoluteAddress(addr);
			if(info.Address >= 0) {
				counts[i] = _counters[(int)info.Type][info.Address];
			}
		}
	} else {
		if(offset + length <= _counters[(int)memoryType].size()) {
			memcpy(counts, _counters[(int)memoryType].data() + offset, length * sizeof(AddressCounters));
		}
	}
}
template ReadResult MemoryAccessCounter::ProcessMemoryRead<1>(AddressInfo& addressInfo, uint64_t masterClock);
template ReadResult MemoryAccessCounter::ProcessMemoryRead<2>(AddressInfo& addressInfo, uint64_t masterClock);
template ReadResult MemoryAccessCounter::ProcessMemoryRead<4>(AddressInfo& addressInfo, uint64_t masterClock);
template void MemoryAccessCounter::ProcessMemoryWrite<1>(AddressInfo& addressInfo, uint64_t masterClock);
template void MemoryAccessCounter::ProcessMemoryWrite<2>(AddressInfo& addressInfo, uint64_t masterClock);
template void MemoryAccessCounter::ProcessMemoryWrite<4>(AddressInfo& addressInfo, uint64_t masterClock);
template void MemoryAccessCounter::ProcessMemoryExec<1>(AddressInfo& addressInfo, uint64_t masterClock);
template void MemoryAccessCounter::ProcessMemoryExec<2>(AddressInfo& addressInfo, uint64_t masterClock);
template void MemoryAccessCounter::ProcessMemoryExec<4>(AddressInfo& addressInfo, uint64_t masterClock);
```

## File: Core/Debugger/MemoryAccessCounter.h
```
#pragma once
#include "pch.h"
#include "Debugger/DebugTypes.h"
#include "Debugger/DebugUtilities.h"
#include "Shared/MemoryType.h"
class Debugger;
class SnesMemoryManager;
class Spc;
class SnesConsole;
class Sa1;
class Gsu;
class Cx4;
class Gameboy;
struct AddressCounters
{
	uint64_t ReadStamp;
	uint64_t WriteStamp;
	uint64_t ExecStamp;
	uint32_t ReadCounter;
	uint32_t WriteCounter;
	uint32_t ExecCounter;
};
enum class ReadResult
{
	Normal,
	FirstUninitRead,
	UninitRead
};
class MemoryAccessCounter
{
private:
	vector<AddressCounters> _counters[DebugUtilities::GetMemoryTypeCount()];
	Debugger* _debugger = nullptr;
	bool _enableBreakOnUninitRead = false;
public:
	MemoryAccessCounter(Debugger *debugger);
	template<uint8_t accessWidth = 1> ReadResult ProcessMemoryRead(AddressInfo& addressInfo, uint64_t masterClock);
	template<uint8_t accessWidth = 1> void ProcessMemoryWrite(AddressInfo& addressInfo, uint64_t masterClock);
	template<uint8_t accessWidth = 1> void ProcessMemoryExec(AddressInfo& addressInfo, uint64_t masterClock);
	void ResetCounts();
	void GetAccessCounts(uint32_t offset, uint32_t length, MemoryType memoryType, AddressCounters counts[]);
};
```

## File: Core/Debugger/MemoryDumper.cpp
```cpp
#include "pch.h"
#include "Debugger/Debugger.h"
#include "Shared/Emulator.h"
#include "SNES/SnesMemoryManager.h"
#include "SNES/Spc.h"
#include "SNES/Coprocessors/DSP/NecDsp.h"
#include "SNES/Coprocessors/SA1/Sa1.h"
#include "SNES/Coprocessors/CX4/Cx4.h"
#include "SNES/Coprocessors/GSU/Gsu.h"
#include "SNES/Coprocessors/ST018/St018.h"
#include "Gameboy/Gameboy.h"
#include "Gameboy/GbMemoryManager.h"
#include "SNES/Coprocessors/BSX/BsxCart.h"
#include "SNES/Coprocessors/BSX/BsxMemoryPack.h"
#include "SNES/SnesConsole.h"
#include "Debugger/MemoryDumper.h"
#include "SNES/BaseCartridge.h"
#include "NES/NesConsole.h"
#include "PCE/PceConsole.h"
#include "PCE/PceMemoryManager.h"
#include "SMS/SmsConsole.h"
#include "SMS/SmsVdp.h"
#include "SMS/SmsMemoryManager.h"
#include "GBA/GbaConsole.h"
#include "GBA/GbaMemoryManager.h"
#include "WS/WsConsole.h"
#include "WS/WsMemoryManager.h"
#include "Shared/Video/VideoDecoder.h"
#include "Debugger/DebugTypes.h"
#include "Debugger/DebugBreakHelper.h"
#include "Debugger/DebugUtilities.h"
#include "Debugger/Disassembler.h"
#include "Debugger/CdlManager.h"
MemoryDumper::MemoryDumper(Debugger* debugger)
{
	_debugger = debugger;
	_emu = debugger->GetEmulator();
	IConsole* console = _debugger->GetConsole();
	if(SnesConsole* snes = dynamic_cast<SnesConsole*>(console)) {
		_spc = snes->GetSpc();
		_memoryManager = snes->GetMemoryManager();
		_cartridge = snes->GetCartridge();
		_gameboy = snes->GetCartridge()->GetGameboy();
	} else if(NesConsole* nes = dynamic_cast<NesConsole*>(console)) {
		_nesConsole = nes;
	} else if(Gameboy* gb = dynamic_cast<Gameboy*>(console)) {
		_gameboy = gb;
	} else if(PceConsole* pce = dynamic_cast<PceConsole*>(console)) {
		_pceConsole = pce;
	} else if(SmsConsole* sms = dynamic_cast<SmsConsole*>(console)) {
		_smsConsole = sms;
	} else if(GbaConsole* gba = dynamic_cast<GbaConsole*>(console)) {
		_gbaConsole = gba;
	} else if(WsConsole* ws = dynamic_cast<WsConsole*>(console)) {
		_wsConsole = ws;
	}
	for(int i = 0; i < DebugUtilities::GetMemoryTypeCount(); i++) {
		MemoryType memType = (MemoryType)i;
		if(memType != MemoryType::None) {
			_isMemorySupported[i] = _emu->GetMemory(memType).Memory != nullptr || _debugger->HasCpuType(DebugUtilities::ToCpuType(memType));
		}
	}
}
void MemoryDumper::SetMemoryState(MemoryType type, uint8_t *buffer, uint32_t length)
{
	if(length > GetMemorySize(type)) {
		return;
	}
	uint8_t* dst = GetMemoryBuffer(type);
	if(dst) {
		memcpy(dst, buffer, length);
	}
}
uint8_t* MemoryDumper::GetMemoryBuffer(MemoryType type)
{
	return (uint8_t*)_emu->GetMemory(type).Memory;
}
uint32_t MemoryDumper::GetMemorySize(MemoryType type)
{
	if(!_isMemorySupported[(int)type]) {
		return 0;
	}
	switch(type) {
		case MemoryType::SnesMemory: return 0x1000000;
		case MemoryType::SpcMemory: return 0x10000;
		case MemoryType::NecDspMemory: return _emu->GetMemory(MemoryType::DspProgramRom).Size;
		case MemoryType::Sa1Memory: return 0x1000000;
		case MemoryType::GsuMemory: return 0x1000000;
		case MemoryType::Cx4Memory: return 0x1000000;
		case MemoryType::St018Memory: return 0x20000;
		case MemoryType::GameboyMemory: return 0x10000;
		case MemoryType::NesMemory: return 0x10000;
		case MemoryType::NesPpuMemory: return 0x4000;
		case MemoryType::PceMemory: return 0x10000;
		case MemoryType::SmsMemory: return 0x10000;
		case MemoryType::GbaMemory: return 0x10000000;
		case MemoryType::WsMemory: return 0x100000;
		case MemoryType::SnesRegister: return 0x10000;
		case MemoryType::SmsPort: return 0x100;
		case MemoryType::WsPort: return 0x10000;
		default: return _emu->GetMemory(type).Size;
	}
}
void MemoryDumper::GetMemoryState(MemoryType type, uint8_t *buffer)
{
	if(GetMemorySize(type) == 0) {
		return;
	}
	switch(type) {
		case MemoryType::SnesMemory:
			for(int i = 0; i <= 0xFFFFFF; i+=0x1000) {
				_memoryManager->PeekBlock(i, buffer+i);
			}
			break;
		case MemoryType::SpcMemory:
			for(int i = 0; i <= 0xFFFF; i++) {
				buffer[i] = _spc->DebugRead(i);
			}
			break;
		case MemoryType::Sa1Memory:
			if(_cartridge->GetSa1()) {
				for(int i = 0; i <= 0xFFFFFF; i += 0x1000) {
					_cartridge->GetSa1()->GetMemoryMappings()->PeekBlock(i, buffer + i);
				}
			}
			break;
		case MemoryType::NecDspMemory:
			GetMemoryState(MemoryType::DspProgramRom, buffer);
			break;
		case MemoryType::GsuMemory:
			if(_cartridge->GetGsu()) {
				for(int i = 0; i <= 0xFFFFFF; i += 0x1000) {
					_cartridge->GetGsu()->GetMemoryMappings()->PeekBlock(i, buffer + i);
				}
			}
			break;
		case MemoryType::Cx4Memory:
			if(_cartridge->GetCx4()) {
				for(int i = 0; i <= 0xFFFFFF; i += 0x1000) {
					_cartridge->GetCx4()->GetMemoryMappings()->PeekBlock(i, buffer + i);
				}
			}
			break;
		case MemoryType::St018Memory:
			if(_cartridge->GetSt018()) {
				for(int i = 0; i < 0x20000; i += 0x1000) {
					_cartridge->GetSt018()->PeekBlock(i, buffer + i);
				}
			}
			break;
		case MemoryType::GameboyMemory: {
			if(_gameboy) {
				GbMemoryManager* memManager = _gameboy->GetMemoryManager();
				for(int i = 0; i <= 0xFFFF; i++) {
					buffer[i] = memManager->DebugRead(i);
				}
			}
			break;
		}
		case MemoryType::NesMemory: {
			if(_nesConsole) {
				for(int i = 0; i <= 0xFFFF; i++) {
					buffer[i] = _nesConsole->DebugRead(i);
				}
			}
			break;
		}
		case MemoryType::NesPpuMemory: {
			if(_nesConsole) {
				for(int i = 0; i < 0x4000; i++) {
					buffer[i] = _nesConsole->DebugReadVram(i);
				}
			}
			break;
		}
		case MemoryType::PceMemory: {
			if(_pceConsole) {
				PceMemoryManager* memManager = _pceConsole->GetMemoryManager();
				for(int i = 0; i <= 0xFFFF; i++) {
					buffer[i] = memManager->DebugRead(i);
				}
			}
			break;
		}
		case MemoryType::SmsMemory: {
			if(_smsConsole) {
				SmsMemoryManager* memManager = _smsConsole->GetMemoryManager();
				for(int i = 0; i <= 0xFFFF; i++) {
					buffer[i] = memManager->DebugRead(i);
				}
			}
			break;
		}
		case MemoryType::GbaMemory: {
			if(_gbaConsole) {
				GbaMemoryManager* memManager = _gbaConsole->GetMemoryManager();
				for(int i = 0; i <= 0xFFFFFFF; i++) {
					buffer[i] = memManager->DebugRead(i);
				}
			}
			break;
		}
		case MemoryType::WsMemory: {
			if(_wsConsole) {
				WsMemoryManager* memManager = _wsConsole->GetMemoryManager();
				for(int i = 0; i <= 0xFFFFF; i++) {
					buffer[i] = memManager->DebugRead(i);
				}
			}
			break;
		}
		default:
			uint8_t* src = GetMemoryBuffer(type);
			if(src) {
				memcpy(buffer, src, GetMemorySize(type));
			}
			break;
	}
}
void MemoryDumper::InternalSetMemoryValues(MemoryType originalMemoryType, uint32_t startAddress, uint8_t* data, uint32_t length, bool disableSideEffects, bool undoAllowed)
{
	uint32_t memSize = GetMemorySize(originalMemoryType);
	UndoBatch undoBatch = {};
	UndoEntry undoEntry = { MemoryType::None };
	Disassembler* disassembler = _debugger->GetDisassembler();
	for(uint32_t i = 0; i < length; i++) {
		uint32_t address = startAddress + i;
		if(address >= memSize) {
			break;
		}
		uint8_t value = data[i];
		MemoryType memoryType = originalMemoryType;
		if(disableSideEffects && DebugUtilities::IsRelativeMemory(memoryType)) {
			AddressInfo addr = { (int32_t)address, memoryType };
			addr = _debugger->GetAbsoluteAddress(addr);
			if(addr.Address < 0) {
				continue;
			}
			address = addr.Address;
			memoryType = addr.Type;
		}
		switch(memoryType) {
			case MemoryType::SnesMemory: _memoryManager->GetMemoryMappings()->DebugWrite(address, value); break;
			case MemoryType::SpcMemory: _spc->DebugWrite(address, value); break;
			case MemoryType::Sa1Memory: _cartridge->GetSa1()->GetMemoryMappings()->DebugWrite(address, value); break;
			case MemoryType::NecDspMemory: SetMemoryValue(MemoryType::DspProgramRom, address, value, disableSideEffects); return;
			case MemoryType::GsuMemory: _cartridge->GetGsu()->GetMemoryMappings()->DebugWrite(address, value); break;
			case MemoryType::Cx4Memory: _cartridge->GetCx4()->GetMemoryMappings()->DebugWrite(address, value); break;
			case MemoryType::St018Memory: _cartridge->GetSt018()->DebugWrite(address, value); break;
			case MemoryType::GameboyMemory: _gameboy->GetMemoryManager()->DebugWrite(address, value); break;
			case MemoryType::NesMemory: _nesConsole->DebugWrite(address, value, disableSideEffects); break;
			case MemoryType::NesPpuMemory: _nesConsole->DebugWriteVram(address, value); break;
			case MemoryType::PceMemory: _pceConsole->GetMemoryManager()->DebugWrite(address, value); break;
			case MemoryType::SmsMemory: _smsConsole->GetMemoryManager()->DebugWrite(address, value); break;
			case MemoryType::GbaMemory: _gbaConsole->GetMemoryManager()->DebugWrite(address, value); break;
			case MemoryType::WsMemory: _wsConsole->GetMemoryManager()->DebugWrite(address, value); break;
			case MemoryType::SpcDspRegisters: _spc->DebugWriteDspReg(address, value); break;
			default:
				uint8_t* src = GetMemoryBuffer(memoryType);
				if(src) {
					if(undoAllowed) {
						if(undoEntry.MemType != memoryType) {
							if(undoEntry.OriginalData.size() > 0) {
								undoBatch.Entries.push_back(undoEntry);
							}
							undoEntry = { memoryType, address };
						}
						uint8_t originalValue = src[address];
						undoEntry.OriginalData.push_back(originalValue);
					}
					switch(memoryType) {
						case MemoryType::SnesCgRam: src[address] = (address & 0x01) ? (value & 0x7F) : value; break;
						case MemoryType::NesSpriteRam: case MemoryType::NesSecondarySpriteRam: src[address] = (address & 0x03) == 0x02 ? (value & 0xE3) : value; break;
						case MemoryType::NesPaletteRam: src[address] = value & 0x3F; break;
						case MemoryType::PcePaletteRam: src[address] = (address & 0x01) ? (value & 0x01) : value; break;
						case MemoryType::SmsPaletteRam: _smsConsole->GetVdp()->DebugWritePalette(address, value); break;
						default:
							src[address] = value;
							AddressInfo addr = { (int32_t)address, memoryType };
							disassembler->InvalidateCache(addr, DebugUtilities::ToCpuType(memoryType));
							break;
					}
				}
				break;
		}
	}
	if(undoAllowed && undoEntry.MemType != MemoryType::None) {
		undoBatch.Entries.push_back(undoEntry);
		auto lock = _undoLock.AcquireSafe();
		_undoHistory.push_back(undoBatch);
		if(_undoHistory.size() > 200) {
			_undoHistory.pop_front();
		}
	}
}
void MemoryDumper::SetMemoryValues(MemoryType memoryType, uint32_t address, uint8_t* data, uint32_t length)
{
	DebugBreakHelper helper(_debugger);
	InternalSetMemoryValues(memoryType, address, data, length, true, true);
}
void MemoryDumper::SetMemoryValue(MemoryType memoryType, uint32_t address, uint8_t value, bool disableSideEffects)
{
	InternalSetMemoryValues(memoryType, address, &value, 1, disableSideEffects, true);
}
void MemoryDumper::GetMemoryValues(MemoryType memoryType, uint32_t start, uint32_t end, uint8_t* output)
{
	int x = 0;
	uint32_t size = GetMemorySize(memoryType);
	for(uint32_t i = start; i <= end && i < size; i++) {
		output[x++] = InternalGetMemoryValue(memoryType, i);
	}
	if(end >= size) {
		memset(output + x, 0, end - start - x + 1);
	}
}
uint8_t MemoryDumper::GetMemoryValue(MemoryType memoryType, uint32_t address, bool disableSideEffects)
{
	if(address >= GetMemorySize(memoryType)) {
		return 0;
	}
	return InternalGetMemoryValue(memoryType, address, disableSideEffects);
}
uint8_t MemoryDumper::InternalGetMemoryValue(MemoryType memoryType, uint32_t address, bool disableSideEffects)
{
	switch(memoryType) {
		case MemoryType::SnesMemory: return _memoryManager->Peek(address);
		case MemoryType::SpcMemory: return _spc->DebugRead(address);
		case MemoryType::Sa1Memory: return _cartridge->GetSa1()->GetMemoryMappings()->Peek(address);
		case MemoryType::NecDspMemory: return GetMemoryValue(MemoryType::DspProgramRom, address);
		case MemoryType::GsuMemory: return _cartridge->GetGsu()->GetMemoryMappings()->Peek(address);
		case MemoryType::Cx4Memory: return _cartridge->GetCx4()->GetMemoryMappings()->Peek(address);
		case MemoryType::St018Memory: return _cartridge->GetSt018()->DebugRead(address);
		case MemoryType::GameboyMemory: return _gameboy->GetMemoryManager()->DebugRead(address);
		case MemoryType::NesMemory: return _nesConsole->DebugRead(address);
		case MemoryType::NesPpuMemory: return _nesConsole->DebugReadVram(address);
		case MemoryType::PceMemory: return _pceConsole->GetMemoryManager()->DebugRead(address);
		case MemoryType::SmsMemory: return _smsConsole->GetMemoryManager()->DebugRead(address);
		case MemoryType::SmsPort: return _smsConsole->GetMemoryManager()->DebugReadPort(address);
		case MemoryType::GbaMemory: return _gbaConsole->GetMemoryManager()->DebugRead(address);
		case MemoryType::WsMemory: return _wsConsole->GetMemoryManager()->DebugRead(address);
		case MemoryType::WsPort: return _wsConsole->GetMemoryManager()->DebugReadPort<uint8_t>(address);
		default:
			uint8_t* src = GetMemoryBuffer(memoryType);
			return src ? src[address] : 0;
	}
}
uint16_t MemoryDumper::GetMemoryValue16(MemoryType memoryType, uint32_t address, bool disableSideEffects)
{
	uint32_t memorySize = GetMemorySize(memoryType);
	uint8_t lsb = GetMemoryValue(memoryType, address);
	uint8_t msb = GetMemoryValue(memoryType, address + 1 >= memorySize ? 0 : address + 1);
	return (msb << 8) | lsb;
}
uint32_t MemoryDumper::GetMemoryValue32(MemoryType memoryType, uint32_t address, bool disableSideEffects)
{
	uint32_t memorySize = GetMemorySize(memoryType);
	uint8_t b0 = GetMemoryValue(memoryType, address);
	uint8_t b1 = GetMemoryValue(memoryType, address + 1 >= memorySize ? 0 : address + 1);
	uint8_t b2 = GetMemoryValue(memoryType, address + 2 >= memorySize ? 0 : address + 2);
	uint8_t b3 = GetMemoryValue(memoryType, address + 3 >= memorySize ? 0 : address + 3);
	return (b3 << 24) | (b2 << 16) | (b1 << 8) | b0;
}
void MemoryDumper::SetMemoryValue16(MemoryType memoryType, uint32_t address, uint16_t value, bool disableSideEffects)
{
	DebugBreakHelper helper(_debugger);
	SetMemoryValue(memoryType, address, (uint8_t)value, disableSideEffects);
	SetMemoryValue(memoryType, address + 1, (uint8_t)(value >> 8), disableSideEffects);
}
void MemoryDumper::SetMemoryValue32(MemoryType memoryType, uint32_t address, uint32_t value, bool disableSideEffects)
{
	DebugBreakHelper helper(_debugger);
	SetMemoryValue(memoryType, address, (uint8_t)value, disableSideEffects);
	SetMemoryValue(memoryType, address + 1, (uint8_t)(value >> 8), disableSideEffects);
	SetMemoryValue(memoryType, address + 2, (uint8_t)(value >> 16), disableSideEffects);
	SetMemoryValue(memoryType, address + 3, (uint8_t)(value >> 24), disableSideEffects);
}
bool MemoryDumper::HasUndoHistory()
{
	auto lock = _undoLock.AcquireSafe();
	return _undoHistory.size() > 0;
}
void MemoryDumper::PerformUndo()
{
	auto lock = _undoLock.AcquireSafe();
	if(!_undoHistory.empty()) {
		DebugBreakHelper helper(_debugger);
		UndoBatch& batch = _undoHistory.back();
		for(auto entry : batch.Entries) {
			InternalSetMemoryValues(entry.MemType, entry.StartAddress, entry.OriginalData.data(), (uint32_t)entry.OriginalData.size(), true, false);
		}
		_undoHistory.pop_back();
		_debugger->GetCdlManager()->RefreshCodeCache();
	}
}
```

## File: Core/Debugger/MemoryDumper.h
```
#pragma once
#include "pch.h"
#include <unordered_map>
#include "Debugger/DebugTypes.h"
#include "Debugger/DebugUtilities.h"
#include "Shared/MemoryType.h"
#include "Utilities/SimpleLock.h"
class SnesMemoryManager;
class NesConsole;
class BaseCartridge;
class Spc;
class Gameboy;
class PceConsole;
class SmsConsole;
class GbaConsole;
class WsConsole;
class Emulator;
class Debugger;
struct UndoEntry
{
	MemoryType MemType;
	uint32_t StartAddress;
	vector<uint8_t> OriginalData;
};
struct UndoBatch
{
	vector<UndoEntry> Entries;
};
class MemoryDumper
{
private:
	Emulator* _emu = nullptr;
	Spc* _spc = nullptr;
	Gameboy* _gameboy = nullptr;
	SnesMemoryManager* _memoryManager = nullptr;
	NesConsole* _nesConsole = nullptr;
	PceConsole* _pceConsole = nullptr;
	SmsConsole* _smsConsole = nullptr;
	GbaConsole* _gbaConsole = nullptr;
	WsConsole* _wsConsole = nullptr;
	BaseCartridge* _cartridge = nullptr;
	Debugger* _debugger = nullptr;
	bool _isMemorySupported[DebugUtilities::GetMemoryTypeCount()] = {};
	SimpleLock _undoLock;
	deque<UndoBatch> _undoHistory;
	uint8_t InternalGetMemoryValue(MemoryType memoryType, uint32_t address, bool disableSideEffects = true);
	void InternalSetMemoryValues(MemoryType memoryType, uint32_t startAddress, uint8_t* data, uint32_t length, bool disableSideEffects, bool undoAllowed);
public:
	MemoryDumper(Debugger* debugger);
	uint8_t* GetMemoryBuffer(MemoryType type);
	uint32_t GetMemorySize(MemoryType type);
	void GetMemoryState(MemoryType type, uint8_t *buffer);
	uint8_t GetMemoryValue(MemoryType memoryType, uint32_t address, bool disableSideEffects = true);
	void GetMemoryValues(MemoryType memoryType, uint32_t start, uint32_t end, uint8_t* output);
	uint16_t GetMemoryValue16(MemoryType memoryType, uint32_t address, bool disableSideEffects = true);
	uint32_t GetMemoryValue32(MemoryType memoryType, uint32_t address, bool disableSideEffects = true);
	void SetMemoryValue16(MemoryType memoryType, uint32_t address, uint16_t value, bool disableSideEffects = true);
	void SetMemoryValue32(MemoryType memoryType, uint32_t address, uint32_t value, bool disableSideEffects);
	void SetMemoryValue(MemoryType memoryType, uint32_t address, uint8_t value, bool disableSideEffects = true);
	void SetMemoryValues(MemoryType memoryType, uint32_t address, uint8_t* data, uint32_t length);
	void SetMemoryState(MemoryType type, uint8_t *buffer, uint32_t length);
	bool HasUndoHistory();
	void PerformUndo();
};
```

## File: Core/Debugger/PpuTools.cpp
```cpp
#include "pch.h"
#include "Debugger/PpuTools.h"
#include "Debugger/CdlManager.h"
#include "Debugger/DebugTypes.h"
#include "Debugger/DebugBreakHelper.h"
#include "Shared/SettingTypes.h"
PpuTools::PpuTools(Debugger* debugger, Emulator *emu)
{
	_emu = emu;
	_debugger = debugger;
}
void PpuTools::BlendColors(uint8_t output[4], uint8_t input[4])
{
	int alpha = input[3] + 1;
	uint8_t invertedAlpha = 256 - input[3];
	output[0] = (uint8_t)((alpha * input[0] + invertedAlpha * output[0]) >> 8);
	output[1] = (uint8_t)((alpha * input[1] + invertedAlpha * output[1]) >> 8);
	output[2] = (uint8_t)((alpha * input[2] + invertedAlpha * output[2]) >> 8);
	output[3] = 0xFF;
}
void PpuTools::GetTileView(GetTileViewOptions options, uint8_t* source, uint32_t srcSize, const uint32_t* colors, uint32_t* outBuffer)
{
	switch(options.Format) {
		case TileFormat::Bpp2: InternalGetTileView<TileFormat::Bpp2>(options, source, srcSize, colors, outBuffer); break;
		case TileFormat::Bpp4: InternalGetTileView<TileFormat::Bpp4>(options, source, srcSize, colors, outBuffer); break;
		case TileFormat::Bpp8: InternalGetTileView<TileFormat::Bpp8>(options, source, srcSize, colors, outBuffer); break;
		case TileFormat::DirectColor: InternalGetTileView<TileFormat::DirectColor>(options, source, srcSize, colors, outBuffer); break;
		case TileFormat::Mode7: InternalGetTileView<TileFormat::Mode7>(options, source, srcSize, colors, outBuffer); break;
		case TileFormat::Mode7DirectColor: InternalGetTileView<TileFormat::Mode7DirectColor>(options, source, srcSize, colors, outBuffer); break;
		case TileFormat::Mode7ExtBg: InternalGetTileView<TileFormat::Mode7ExtBg>(options, source, srcSize, colors, outBuffer); break;
		case TileFormat::NesBpp2: InternalGetTileView<TileFormat::NesBpp2>(options, source, srcSize, colors, outBuffer); break;
		case TileFormat::PceSpriteBpp4: InternalGetTileView<TileFormat::PceSpriteBpp4>(options, source, srcSize, colors, outBuffer); break;
		case TileFormat::PceBackgroundBpp2Cg0: InternalGetTileView<TileFormat::PceBackgroundBpp2Cg0>(options, source, srcSize, colors, outBuffer); break;
		case TileFormat::PceBackgroundBpp2Cg1: InternalGetTileView<TileFormat::PceBackgroundBpp2Cg1>(options, source, srcSize, colors, outBuffer); break;
		case TileFormat::PceSpriteBpp2Sp01: InternalGetTileView<TileFormat::PceSpriteBpp2Sp01>(options, source, srcSize, colors, outBuffer); break;
		case TileFormat::PceSpriteBpp2Sp23: InternalGetTileView<TileFormat::PceSpriteBpp2Sp23>(options, source, srcSize, colors, outBuffer); break;
		case TileFormat::SmsBpp4: InternalGetTileView<TileFormat::SmsBpp4>(options, source, srcSize, colors, outBuffer); break;
		case TileFormat::SmsSgBpp1: InternalGetTileView<TileFormat::SmsSgBpp1>(options, source, srcSize, colors, outBuffer); break;
		case TileFormat::GbaBpp4: InternalGetTileView<TileFormat::GbaBpp4>(options, source, srcSize, colors, outBuffer); break;
		case TileFormat::GbaBpp8: InternalGetTileView<TileFormat::GbaBpp8>(options, source, srcSize, colors, outBuffer); break;
		case TileFormat::WsBpp4Packed: InternalGetTileView<TileFormat::WsBpp4Packed>(options, source, srcSize, colors, outBuffer); break;
	}
}
uint32_t PpuTools::GetBackgroundColor(TileBackground bgColor, const uint32_t* colors, uint8_t paletteIndex, uint8_t bpp)
{
	switch(bgColor) {
		default:
		case TileBackground::Default: return colors[0];
		case TileBackground::PaletteColor: return colors[paletteIndex * (1 << bpp)];
		case TileBackground::Black: return 0xFF000000;
		case TileBackground::White: return 0xFFFFFFFF;
		case TileBackground::Magenta: return 0xFFFF00FF;
		case TileBackground::Transparent: return 0;
	}
}
uint32_t PpuTools::GetSpriteBackgroundColor(SpriteBackground bgColor, const uint32_t* colors, bool useDarkerColor)
{
	switch(bgColor) {
		default:
		case SpriteBackground::Gray: return useDarkerColor ? 0xFF333333 : 0xFF666666;
		case SpriteBackground::Background: return useDarkerColor ? (((colors[0] >> 1) & 0x7F7F7F) | 0xFF000000) : colors[0];
		case SpriteBackground::Black: return useDarkerColor ? 0xFF000000 : 0xFF202020;
		case SpriteBackground::White: return useDarkerColor ? 0xFFEEEEEE : 0xFFFFFFFF;
		case SpriteBackground::Magenta: return useDarkerColor ? 0xFFCC00CC : 0xFFFF00FF;
		case SpriteBackground::Transparent: return 0;
	}
}
template<TileFormat format>
void PpuTools::InternalGetTileView(GetTileViewOptions options, uint8_t *source, uint32_t srcSize, const uint32_t *colors, uint32_t *outBuffer)
{
	uint8_t* ram = source;
	uint8_t bpp;
	int rowOffset = 2;
	int tileWidth = 8;
	int tileHeight = 8;
	switch(options.Format) {
		case TileFormat::Bpp2: bpp = 2; break;
		case TileFormat::Bpp4: bpp = 4; break;
		case TileFormat::DirectColor: bpp = 8; break;
		case TileFormat::Mode7:
		case TileFormat::Mode7DirectColor:
		case TileFormat::Mode7ExtBg:
			bpp = 16;
			rowOffset = 16;
			break;
		case TileFormat::NesBpp2: bpp = 2; rowOffset = 1; break;
		case TileFormat::PceSpriteBpp4: bpp = 4; rowOffset = 2; tileWidth = 16; tileHeight = 16; options.Width /= 2; options.Height /= 2; break;
		case TileFormat::PceSpriteBpp2Sp01: bpp = 4; rowOffset = 2; tileWidth = 16; tileHeight = 16; options.Width /= 2; options.Height /= 2; break;
		case TileFormat::PceSpriteBpp2Sp23: bpp = 4; rowOffset = 2; tileWidth = 16; tileHeight = 16; options.Width /= 2; options.Height /= 2; break;
		case TileFormat::PceBackgroundBpp2Cg0: bpp = 4; break;
		case TileFormat::PceBackgroundBpp2Cg1: bpp = 4; break;
		case TileFormat::SmsBpp4: bpp = 4; rowOffset = 4; break;
		case TileFormat::SmsSgBpp1: bpp = 1; rowOffset = 1; break;
		case TileFormat::GbaBpp4: bpp = 4; rowOffset = 4; break;
		case TileFormat::GbaBpp8: bpp = 8; rowOffset = 8; break;
		case TileFormat::WsBpp4Packed: bpp = 4; rowOffset = 4; break;
		default: bpp = 8; break;
	}
	int bytesPerTile = tileHeight*tileWidth * bpp / 8;
	int tileCount = options.Width * options.Height;
	uint8_t colorMask = 0xFF;
	if(options.UseGrayscalePalette) {
		options.Palette = 0;
		switch(bpp) {
			case 1: colors = _grayscaleColorsBpp1; colorMask = 0x01; break;
			case 2: colors = _grayscaleColorsBpp2; colorMask = 0x03; break;
			default: colors = _grayscaleColorsBpp4; colorMask = 0x0F; break;
		}
	}
	uint32_t bgColor = GetBackgroundColor(options.Background, colors, options.Palette, bpp);
	uint32_t outputSize = tileCount * tileWidth * tileHeight;
	for(uint32_t i = 0; i < outputSize; i++) {
		outBuffer[i] = bgColor;
	}
	int rowCount = (int)std::ceil((double)tileCount / options.Width);
	for(int row = 0; row < rowCount; row++) {
		uint32_t baseOffset = row * bytesPerTile * options.Width;
		if(baseOffset >= srcSize) {
			break;
		}
		for(int column = 0; column < options.Width; column++) {
			uint32_t addr = baseOffset + bytesPerTile * column;
			int baseOutputOffset;
			if(options.Layout == TileLayout::SingleLine8x16) {
				int displayColumn = column / 2 + ((row & 0x01) ? options.Width/2 : 0);
				int displayRow = (row & ~0x01) + ((column & 0x01) ? 1 : 0);
				baseOutputOffset = displayRow * options.Width * tileWidth * tileHeight + displayColumn * tileWidth;
			} else if(options.Layout == TileLayout::SingleLine16x16) {
				int displayColumn = (column / 2) + (column & 0x01) + ((row & 0x01) ? options.Width/2 : 0) + ((column & 0x02) ? -1 : 0);
				int displayRow = (row & ~0x01) + ((column & 0x02) ? 1 : 0);
				baseOutputOffset = displayRow * options.Width * tileWidth * tileHeight + displayColumn * tileWidth;
			} else {
				baseOutputOffset = row * options.Width * tileWidth * tileHeight + column * tileWidth;
			}
			if(IsTileHidden(options.MemType, addr, options)) {
				continue;
			}
			for(int y = 0; y < tileHeight; y++) {
				uint32_t pixelStart = addr + y * rowOffset;
				for(int x = 0; x < tileWidth; x++) {
					uint8_t color = GetTilePixelColor<format>(ram, 0xFFFFFFFF, pixelStart, x);
					if(color != 0 || options.Background == TileBackground::PaletteColor) {
						uint32_t pos = baseOutputOffset + (y * options.Width * tileWidth) + x;
						if(pos < outputSize) {
							outBuffer[pos] = GetRgbPixelColor<format>(colors, color & colorMask, options.Palette);
						}
					}
				}
			}
		}
	}
}
bool PpuTools::IsTileHidden(MemoryType memType, uint32_t addr, GetTileViewOptions& options)
{
	if(options.Filter == TileFilter::None) {
		return false;
	}
	int16_t cdlFlags = _debugger->GetCdlManager()->GetCdlFlags(memType, addr);
	return (
		(cdlFlags == 0 && options.Filter == TileFilter::HideUnused) ||
		(cdlFlags > 0 && options.Filter == TileFilter::HideUsed)
	);
}
void PpuTools::SetViewerUpdateTiming(uint32_t viewerId, uint16_t scanline, uint16_t cycle)
{
	DebugBreakHelper helper(_debugger);
	ViewerRefreshConfig cfg;
	cfg.Scanline = scanline;
	cfg.Cycle = cycle;
	_updateTimings[viewerId] = cfg;
}
void PpuTools::RemoveViewer(uint32_t viewerId)
{
	DebugBreakHelper helper(_debugger);
	_updateTimings.erase(viewerId);
}
int32_t PpuTools::GetTilePixel(AddressInfo tileAddress, TileFormat format, int32_t x, int32_t y)
{
	int32_t color = 0;
	GetSetTilePixel(tileAddress, format, x, y, color, true);
	return color;
}
void PpuTools::SetTilePixel(AddressInfo tileAddress, TileFormat format, int32_t x, int32_t y, int32_t color)
{
	GetSetTilePixel(tileAddress, format, x, y, color, false);
}
void PpuTools::GetSetTilePixel(AddressInfo tileAddress, TileFormat format, int32_t x, int32_t y, int32_t& color, bool forGet)
{
	ConsoleMemoryInfo memInfo = _emu->GetMemory(tileAddress.Type);
	if(!memInfo.Memory || memInfo.Size == 0) {
		return;
	}
	int rowOffset;
	switch(format) {
		default: rowOffset = 2; break;
		case TileFormat::Mode7:
		case TileFormat::Mode7DirectColor:
		case TileFormat::Mode7ExtBg:
			rowOffset = 16;
			break;
		case TileFormat::NesBpp2: rowOffset = 1; break;
		case TileFormat::PceSpriteBpp4: rowOffset = 2; break;
		case TileFormat::SmsBpp4: rowOffset = 4; break;
		case TileFormat::SmsSgBpp1: rowOffset = 1; break;
		case TileFormat::GbaBpp4: rowOffset = 4; break;
		case TileFormat::GbaBpp8: rowOffset = 8; break;
		case TileFormat::WsBpp4Packed: rowOffset = 4; break;
	}
	uint8_t* ram = (uint8_t*)memInfo.Memory;
	int rowStart = tileAddress.Address + (y * rowOffset);
	uint8_t shift = (7 - x);
	auto setBit = [&](uint32_t addr, uint8_t pixelNumber, uint8_t bitNumber) {
		if(addr >= memInfo.Size) {
			return;
		}
		if(forGet) {
			uint8_t bitValue = ((ram[addr] >> pixelNumber) & 0x01);
			color |= bitValue << bitNumber;
		} else {
			uint8_t bitValue = (color >> bitNumber) & 0x01;
			ram[addr] &= ~(1 << pixelNumber);
			ram[addr] |= (bitValue & 0x01) << pixelNumber;
		}
	};
	switch(format) {
		case TileFormat::Bpp2:
			setBit(rowStart, shift, 0);
			setBit(rowStart + 1, shift, 1);
			break;
		case TileFormat::NesBpp2:
			setBit(rowStart, shift, 0);
			setBit(rowStart + 8, shift, 1);
			break;
		case TileFormat::Bpp4:
			setBit(rowStart, shift, 0);
			setBit(rowStart + 1, shift, 1);
			setBit(rowStart + 16, shift, 2);
			setBit(rowStart + 17, shift, 3);
			break;
		case TileFormat::Bpp8:
		case TileFormat::DirectColor:
			setBit(rowStart, shift, 0);
			setBit(rowStart + 1, shift, 1);
			setBit(rowStart + 16, shift, 2);
			setBit(rowStart + 17, shift, 3);
			setBit(rowStart + 32, shift, 4);
			setBit(rowStart + 33, shift, 5);
			setBit(rowStart + 48, shift, 6);
			setBit(rowStart + 49, shift, 7);
			break;
		case TileFormat::Mode7:
		case TileFormat::Mode7DirectColor:
		case TileFormat::Mode7ExtBg: {
			uint32_t addr = (rowStart + x * 2 + 1);
			if(addr < memInfo.Size) {
				if(forGet) {
					color = ram[addr];
				} else {
					ram[addr] = color;
				}
			}
			break;
		}
		case TileFormat::PceSpriteBpp4:
		case TileFormat::PceSpriteBpp2Sp01:
		case TileFormat::PceSpriteBpp2Sp23:
		{
			shift = 15 - x;
			if(shift >= 8) {
				shift -= 8;
				rowStart++;
			}
			switch(format) {
				case TileFormat::PceSpriteBpp4:
					setBit(rowStart, shift, 0);
					setBit(rowStart + 32, shift, 1);
					setBit(rowStart + 64, shift, 2);
					setBit(rowStart + 96, shift, 3);
					break;
				case TileFormat::PceSpriteBpp2Sp01:
					setBit(rowStart, shift, 0);
					setBit(rowStart + 32, shift, 1);
					break;
				case TileFormat::PceSpriteBpp2Sp23:
					setBit(rowStart + 64, shift, 2);
					setBit(rowStart + 96, shift, 3);
					break;
			}
			break;
		}
		case TileFormat::PceBackgroundBpp2Cg0:
			setBit(rowStart, shift, 0);
			setBit(rowStart + 1, shift, 1);
			break;
		case TileFormat::PceBackgroundBpp2Cg1:
			setBit(rowStart + 16, shift, 2);
			setBit(rowStart + 17, shift, 3);
			break;
		case TileFormat::SmsBpp4:
			setBit(rowStart, shift, 0);
			setBit(rowStart + 1, shift, 1);
			setBit(rowStart + 2, shift, 2);
			setBit(rowStart + 3, shift, 3);
			break;
		case TileFormat::SmsSgBpp1:
			setBit(rowStart, shift, 0);
			break;
		case TileFormat::GbaBpp4: {
			uint8_t pixelOffset = (7 - shift);
			int32_t addr = (rowStart + (pixelOffset >> 1));
			int offset = pixelOffset & 0x01 ? 4 : 0;
			for(int i = 0; i < 4; i++) {
				setBit(addr, i+offset, i);
			}
			break;
		}
		case TileFormat::GbaBpp8: {
			uint8_t pixelOffset = (7 - shift);
			int32_t addr = rowStart + pixelOffset;
			for(int i = 0; i < 8; i++) {
				setBit(addr, i, i);
			}
			break;
		}
		case TileFormat::WsBpp4Packed: {
			uint8_t pixelOffset = (7 - shift);
			int32_t addr = (rowStart + (pixelOffset >> 1));
			int offset = pixelOffset & 0x01 ? 0 : 4;
			for(int i = 0; i < 4; i++) {
				setBit(addr, i+offset, i);
			}
			break;
		}
		default:
			throw std::runtime_error("unsupported format");
	}
}
void PpuTools::UpdateViewers(uint16_t scanline, uint16_t cycle)
{
	for(auto updateTiming : _updateTimings) {
		ViewerRefreshConfig cfg = updateTiming.second;
		if(cfg.Cycle == cycle && cfg.Scanline == scanline) {
			if(!_emu->IsDebuggerBlocked()) {
				_emu->GetNotificationManager()->SendNotification(ConsoleNotificationType::ViewerRefresh, (void*)(uint64_t)updateTiming.first);
			}
		}
	}
}
```

## File: Core/Debugger/PpuTools.h
```
#pragma once
#include "pch.h"
#include "Debugger/DebugTypes.h"
#include "Shared/NotificationManager.h"
#include "Shared/Emulator.h"
#include "Shared/ColorUtilities.h"
class Debugger;
struct ViewerRefreshConfig
{
	uint16_t Scanline;
	uint16_t Cycle;
};
enum class SpriteVisibility : uint8_t
{
	Visible = 0,
	Offscreen = 1,
	Disabled = 2
};
enum class NullableBoolean : int8_t
{
	Undefined = -1,
	False = 0,
	True = 1
};
enum class DebugSpritePriority : int8_t
{
	Undefined = -1,
	Number0 = 0,
	Number1 = 1,
	Number2 = 2,
	Number3 = 3,
	Foreground = 4,
	Background = 5
};
enum class DebugSpriteMode : int8_t
{
	Undefined = -1,
	Normal = 0,
	Blending,
	Window,
	Stereoscopic
};
struct DebugSpriteInfo
{
	int32_t TileIndex;
	int32_t TileAddress;
	int32_t PaletteAddress;
	TileFormat Format;
	int16_t SpriteIndex;
	int16_t X;
	int16_t Y;
	int16_t RawX;
	int16_t RawY;
	int16_t Bpp;
	int16_t Palette;
	DebugSpritePriority Priority;
	DebugSpriteMode Mode;
	uint16_t Width;
	uint16_t Height;
	NullableBoolean HorizontalMirror;
	NullableBoolean VerticalMirror;
	NullableBoolean MosaicEnabled;
	NullableBoolean TransformEnabled;
	NullableBoolean DoubleSize;
	int8_t TransformParamIndex;
	SpriteVisibility Visibility;
	bool UseExtendedVram;
	NullableBoolean UseSecondTable;
	uint32_t TileCount;
	uint32_t TileAddresses[8 * 8];
public:
	void Init()
	{
		TileIndex = -1;
		TileAddress = -1;
		PaletteAddress = -1;
		Format = {};
		SpriteIndex = -1;
		X = -1;
		Y = -1;
		RawX = -1;
		RawY = -1;
		Bpp = 2;
		Palette = -1;
		Priority = DebugSpritePriority::Undefined;
		Width = 0;
		Height = 0;
		HorizontalMirror = NullableBoolean::Undefined;
		VerticalMirror = NullableBoolean::Undefined;
		MosaicEnabled = NullableBoolean::Undefined;
		TransformEnabled = NullableBoolean::Undefined;
		Mode = DebugSpriteMode::Undefined;
		DoubleSize = NullableBoolean::Undefined;
		TransformParamIndex = -1;
		Visibility = SpriteVisibility::Offscreen;
		UseExtendedVram = false;
		UseSecondTable = NullableBoolean::Undefined;
		TileCount = 0;
	}
};
enum class TilemapMirroring
{
	None,
	Horizontal,
	Vertical,
	SingleScreenA,
	SingleScreenB,
	FourScreens,
};
struct DebugTilemapInfo
{
	uint32_t Bpp;
	TileFormat Format;
	TilemapMirroring Mirroring;
	uint32_t TileWidth;
	uint32_t TileHeight;
	uint32_t ScrollX;
	uint32_t ScrollWidth;
	uint32_t ScrollY;
	uint32_t ScrollHeight;
	uint32_t RowCount;
	uint32_t ColumnCount;
	uint32_t TilemapAddress;
	uint32_t TilesetAddress;
	int8_t Priority = -1;
};
struct DebugTilemapTileInfo
{
	int32_t Row = -1;
	int32_t Column = -1;
	int32_t Width = -1;
	int32_t Height = -1;
	int32_t TileMapAddress = -1;
	int32_t TileIndex = -1;
	int32_t TileAddress = -1;
	int32_t PixelData = -1;
	int32_t PaletteIndex = -1;
	int32_t PaletteAddress = -1;
	int32_t BasePaletteIndex = -1;
	int32_t AttributeAddress = -1;
	int16_t AttributeData = -1;
	NullableBoolean HorizontalMirroring = NullableBoolean::Undefined;
	NullableBoolean VerticalMirroring = NullableBoolean::Undefined;
	NullableBoolean HighPriority = NullableBoolean::Undefined;
};
struct DebugSpritePreviewInfo
{
	uint32_t Width;
	uint32_t Height;
	uint32_t SpriteCount;
	int32_t CoordOffsetX;
	int32_t CoordOffsetY;
	uint32_t VisibleX;
	uint32_t VisibleY;
	uint32_t VisibleWidth;
	uint32_t VisibleHeight;
	bool WrapBottomToTop;
	bool WrapRightToLeft;
};
enum class RawPaletteFormat
{
	Indexed,
	Rgb555,
	Rgb333,
	Rgb222,
	Rgb444,
	Bgr444
};
struct DebugPaletteInfo
{
	MemoryType PaletteMemType;
	uint32_t PaletteMemOffset;
	bool HasMemType;
	uint32_t ColorCount;
	uint32_t BgColorCount;
	uint32_t SpriteColorCount;
	uint32_t SpritePaletteOffset;
	uint32_t ColorsPerPalette;
	RawPaletteFormat RawFormat;
	uint32_t RawPalette[512];
	uint32_t RgbPalette[512];
};
class PpuTools
{
protected:
	static constexpr uint32_t _spritePreviewSize = 128*128;
	static constexpr uint32_t _grayscaleColorsBpp1[2] = { 0xFF000000, 0xFFFFFFFF };
	static constexpr uint32_t _grayscaleColorsBpp2[4] = { 0xFF000000, 0xFF666666, 0xFFBBBBBB, 0xFFFFFFFF };
	static constexpr uint32_t _grayscaleColorsBpp4[16] = {
		0xFF000000, 0xFF303030, 0xFF404040, 0xFF505050, 0xFF606060, 0xFF707070, 0xFF808080, 0xFF909090,
		0xFF989898, 0xFFA0A0A0, 0xFFAAAAAA, 0xFFBBBBBB, 0xFFCCCCCC, 0xFFDDDDDD, 0xFFEEEEEE, 0xFFFFFFFF
	};
	Emulator* _emu;
	Debugger* _debugger;
	unordered_map<uint32_t, ViewerRefreshConfig> _updateTimings;
	void BlendColors(uint8_t output[4], uint8_t input[4]);
	template<TileFormat format> __forceinline uint32_t GetRgbPixelColor(const uint32_t* colors, uint8_t colorIndex, uint8_t palette);
	template<TileFormat format> __forceinline uint8_t GetTilePixelColor(const uint8_t* ram, const uint32_t ramMask, uint32_t rowStart, uint8_t pixelIndex);
	bool IsTileHidden(MemoryType memType, uint32_t addr, GetTileViewOptions& options);
	uint32_t GetBackgroundColor(TileBackground bgColor, const uint32_t* colors, uint8_t paletteIndex = 0, uint8_t bpp = 0);
	uint32_t GetSpriteBackgroundColor(SpriteBackground bgColor, const uint32_t* colors, bool useDarkerColor);
	void GetSetTilePixel(AddressInfo tileAddress, TileFormat format, int32_t x, int32_t y, int32_t& color, bool forGet);
public:
	PpuTools(Debugger* debugger, Emulator *emu);
	virtual void GetPpuToolsState(BaseState& state) {};
	virtual DebugPaletteInfo GetPaletteInfo(GetPaletteInfoOptions options) = 0;
	void GetTileView(GetTileViewOptions options, uint8_t *source, uint32_t srcSize, const uint32_t* palette, uint32_t *outBuffer);
	virtual DebugTilemapTileInfo GetTilemapTileInfo(uint32_t x, uint32_t y, uint8_t* vram, GetTilemapOptions options, BaseState& baseState, BaseState& ppuToolsState) = 0;
	virtual FrameInfo GetTilemapSize(GetTilemapOptions options, BaseState& state) = 0;
	virtual DebugTilemapInfo GetTilemap(GetTilemapOptions options, BaseState& state, BaseState& ppuToolsState, uint8_t* vram, uint32_t* palette, uint32_t* outBuffer) = 0;
	virtual DebugSpritePreviewInfo GetSpritePreviewInfo(GetSpritePreviewOptions options, BaseState& state, BaseState& ppuToolsState) = 0;
	virtual void GetSpriteList(GetSpritePreviewOptions options, BaseState& baseState, BaseState& ppuToolsState, uint8_t* vram, uint8_t* oamRam, uint32_t* palette, DebugSpriteInfo outBuffer[], uint32_t* spritePreviews, uint32_t* screenPreview) = 0;
	int32_t GetTilePixel(AddressInfo tileAddress, TileFormat format, int32_t x, int32_t y);
	void SetTilePixel(AddressInfo tileAddress, TileFormat format, int32_t x, int32_t y, int32_t color);
	virtual void SetPaletteColor(int32_t colorIndex, uint32_t color) = 0;
	virtual void SetViewerUpdateTiming(uint32_t viewerId, uint16_t scanline, uint16_t cycle);
	void RemoveViewer(uint32_t viewerId);
	void UpdateViewers(uint16_t scanline, uint16_t cycle);
	__forceinline bool HasOpenedViewer()
	{
		return _updateTimings.size() > 0;
	}
	template<TileFormat format>
	void InternalGetTileView(GetTileViewOptions options, uint8_t* source, uint32_t srcSize, const uint32_t* colors, uint32_t* outBuffer);
};
template<TileFormat format> uint32_t PpuTools::GetRgbPixelColor(const uint32_t* colors, uint8_t colorIndex, uint8_t palette)
{
	switch(format) {
		case TileFormat::DirectColor:
			return ColorUtilities::Rgb555ToArgb(
				((((colorIndex & 0x07) << 1) | (palette & 0x01)) << 1) |
				(((colorIndex & 0x38) | ((palette & 0x02) << 1)) << 4) |
				(((colorIndex & 0xC0) | ((palette & 0x04) << 3)) << 7)
			);
		case TileFormat::NesBpp2:
		case TileFormat::Bpp2:
			return colors[palette * 4 + colorIndex];
		case TileFormat::Bpp4:
		case TileFormat::SmsBpp4:
		case TileFormat::GbaBpp4:
		case TileFormat::WsBpp4Packed:
		case TileFormat::PceSpriteBpp4:
		case TileFormat::PceSpriteBpp2Sp01:
		case TileFormat::PceSpriteBpp2Sp23:
		case TileFormat::PceBackgroundBpp2Cg0:
		case TileFormat::PceBackgroundBpp2Cg1:
			return colors[palette * 16 + colorIndex];
		case TileFormat::Bpp8:
		case TileFormat::GbaBpp8:
		case TileFormat::Mode7:
		case TileFormat::Mode7ExtBg:
			return colors[palette * 256 + colorIndex];
		case TileFormat::Mode7DirectColor:
			return ColorUtilities::Rgb555ToArgb(((colorIndex & 0x07) << 2) | ((colorIndex & 0x38) << 4) | ((colorIndex & 0xC0) << 7));
		case TileFormat::SmsSgBpp1:
			return colors[palette * 2 + colorIndex];
		default:
			throw std::runtime_error("unsupported format");
	}
}
template<TileFormat format> __forceinline uint8_t PpuTools::GetTilePixelColor(const uint8_t* ram, const uint32_t ramMask, uint32_t rowStart, uint8_t pixelIndex)
{
	uint8_t shift = (7 - pixelIndex);
	uint8_t color;
	switch(format) {
		case TileFormat::PceSpriteBpp4:
		case TileFormat::PceSpriteBpp2Sp01:
		case TileFormat::PceSpriteBpp2Sp23:
			shift = 15 - pixelIndex;
			if(shift >= 8) {
				shift -= 8;
				rowStart++;
			}
			break;
		default:
			break;
	}
	switch(format) {
		case TileFormat::PceSpriteBpp4:
			color = (((ram[(rowStart + 0) & ramMask] >> shift) & 0x01) << 0);
			color |= (((ram[(rowStart + 32) & ramMask] >> shift) & 0x01) << 1);
			color |= (((ram[(rowStart + 64) & ramMask] >> shift) & 0x01) << 2);
			color |= (((ram[(rowStart + 96) & ramMask] >> shift) & 0x01) << 3);
			return color;
		case TileFormat::PceSpriteBpp2Sp01:
			color = (((ram[(rowStart + 0) & ramMask] >> shift) & 0x01) << 0);
			color |= (((ram[(rowStart + 32) & ramMask] >> shift) & 0x01) << 1);
			return color;
		case TileFormat::PceSpriteBpp2Sp23:
			color = (((ram[(rowStart + 64) & ramMask] >> shift) & 0x01) << 0);
			color |= (((ram[(rowStart + 96) & ramMask] >> shift) & 0x01) << 1);
			return color;
		case TileFormat::PceBackgroundBpp2Cg0:
			color = (((ram[(rowStart + 0) & ramMask] >> shift) & 0x01) << 0);
			color |= (((ram[(rowStart + 1) & ramMask] >> shift) & 0x01) << 1);
			return color;
		case TileFormat::PceBackgroundBpp2Cg1:
			color = (((ram[(rowStart + 16) & ramMask] >> shift) & 0x01) << 0);
			color |= (((ram[(rowStart + 17) & ramMask] >> shift) & 0x01) << 1);
			return color;
		case TileFormat::Bpp2:
			color = (((ram[rowStart & ramMask] >> shift) & 0x01) << 0);
			color |= (((ram[(rowStart + 1) & ramMask] >> shift) & 0x01) << 1);
			return color;
		case TileFormat::NesBpp2:
			color = (((ram[(rowStart + 0) & ramMask] >> shift) & 0x01) << 0);
			color |= (((ram[(rowStart + 8) & ramMask] >> shift) & 0x01) << 1);
			return color;
		case TileFormat::Bpp4:
			color = (((ram[(rowStart + 0) & ramMask] >> shift) & 0x01) << 0);
			color |= (((ram[(rowStart + 1) & ramMask] >> shift) & 0x01) << 1);
			color |= (((ram[(rowStart + 16) & ramMask] >> shift) & 0x01) << 2);
			color |= (((ram[(rowStart + 17) & ramMask] >> shift) & 0x01) << 3);
			return color;
		case TileFormat::Bpp8:
		case TileFormat::DirectColor:
			color = (((ram[(rowStart + 0) & ramMask] >> shift) & 0x01) << 0);
			color |= (((ram[(rowStart + 1) & ramMask] >> shift) & 0x01) << 1);
			color |= (((ram[(rowStart + 16) & ramMask] >> shift) & 0x01) << 2);
			color |= (((ram[(rowStart + 17) & ramMask] >> shift) & 0x01) << 3);
			color |= (((ram[(rowStart + 32) & ramMask] >> shift) & 0x01) << 4);
			color |= (((ram[(rowStart + 33) & ramMask] >> shift) & 0x01) << 5);
			color |= (((ram[(rowStart + 48) & ramMask] >> shift) & 0x01) << 6);
			color |= (((ram[(rowStart + 49) & ramMask] >> shift) & 0x01) << 7);
			return color;
		case TileFormat::Mode7:
		case TileFormat::Mode7DirectColor:
			return ram[(rowStart + pixelIndex * 2 + 1) & ramMask];
		case TileFormat::Mode7ExtBg:
			return ram[(rowStart + pixelIndex * 2 + 1) & ramMask] & 0x7F;
		case TileFormat::SmsBpp4:
			color = (((ram[(rowStart + 0) & ramMask] >> shift) & 0x01) << 0);
			color |= (((ram[(rowStart + 1) & ramMask] >> shift) & 0x01) << 1);
			color |= (((ram[(rowStart + 2) & ramMask] >> shift) & 0x01) << 2);
			color |= (((ram[(rowStart + 3) & ramMask] >> shift) & 0x01) << 3);
			return color;
		case TileFormat::SmsSgBpp1:
			color = ((ram[rowStart & ramMask] >> shift) & 0x01);
			return color;
		case TileFormat::GbaBpp4: {
			uint8_t pixelOffset = (7 - shift);
			uint32_t addr = (rowStart + (pixelOffset >> 1));
			if(addr <= ramMask) {
				if(pixelOffset & 0x01) {
					return ram[addr] >> 4;
				} else {
					return ram[addr] & 0x0F;
				}
			} else {
				return 0;
			}
		}
		case TileFormat::GbaBpp8: {
			uint8_t pixelOffset = (7 - shift);
			uint32_t addr = rowStart + pixelOffset;
			if(addr <= ramMask) {
				return ram[addr];
			} else {
				return 0;
			}
		}
		case TileFormat::WsBpp4Packed: {
			uint8_t pixelOffset = (7 - shift);
			uint32_t addr = (rowStart + (pixelOffset >> 1));
			if(addr <= ramMask) {
				if(pixelOffset & 0x01) {
					return ram[addr] & 0x0F;
				} else {
					return ram[addr] >> 4;
				}
			} else {
				return 0;
			}
		}
		default:
			throw std::runtime_error("unsupported format");
	}
}
```

## File: Core/Debugger/Profiler.cpp
```cpp
#include "pch.h"
#include <limits>
#include "Debugger/Profiler.h"
#include "Debugger/DebugBreakHelper.h"
#include "Debugger/Debugger.h"
#include "Debugger/IDebugger.h"
#include "Debugger/MemoryDumper.h"
#include "Debugger/DebugTypes.h"
#include "Shared/Interfaces/IConsole.h"
static constexpr int32_t ResetFunctionIndex = -1;
Profiler::Profiler(Debugger* debugger, IDebugger* cpuDebugger)
{
	_debugger = debugger;
	_cpuDebugger = cpuDebugger;
	InternalReset();
}
Profiler::~Profiler()
{
}
void Profiler::StackFunction(AddressInfo &addr, StackFrameFlags stackFlag)
{
	if(addr.Address >= 0) {
		uint32_t key = addr.Address | ((uint8_t)addr.Type << 24);
		if(_functions.find(key) == _functions.end()) {
			_functions[key] = ProfiledFunction();
			_functions[key].Address = addr;
		}
		UpdateCycles();
		_stackFlags.push_back(stackFlag);
		_cycleCountStack.push_back(_currentCycleCount);
		_functionStack.push_back(_currentFunction);
		if(_functionStack.size() > 100) {
			_functionStack.pop_front();
			_cycleCountStack.pop_front();
			_stackFlags.pop_front();
		}
		ProfiledFunction& func = _functions[key];
		func.CallCount++;
		func.Flags = stackFlag;
		_currentFunction = key;
		_currentCycleCount = 0;
	}
}
void Profiler::UpdateCycles()
{
	uint64_t masterClock = _cpuDebugger->GetCpuCycleCount(true);
	ProfiledFunction& func = _functions[_currentFunction];
	uint64_t clockGap = masterClock - _prevMasterClock;
	func.ExclusiveCycles += clockGap;
	func.InclusiveCycles += clockGap;
	int32_t len = (int32_t)_functionStack.size();
	for(int32_t i = len - 1; i >= 0; i--) {
		_functions[_functionStack[i]].InclusiveCycles += clockGap;
		if(_stackFlags[i] != StackFrameFlags::None) {
			break;
		}
	}
	_currentCycleCount += clockGap;
	_prevMasterClock = masterClock;
}
void Profiler::UnstackFunction()
{
	if(!_functionStack.empty()) {
		UpdateCycles();
		ProfiledFunction& func = _functions[_currentFunction];
		func.MinCycles = std::min(func.MinCycles, _currentCycleCount);
		func.MaxCycles = std::max(func.MaxCycles, _currentCycleCount);
		_currentFunction = _functionStack.back();
		_functionStack.pop_back();
		_stackFlags.pop_back();
		_currentCycleCount = _cycleCountStack.back() + _currentCycleCount;
		_cycleCountStack.pop_back();
	}
}
void Profiler::Reset()
{
	DebugBreakHelper helper(_debugger);
	InternalReset();
}
void Profiler::ResetState()
{
	_prevMasterClock = _cpuDebugger->GetCpuCycleCount(true);
	_currentCycleCount = 0;
	_functionStack.clear();
	_stackFlags.clear();
	_cycleCountStack.clear();
	_currentFunction = ResetFunctionIndex;
}
void Profiler::InternalReset()
{
	ResetState();
	_functions.clear();
	_functions[ResetFunctionIndex] = ProfiledFunction();
	_functions[ResetFunctionIndex].Address = { ResetFunctionIndex, MemoryType::None };
}
void Profiler::GetProfilerData(ProfiledFunction* profilerData, uint32_t& functionCount)
{
	DebugBreakHelper helper(_debugger);
	UpdateCycles();
	functionCount = 0;
	for(auto& func : _functions) {
		profilerData[functionCount] = func.second;
		functionCount++;
		if(functionCount >= 100000) {
			break;
		}
	}
}
```

## File: Core/Debugger/Profiler.h
```
#pragma once
#include "pch.h"
#include "Debugger/DebugTypes.h"
class Debugger;
class IDebugger;
struct ProfiledFunction
{
	uint64_t ExclusiveCycles = 0;
	uint64_t InclusiveCycles = 0;
	uint64_t CallCount = 0;
	uint64_t MinCycles = UINT64_MAX;
	uint64_t MaxCycles = 0;
	AddressInfo Address = {};
	StackFrameFlags Flags = {};
};
class Profiler
{
private:
	Debugger* _debugger = nullptr;
	IDebugger* _cpuDebugger = nullptr;
	unordered_map<int32_t, ProfiledFunction> _functions;
	deque<int32_t> _functionStack;
	deque<StackFrameFlags> _stackFlags;
	deque<uint64_t> _cycleCountStack;
	uint64_t _currentCycleCount = 0;
	uint64_t _prevMasterClock = 0;
	int32_t _currentFunction = -1;
	void InternalReset();
	void UpdateCycles();
public:
	Profiler(Debugger* debugger, IDebugger* cpuDebugger);
	~Profiler();
	void StackFunction(AddressInfo& addr, StackFrameFlags stackFlag);
	void UnstackFunction();
	void Reset();
	void ResetState();
	void GetProfilerData(ProfiledFunction* profilerData, uint32_t& functionCount);
};
```

## File: Core/Debugger/ScriptHost.cpp
```cpp
#include "pch.h"
#include "Debugger/ScriptHost.h"
#include "Debugger/ScriptingContext.h"
#include "Debugger/ScriptingContext.h"
#include "Shared/EventType.h"
#include "Shared/MemoryOperationType.h"
ScriptHost::ScriptHost(int scriptId)
{
	_scriptId = scriptId;
}
int ScriptHost::GetScriptId()
{
	return _scriptId;
}
string ScriptHost::GetLog()
{
	shared_ptr<ScriptingContext> context = _context.lock();
	return context ? context->GetLog() : "";
}
bool ScriptHost::LoadScript(string scriptName, string path, string scriptContent, Debugger* debugger)
{
	_context.reset(new ScriptingContext(debugger));
	if(!_context->LoadScript(scriptName, path, scriptContent, debugger)) {
		return false;
	}
	return true;
}
void ScriptHost::ProcessEvent(EventType eventType, CpuType cpuType)
{
	_context->CallEventCallback(eventType, cpuType);
}
```

## File: Core/Debugger/ScriptHost.h
```
#pragma once
#include "pch.h"
#include "Debugger/DebugTypes.h"
#include "Debugger/ScriptingContext.h"
#include "Shared/EventType.h"
#include "Shared/MemoryOperationType.h"
#include "Utilities/safe_ptr.h"
class Debugger;
class ScriptHost
{
private:
	safe_ptr<ScriptingContext> _context;
	int _scriptId = 0;
public:
	ScriptHost(int scriptId);
	int GetScriptId();
	string GetLog();
	bool LoadScript(string scriptName, string path, string scriptContent, Debugger* debugger);
	void RefreshMemoryCallbackFlags() { _context->RefreshMemoryCallbackFlags(); }
	void ProcessEvent(EventType eventType, CpuType cpuType);
	template<typename T>
	__forceinline void CallMemoryCallback(AddressInfo relAddr, T& value, CallbackType callbackType, CpuType cpuType)
	{
		_context->CallMemoryCallback(relAddr, value, callbackType, cpuType);
	}
};
```

## File: Core/Debugger/ScriptingContext.cpp
```cpp
#include "pch.h"
#include <algorithm>
#include <regex>
#include "Lua/lua.hpp"
#include "Lua/luasocket.hpp"
#include "Debugger/ScriptingContext.h"
#include "Debugger/LuaApi.h"
#include "Debugger/LuaCallHelper.h"
#include "Debugger/DebugTypes.h"
#include "Debugger/Debugger.h"
#include "Debugger/ScriptManager.h"
#include "Shared/Emulator.h"
#include "Shared/EmuSettings.h"
#include "Shared/EventType.h"
#include "Shared/SaveStateManager.h"
#include "Utilities/magic_enum.hpp"
#include "Utilities/StringUtilities.h"
ScriptingContext* ScriptingContext::_context = nullptr;
ScriptingContext::ScriptingContext(Debugger *debugger)
{
	_debugger = debugger;
	_settings = debugger->GetEmulator()->GetSettings();
	_defaultCpuType = debugger->GetEmulator()->GetCpuTypes()[0];
	_defaultMemType = DebugUtilities::GetCpuMemoryType(_defaultCpuType);
}
ScriptingContext::~ScriptingContext()
{
	if(_lua) {
		std::unordered_set<int> references;
		for(int i = (int)CallbackType::Read; i <= (int)CallbackType::Exec; i++) {
			for(MemoryCallback& callback : _callbacks[i]) {
				references.emplace(callback.Reference);
			}
		}
		for(auto& entry : magic_enum::enum_entries<EventType>()) {
			for(int& ref : _eventCallbacks[(int)entry.first]) {
				references.emplace(ref);
			}
		}
		for(const int& ref : references) {
			luaL_unref(_lua, LUA_REGISTRYINDEX, ref);
		}
		lua_close(_lua);
		_lua = nullptr;
	}
}
bool ScriptingContext::LoadScript(string scriptName, string path, string scriptContent, Debugger* debugger)
{
	_scriptName = scriptName;
	int iErr = 0;
	_lua = luaL_newstate();
	_context = this;
	LuaApi::SetContext(this);
	EmuSettings* settings = debugger->GetEmulator()->GetSettings();
	bool allowIoOsAccess = settings->GetDebugConfig().ScriptAllowIoOsAccess;
	LuaOpenLibs(_lua, allowIoOsAccess);
	SANDBOX_ALLOW_LOADFILE = allowIoOsAccess ? 1 : 0;
	if(allowIoOsAccess && settings->GetDebugConfig().ScriptAllowNetworkAccess) {
		lua_getglobal(_lua, "package");
		lua_getfield(_lua, -1, "preload");
		lua_pushcfunction(_lua, luaopen_socket_core);
		lua_setfield(_lua, -2, "socket.core");
		lua_pushcfunction(_lua, luaopen_mime_core);
		lua_setfield(_lua, -2, "mime.core");
		lua_pop(_lua, 2);
	}
	if(allowIoOsAccess) {
		std::regex r("\\\\");
		path = std::regex_replace(path, r, "\\\\");
		string cmd = "package.path = package.path .. ';" + path + "?.lua'";
		luaL_dostring(_lua, cmd.c_str());
	}
	luaL_requiref(_lua, "emu", LuaApi::GetLibrary, 1);
	Log("Loading script...");
	if((iErr = luaL_loadbufferx(_lua, scriptContent.c_str(), scriptContent.size(), ("@" + scriptName).c_str(), nullptr)) == 0) {
		_timer.Reset();
		lua_setwatchdogtimer(_lua, ScriptingContext::ExecutionCountHook, 1000);
		if((iErr = lua_pcall(_lua, 0, LUA_MULTRET, 0)) == 0) {
			Log("Script loaded successfully.");
			_initDone = true;
			return true;
		}
	}
	if(lua_isstring(_lua, -1)) {
		ProcessLuaError();
	}
	return false;
}
void ScriptingContext::ProcessLuaError()
{
	string errorMsg = lua_tostring(_lua, -1);
	if(StringUtilities::Contains(errorMsg, "attempt to call a nil value (global 'require')") || StringUtilities::Contains(errorMsg, "attempt to index a nil value (global 'os')") || StringUtilities::Contains(errorMsg, "attempt to index a nil value (global 'io')")) {
		Log("I/O and OS libraries are disabled by default for security.\nYou can enable them here:\nScript->Settings->Script Window->Restrictions->Allow access to I/O and OS functions.");
	} else if(StringUtilities::Contains(errorMsg, "module 'socket.core' not found")) {
		Log("Lua sockets are disabled by default for security.\nYou can enable them here:\nScript->Settings->Script Window->Restrictions->Allow network access.");
	} else {
		Log(errorMsg);
	}
	lua_pop(_lua, 1);
}
void ScriptingContext::ExecutionCountHook(lua_State* lua)
{
	uint32_t timeout = _context->_settings->GetDebugConfig().ScriptTimeout;
	if(_context->_timer.GetElapsedMS() > timeout * 1000) {
		luaL_error(lua, (std::string("Maximum execution time (") + std::to_string(timeout) + " seconds) exceeded.").c_str());
	}
	lua_setwatchdogtimer(lua, ScriptingContext::ExecutionCountHook, 1000);
}
void ScriptingContext::LuaOpenLibs(lua_State* L, bool allowIoOsAccess)
{
	constexpr luaL_Reg loadedlibs[] = {
	  {"_G", luaopen_base},
	  {LUA_LOADLIBNAME, luaopen_package},
	  {LUA_COLIBNAME, luaopen_coroutine},
	  {LUA_TABLIBNAME, luaopen_table},
	  {LUA_IOLIBNAME, luaopen_io},
	  {LUA_OSLIBNAME, luaopen_os},
	  {LUA_STRLIBNAME, luaopen_string},
	  {LUA_MATHLIBNAME, luaopen_math},
	  {LUA_UTF8LIBNAME, luaopen_utf8},
	  {LUA_DBLIBNAME, luaopen_debug},
	  {NULL, NULL}
	};
	const luaL_Reg* lib;
	for(lib = loadedlibs; lib->func; lib++) {
		if(!allowIoOsAccess) {
			if(strcmp(lib->name, LUA_IOLIBNAME) == 0 || strcmp(lib->name, LUA_OSLIBNAME) == 0 || strcmp(lib->name, LUA_LOADLIBNAME) == 0) {
				continue;
			}
		}
		luaL_requiref(L, lib->name, lib->func, 1);
		lua_pop(L, 1);
	}
}
void ScriptingContext::Log(string message)
{
	auto lock = _logLock.AcquireSafe();
	_logRows.push_back(message);
	if(_logRows.size() > 500) {
		_logRows.pop_front();
	}
}
string ScriptingContext::GetLog()
{
	auto lock = _logLock.AcquireSafe();
	stringstream ss;
	for(string &msg : _logRows) {
		ss << msg << "\n";
	}
	return ss.str();
}
Debugger* ScriptingContext::GetDebugger()
{
	return _debugger;
}
string ScriptingContext::GetScriptName()
{
	return _scriptName;
}
template<typename T>
void ScriptingContext::CallMemoryCallback(AddressInfo relAddr, T &value, CallbackType type, CpuType cpuType)
{
	_allowSaveState = type == CallbackType::Exec && cpuType == _defaultCpuType;
	InternalCallMemoryCallback(relAddr, value, type, cpuType);
	_allowSaveState = false;
}
bool ScriptingContext::CheckInitDone()
{
	return _initDone;
}
bool ScriptingContext::IsSaveStateAllowed()
{
	return _allowSaveState;
}
void ScriptingContext::RegisterMemoryCallback(CallbackType type, int startAddr, int endAddr, MemoryType memType, CpuType cpuType, int reference)
{
	if(endAddr < startAddr) {
		return;
	}
	MemoryCallback callback;
	callback.StartAddress = (uint32_t)startAddr;
	callback.EndAddress = (uint32_t)endAddr;
	callback.Reference = reference;
	callback.Cpu = cpuType;
	callback.MemType = memType;
	if(DebugUtilities::IsPpuMemory(memType)) {
		_debugger->GetScriptManager()->EnablePpuMemoryCallbacks();
	} else {
		_debugger->GetScriptManager()->EnableCpuMemoryCallbacks();
	}
	_callbacks[(int)type].push_back(callback);
}
void ScriptingContext::RefreshMemoryCallbackFlags()
{
	for(int i = (int)CallbackType::Read; i <= (int)CallbackType::Exec; i++) {
		for(size_t j = 0, len = _callbacks[i].size(); j < len; j++) {
			if(DebugUtilities::IsPpuMemory(_callbacks[i][j].MemType)) {
				_debugger->GetScriptManager()->EnablePpuMemoryCallbacks();
			} else {
				_debugger->GetScriptManager()->EnableCpuMemoryCallbacks();
			}
		}
	}
}
void ScriptingContext::UnregisterMemoryCallback(CallbackType type, int startAddr, int endAddr, MemoryType memType, CpuType cpuType, int reference)
{
	if(endAddr < startAddr) {
		return;
	}
	for(size_t i = 0; i < _callbacks[(int)type].size(); i++) {
		MemoryCallback &callback = _callbacks[(int)type][i];
		bool isMatch = (
			callback.Reference == reference &&
			callback.Cpu == cpuType &&
			callback.MemType == memType &&
			(int)callback.StartAddress == startAddr &&
			(int)callback.EndAddress == endAddr
		);
		if(isMatch) {
			_callbacks[(int)type].erase(_callbacks[(int)type].begin() + i);
			break;
		}
	}
	luaL_unref(_lua, LUA_REGISTRYINDEX, reference);
}
void ScriptingContext::RegisterEventCallback(EventType type, int reference)
{
	_eventCallbacks[(int)type].push_back(reference);
}
void ScriptingContext::UnregisterEventCallback(EventType type, int reference)
{
	vector<int> &callbacks = _eventCallbacks[(int)type];
	callbacks.erase(std::remove(callbacks.begin(), callbacks.end(), reference), callbacks.end());
	luaL_unref(_lua, LUA_REGISTRYINDEX, reference);
}
bool ScriptingContext::IsAddressMatch(MemoryCallback& callback, AddressInfo addr)
{
	return addr.Type == callback.MemType && addr.Address >= (int32_t)callback.StartAddress && addr.Address <= (int32_t)callback.EndAddress;
}
template<typename T>
void ScriptingContext::InternalCallMemoryCallback(AddressInfo relAddr, T& value, CallbackType type, CpuType cpuType)
{
	if(_callbacks[(int)type].empty()) {
		return;
	}
	_context = this;
	bool needTimerReset = true;
	lua_setwatchdogtimer(_lua, ScriptingContext::ExecutionCountHook, 1000);
	LuaApi::SetContext(this);
	for(MemoryCallback& callback : _callbacks[(int)type]) {
		if(callback.Cpu != cpuType) {
			continue;
		}
		if(DebugUtilities::IsRelativeMemory(callback.MemType)) {
			if(!IsAddressMatch(callback, relAddr)) {
				continue;
			}
		} else {
			if(!IsAddressMatch(callback, _debugger->GetAbsoluteAddress(relAddr))) {
				continue;
			}
		}
		if(needTimerReset) {
			_timer.Reset();
			needTimerReset = false;
		}
		int top = lua_gettop(_lua);
		lua_rawgeti(_lua, LUA_REGISTRYINDEX, callback.Reference);
		lua_pushinteger(_lua, relAddr.Address);
		lua_pushinteger(_lua, value);
		if(lua_pcall(_lua, 2, LUA_MULTRET, 0) != 0) {
			ProcessLuaError();
		} else {
			int returnParamCount = lua_gettop(_lua) - top;
			if(returnParamCount && lua_isinteger(_lua, -1)) {
				int newValue = (int)lua_tointeger(_lua, -1);
				value = (T)newValue;
			}
			lua_settop(_lua, top);
		}
	}
}
int ScriptingContext::CallEventCallback(EventType type, CpuType cpuType)
{
	if(_eventCallbacks[(int)type].empty()) {
		return 0;
	}
	_timer.Reset();
	_context = this;
	lua_setwatchdogtimer(_lua, ScriptingContext::ExecutionCountHook, 1000);
	LuaApi::SetContext(this);
	LuaCallHelper l(_lua);
	for(int& ref : _eventCallbacks[(int)type]) {
		lua_rawgeti(_lua, LUA_REGISTRYINDEX, ref);
		lua_pushinteger(_lua, (int)cpuType);
		if(lua_pcall(_lua, 1, 0, 0) != 0) {
			ProcessLuaError();
		}
	}
	return l.ReturnCount();
}
template void ScriptingContext::CallMemoryCallback<uint8_t>(AddressInfo relAddr, uint8_t& value, CallbackType type, CpuType cpuType);
template void ScriptingContext::CallMemoryCallback<uint16_t>(AddressInfo relAddr, uint16_t& value, CallbackType type, CpuType cpuType);
template void ScriptingContext::CallMemoryCallback<uint32_t>(AddressInfo relAddr, uint32_t& value, CallbackType type, CpuType cpuType);
```

## File: Core/Debugger/ScriptingContext.h
```
#pragma once
#include "pch.h"
#include <deque>
#include "Utilities/SimpleLock.h"
#include "Utilities/Timer.h"
#include "Debugger/DebugTypes.h"
#include "Shared/EventType.h"
class Debugger;
struct lua_State;
enum class CallbackType
{
	Read = 0,
	Write = 1,
	Exec = 2
};
struct MemoryCallback
{
	uint32_t StartAddress;
	uint32_t EndAddress;
	CpuType Cpu;
	MemoryType MemType;
	int Reference;
};
enum class ScriptDrawSurface
{
	ConsoleScreen,
	ScriptHud
};
class ScriptingContext
{
private:
	static ScriptingContext* _context;
	lua_State* _lua = nullptr;
	Timer _timer;
	EmuSettings* _settings = nullptr;
	deque<string> _logRows;
	SimpleLock _logLock;
	bool _allowSaveState = false;
	Debugger* _debugger = nullptr;
	CpuType _defaultCpuType = {};
	MemoryType _defaultMemType = {};
	ScriptDrawSurface _drawSurface = ScriptDrawSurface::ConsoleScreen;
	static void ExecutionCountHook(lua_State* lua);
	void LuaOpenLibs(lua_State* L, bool allowIoOsAccess);
	void ProcessLuaError();
protected:
	string _scriptName;
	bool _initDone = false;
	vector<MemoryCallback> _callbacks[3];
	vector<int> _eventCallbacks[(int)EventType::LastValue + 1];
	template<typename T> void InternalCallMemoryCallback(AddressInfo relAddr, T& value, CallbackType type, CpuType cpuType);
	bool IsAddressMatch(MemoryCallback& callback, AddressInfo addr);
public:
	ScriptingContext(Debugger* debugger);
	~ScriptingContext();
	bool LoadScript(string scriptName, string path, string scriptContent, Debugger* debugger);
	void Log(string message);
	string GetLog();
	Debugger* GetDebugger();
	string GetScriptName();
	void SetDrawSurface(ScriptDrawSurface surface) { _drawSurface = surface; }
	ScriptDrawSurface GetDrawSurface() { return _drawSurface; }
	template<typename T> void CallMemoryCallback(AddressInfo relAddr, T& value, CallbackType type, CpuType cpuType);
	int CallEventCallback(EventType type, CpuType cpuType);
	bool CheckInitDone();
	bool IsSaveStateAllowed();
	CpuType GetDefaultCpuType() { return _defaultCpuType; }
	MemoryType GetDefaultMemType() { return _defaultMemType; }
	void RefreshMemoryCallbackFlags();
	void RegisterMemoryCallback(CallbackType type, int startAddr, int endAddr, MemoryType memType, CpuType cpuType, int reference);
	void UnregisterMemoryCallback(CallbackType type, int startAddr, int endAddr, MemoryType memType, CpuType cpuType, int reference);
	void RegisterEventCallback(EventType type, int reference);
	void UnregisterEventCallback(EventType type, int reference);
};
```

## File: Core/Debugger/ScriptManager.cpp
```cpp
#include "pch.h"
#include "Debugger/ScriptManager.h"
#include "Debugger/ScriptHost.h"
#include "Debugger/DebugBreakHelper.h"
#include "Debugger/Debugger.h"
#include "Shared/Emulator.h"
#include "Shared/Video/DebugHud.h"
#include "Shared/MemoryOperationType.h"
ScriptManager::ScriptManager(Debugger* debugger)
{
	_debugger = debugger;
	_hasScript = false;
	_nextScriptId = 1;
}
ScriptManager::~ScriptManager()
{
	_debugger->GetEmulator()->GetDebugHud()->ClearScreen();
	_debugger->GetEmulator()->GetScriptHud()->ClearScreen();
}
int ScriptManager::LoadScript(string name, string path, string content, int32_t scriptId)
{
	DebugBreakHelper helper(_debugger);
	auto lock = _scriptLock.AcquireSafe();
	if(scriptId < 0) {
		unique_ptr<ScriptHost> script(new ScriptHost(_nextScriptId++));
		script->LoadScript(name, path, content, _debugger);
		scriptId = script->GetScriptId();
		_scripts.push_back(std::move(script));
		_hasScript = true;
		return scriptId;
	} else {
		auto result = std::find_if(_scripts.begin(), _scripts.end(), [=](unique_ptr<ScriptHost> &script) {
			return script->GetScriptId() == scriptId;
		});
		if(result != _scripts.end()) {
			(*result)->ProcessEvent(EventType::ScriptEnded, _debugger->GetMainCpuType());
			(*result)->LoadScript(name, path, content, _debugger);
			RefreshMemoryCallbackFlags();
			return scriptId;
		}
	}
	return -1;
}
void ScriptManager::RemoveScript(int32_t scriptId)
{
	DebugBreakHelper helper(_debugger);
	auto lock = _scriptLock.AcquireSafe();
	_scripts.erase(std::remove_if(_scripts.begin(), _scripts.end(), [=](const unique_ptr<ScriptHost>& script) {
		if(script->GetScriptId() == scriptId) {
			script->ProcessEvent(EventType::ScriptEnded, _debugger->GetMainCpuType());
			_debugger->GetEmulator()->GetDebugHud()->ClearScreen();
			_debugger->GetEmulator()->GetScriptHud()->ClearScreen();
			return true;
		}
		return false;
	}), _scripts.end());
	RefreshMemoryCallbackFlags();
	_hasScript = _scripts.size() > 0;
}
void ScriptManager::RefreshMemoryCallbackFlags()
{
	_isPpuMemoryCallbackEnabled = false;
	_isCpuMemoryCallbackEnabled = false;
	for(unique_ptr<ScriptHost>& script : _scripts) {
		script->RefreshMemoryCallbackFlags();
	}
}
string ScriptManager::GetScriptLog(int32_t scriptId)
{
	auto lock = _scriptLock.AcquireSafe();
	for(unique_ptr<ScriptHost> &script : _scripts) {
		if(script->GetScriptId() == scriptId) {
			return script->GetLog();
		}
	}
	return "";
}
void ScriptManager::ProcessEvent(EventType type, CpuType cpuType)
{
	for(unique_ptr<ScriptHost> &script : _scripts) {
		script->ProcessEvent(type, cpuType);
	}
}
```

## File: Core/Debugger/ScriptManager.h
```
#pragma once
#include "pch.h"
#include "Debugger/DebugTypes.h"
#include "Debugger/ScriptHost.h"
#include "Utilities/SimpleLock.h"
#include "Shared/EventType.h"
class Debugger;
enum class MemoryOperationType;
class ScriptManager
{
private:
	Debugger *_debugger = nullptr;
	bool _hasScript = false;
	SimpleLock _scriptLock;
	int _nextScriptId = 0;
	bool _isCpuMemoryCallbackEnabled = false;
	bool _isPpuMemoryCallbackEnabled = false;
	vector<unique_ptr<ScriptHost>> _scripts;
	void RefreshMemoryCallbackFlags();
public:
	ScriptManager(Debugger *debugger);
	~ScriptManager();
	__forceinline bool HasScript() { return _hasScript; }
	int32_t LoadScript(string name, string path, string content, int32_t scriptId);
	void RemoveScript(int32_t scriptId);
	string GetScriptLog(int32_t scriptId);
	void ProcessEvent(EventType type, CpuType cpuType);
	void EnableCpuMemoryCallbacks() { _isCpuMemoryCallbackEnabled = true; }
	bool HasCpuMemoryCallbacks() { return _scripts.size() && _isCpuMemoryCallbackEnabled; }
	void EnablePpuMemoryCallbacks() { _isPpuMemoryCallbackEnabled = true; }
	bool HasPpuMemoryCallbacks() { return _scripts.size() && _isPpuMemoryCallbackEnabled; }
	template<typename T>
	__forceinline void ProcessMemoryOperation(AddressInfo relAddr, T& value, MemoryOperationType type, CpuType cpuType, bool processExec)
	{
		switch(type) {
			case MemoryOperationType::Read:
			case MemoryOperationType::DmaRead:
			case MemoryOperationType::PpuRenderingRead:
			case MemoryOperationType::DummyRead:
				for(unique_ptr<ScriptHost>& script : _scripts) {
					script->CallMemoryCallback(relAddr, value, CallbackType::Read, cpuType);
				}
				break;
			case MemoryOperationType::Write:
			case MemoryOperationType::DummyWrite:
			case MemoryOperationType::DmaWrite:
				for(unique_ptr<ScriptHost>& script : _scripts) {
					script->CallMemoryCallback(relAddr, value, CallbackType::Write, cpuType);
				}
				break;
			case MemoryOperationType::ExecOpCode:
			case MemoryOperationType::ExecOperand:
				if(processExec) {
					for(unique_ptr<ScriptHost>& script : _scripts) {
						script->CallMemoryCallback(relAddr, value, CallbackType::Exec, cpuType);
					}
				}
				break;
			default: break;
		}
	}
};
```

## File: Core/Debugger/StepBackManager.cpp
```cpp
#include "pch.h"
#include "Debugger/StepBackManager.h"
#include "Debugger/IDebugger.h"
#include "Shared/Emulator.h"
#include "Shared/SaveStateManager.h"
#include "Shared/NotificationManager.h"
#include "Shared/RewindManager.h"
StepBackManager::StepBackManager(Emulator* emu, IDebugger* debugger)
{
	_emu = emu;
	_rewindManager = emu->GetRewindManager();
	_debugger = debugger;
}
void StepBackManager::StepBack(StepBackType type)
{
	if(!_active) {
		StepBackConfig cfg = _debugger->GetStepBackConfig();
		int64_t target = 0;
		switch(type) {
			default: case StepBackType::Instruction: target = cfg.CurrentCycle; break;
			case StepBackType::Scanline: target = (int64_t)cfg.CurrentCycle - cfg.CyclesPerScanline; break;
			case StepBackType::Frame: target = (int64_t)cfg.CurrentCycle - cfg.CyclesPerFrame; break;
		}
		_targetClock = (uint64_t)std::max<int64_t>(0, target);
		_active = true;
		_allowRetry = true;
		_stateClockLimit = StepBackManager::DefaultClockLimit;
	}
}
bool StepBackManager::CheckStepBack()
{
	if(!_active) {
		return false;
	}
	uint64_t clock = _debugger->GetStepBackConfig().CurrentCycle;
	if(!_rewindManager->IsStepBack()) {
		if(_cache.size() > 1) {
			if(_cache.back().Clock == _targetClock) {
				_cache.pop_back();
				if(_cache.size()) {
					_emu->Deserialize(_cache.back().SaveState, SaveStateManager::FileFormatVersion, true, std::nullopt, false);
					_emu->GetRewindManager()->StopRewinding(true, true);
					_active = false;
					_prevClock = clock;
					return true;
				}
			} else {
				_cache.clear();
			}
		}
		_cache.clear();
		_rewindManager->StartRewinding(true);
		clock = _debugger->GetStepBackConfig().CurrentCycle;
	}
	if(clock < _targetClock && _targetClock - clock < _stateClockLimit) {
		_cache.push_back(StepBackCacheEntry());
		_cache.back().Clock = clock;
		_emu->Serialize(_cache.back().SaveState, true, 0);
	}
	if(clock >= _targetClock) {
		if(_cache.size() > 0) {
			_emu->Deserialize(_cache.back().SaveState, SaveStateManager::FileFormatVersion, true, std::nullopt, false);
			_rewindManager->StopRewinding(true, true);
		} else if(_allowRetry && clock > _prevClock && (clock - _prevClock) > StepBackManager::DefaultClockLimit) {
			_rewindManager->StopRewinding(true);
			_rewindManager->StartRewinding(true);
			_stateClockLimit = (clock - _prevClock) + StepBackManager::DefaultClockLimit;
			_allowRetry = false;
			return false;
		} else {
			_rewindManager->StopRewinding(true);
		}
		_active = false;
		_prevClock = clock;
		return true;
	}
	_prevClock = clock;
	return false;
}
```

## File: Core/Debugger/StepBackManager.h
```
#pragma once
#include "pch.h"
#include "Shared/RewindManager.h"
class Emulator;
class IDebugger;
struct StepBackCacheEntry
{
	stringstream SaveState;
	uint64_t Clock;
};
struct StepBackConfig
{
	uint64_t CurrentCycle;
	uint32_t CyclesPerScanline;
	uint32_t CyclesPerFrame;
};
enum class StepBackType
{
	Instruction,
	Scanline,
	Frame
};
class StepBackManager
{
private:
	static constexpr uint64_t DefaultClockLimit = 600;
	Emulator* _emu = nullptr;
	RewindManager* _rewindManager = nullptr;
	IDebugger* _debugger = nullptr;
	vector<StepBackCacheEntry> _cache;
	uint64_t _targetClock = 0;
	uint64_t _prevClock = 0;
	bool _active = false;
	bool _allowRetry = false;
	uint64_t _stateClockLimit = StepBackManager::DefaultClockLimit;
public:
	StepBackManager(Emulator* emu, IDebugger* debugger);
	void StepBack(StepBackType type);
	bool CheckStepBack();
	void ResetCache() { _cache.clear(); }
	bool IsRewinding() { return _active || _rewindManager->IsRewinding(); }
};
```

## File: Core/Debugger/TraceLogFileSaver.h
```
#pragma once
#include "pch.h"
class TraceLogFileSaver
{
private:
	bool _enabled = false;
	string _outputFilepath;
	string _outputBuffer;
	ofstream _outputFile;
public:
	~TraceLogFileSaver()
	{
		StopLogging();
	}
	void StartLogging(string filename)
	{
		_outputBuffer.clear();
		_outputFile.open(filename, ios::out | ios::binary);
		_enabled = true;
	}
	void StopLogging()
	{
		if(_enabled) {
			_enabled = false;
			if(_outputFile) {
				if(!_outputBuffer.empty()) {
					_outputFile << _outputBuffer;
				}
				_outputFile.close();
			}
		}
	}
	__forceinline bool IsEnabled() { return _enabled; }
	void Log(string& log)
	{
		_outputBuffer += log + '\n';
		if(_outputBuffer.size() > 32768) {
			_outputFile << _outputBuffer;
			_outputBuffer.clear();
		}
	}
};
```

## File: Core/Netplay/ClientConnectionData.h
```
#pragma once
#include "pch.h"
class ClientConnectionData
{
public:
	string Host;
	uint16_t Port = 0;
	string Password;
	bool Spectator = false;
	ClientConnectionData() {}
	ClientConnectionData(string host, uint16_t port, string password, bool spectator) :
		Host(host), Port(port), Password(password), Spectator(spectator)
	{
	}
	~ClientConnectionData()
	{
	}
};
```

## File: Core/Netplay/ForceDisconnectMessage.h
```
#pragma once
#include "pch.h"
#include "Netplay/NetMessage.h"
#include "Shared/MessageManager.h"
#include "Utilities/FolderUtilities.h"
class ForceDisconnectMessage : public NetMessage
{
private:
	string _disconnectMessage;
protected:
	void Serialize(Serializer &s) override
	{
		SV(_disconnectMessage);
	}
public:
	ForceDisconnectMessage(void* buffer, uint32_t length) : NetMessage(buffer, length) { }
	ForceDisconnectMessage(string message) : NetMessage(MessageType::ForceDisconnect)
	{
		_disconnectMessage = message;
	}
	string GetMessage()
	{
		return _disconnectMessage;
	}
};
```

## File: Core/Netplay/GameClient.cpp
```cpp
#include "pch.h"
#include "Netplay/GameClient.h"
#include "Netplay/ClientConnectionData.h"
#include "Netplay/GameClientConnection.h"
#include "Shared/MessageManager.h"
#include "Shared/Emulator.h"
#include "Shared/NotificationManager.h"
#include "Utilities/Socket.h"
GameClient::GameClient(Emulator* emu)
{
	_emu = emu;
	_stop = false;
	_connected = false;
}
GameClient::~GameClient()
{
}
bool GameClient::Connected()
{
	return _connected;
}
void GameClient::Connect(ClientConnectionData &connectionData)
{
	Disconnect();
	_stop = false;
	unique_ptr<Socket> socket(new Socket());
	if(socket->Connect(connectionData.Host.c_str(), connectionData.Port)) {
		_connection.reset(new GameClientConnection(_emu, std::move(socket), connectionData));
		_connected = true;
		_clientThread.reset(new thread(&GameClient::Exec, this));
		_emu->GetNotificationManager()->RegisterNotificationListener(shared_from_this());
	} else {
		MessageManager::DisplayMessage("NetPlay", "CouldNotConnect");
		_connected = false;
	}
}
void GameClient::Disconnect()
{
	_stop = true;
	_connected = false;
	if(_clientThread) {
		_clientThread->join();
		_clientThread.reset();
	}
}
void GameClient::Exec()
{
	if(_connected) {
		while(!_stop) {
			if(!_connection->ConnectionError()) {
				_connection->ProcessMessages();
				_connection->SendInput();
			} else {
				break;
			}
			std::this_thread::sleep_for(std::chrono::duration<int, std::milli>(1));
		}
		_connected = false;
		_connection->Shutdown();
	}
}
void GameClient::ProcessNotification(ConsoleNotificationType type, void* parameter)
{
	if(!_connected) {
		return;
	}
	if(type == ConsoleNotificationType::GameLoaded &&
		std::this_thread::get_id() != _clientThread->get_id() &&
		!_emu->IsEmulationThread()
	) {
		Disconnect();
	}
	if(_connection) {
		_connection->ProcessNotification(type, parameter);
	}
}
void GameClient::SelectController(NetplayControllerInfo controller)
{
	if(_connection) {
		_connection->SelectController(controller);
	}
}
vector<NetplayControllerUsageInfo> GameClient::GetControllerList()
{
	return _connection ? _connection->GetControllerList() : vector<NetplayControllerUsageInfo>();
}
NetplayControllerInfo GameClient::GetControllerPort()
{
	return _connection ? _connection->GetControllerPort() : NetplayControllerInfo { GameConnection::SpectatorPort, 0 };
}
```

## File: Core/Netplay/GameClient.h
```
#pragma once
#include "pch.h"
#include "Shared/Interfaces/INotificationListener.h"
#include "Netplay/NetplayTypes.h"
class Socket;
class GameClientConnection;
class ClientConnectionData;
class Emulator;
class GameClient : public INotificationListener, public std::enable_shared_from_this<GameClient>
{
private:
	Emulator* _emu;
	unique_ptr<thread> _clientThread;
	unique_ptr<GameClientConnection> _connection;
	atomic<bool> _stop;
	atomic<bool> _connected;
	void Exec();
public:
	GameClient(Emulator* emu);
	virtual ~GameClient();
	bool Connected();
	void Connect(ClientConnectionData &connectionData);
	void Disconnect();
	void SelectController(NetplayControllerInfo controller);
	NetplayControllerInfo GetControllerPort();
	vector<NetplayControllerUsageInfo> GetControllerList();
	void ProcessNotification(ConsoleNotificationType type, void* parameter) override;
};
```

## File: Core/Netplay/GameClientConnection.cpp
```cpp
#include "pch.h"
#include "Netplay/GameClientConnection.h"
#include "Netplay/HandShakeMessage.h"
#include "Netplay/InputDataMessage.h"
#include "Netplay/MovieDataMessage.h"
#include "Netplay/GameInformationMessage.h"
#include "Netplay/SaveStateMessage.h"
#include "Netplay/ClientConnectionData.h"
#include "Netplay/SelectControllerMessage.h"
#include "Netplay/PlayerListMessage.h"
#include "Netplay/ForceDisconnectMessage.h"
#include "Netplay/ServerInformationMessage.h"
#include "Netplay/GameServer.h"
#include "Shared/BaseControlManager.h"
#include "Shared/Emulator.h"
#include "Shared/EmuSettings.h"
#include "Shared/NotificationManager.h"
#include "Shared/RomFinder.h"
GameClientConnection::GameClientConnection(Emulator* emu, unique_ptr<Socket> socket, ClientConnectionData &connectionData) : GameConnection(emu, std::move(socket))
{
	_connectionData = connectionData;
	_shutdown = false;
	_enableControllers = false;
	_minimumQueueSize = 3;
	_controllerType = ControllerType::None;
	MessageManager::DisplayMessage("NetPlay", "ConnectedToServer");
}
GameClientConnection::~GameClientConnection()
{
	Shutdown();
}
void GameClientConnection::Shutdown()
{
	if(!_shutdown) {
		_shutdown = true;
		DisableControllers();
		_emu->UnregisterInputProvider(this);
		MessageManager::DisplayMessage("NetPlay", "ConnectionLost");
		_emu->GetSettings()->ClearFlag(EmulationFlags::MaximumSpeed);
	}
	Disconnect();
}
void GameClientConnection::SendHandshake()
{
	HandShakeMessage message(HandShakeMessage::GetPasswordHash(_connectionData.Password, _serverSalt), _connectionData.Spectator, _emu->GetSettings()->GetVersion());
	SendNetMessage(message);
}
void GameClientConnection::SendControllerSelection(NetplayControllerInfo controller)
{
	SelectControllerMessage message(controller);
	SendNetMessage(message);
}
void GameClientConnection::ClearInputData()
{
	LockHandler lock = _writeLock.AcquireSafe();
	for(int i = 0; i < BaseControlDevice::PortCount; i++) {
		_inputSize[i] = 0;
		_inputData[i].clear();
	}
}
void GameClientConnection::ProcessMessage(NetMessage* message)
{
	GameInformationMessage* gameInfo;
	switch(message->GetType()) {
		case MessageType::ServerInformation:
			_serverSalt = ((ServerInformationMessage*)message)->GetHashSalt();
			SendHandshake();
			break;
		case MessageType::SaveState:
			if(_gameLoaded) {
				DisableControllers();
				auto lock = _emu->AcquireLock();
				ClearInputData();
				((SaveStateMessage*)message)->LoadState(_emu);
				_enableControllers = true;
				InitControlDevice();
			}
			break;
		case MessageType::MovieData:
			if(_gameLoaded) {
				PushControllerState(((MovieDataMessage*)message)->GetPortNumber(), ((MovieDataMessage*)message)->GetInputState());
			}
			break;
		case MessageType::ForceDisconnect:
			MessageManager::DisplayMessage("NetPlay", ((ForceDisconnectMessage*)message)->GetMessage());
			break;
		case MessageType::PlayerList:
			_playerList = ((PlayerListMessage*)message)->GetPlayerList();
			break;
		case MessageType::GameInformation:
			DisableControllers();
			{
				auto lock = _emu->AcquireLock();
				gameInfo = (GameInformationMessage*)message;
				if(gameInfo->GetPort().Port != _controllerPort.Port || gameInfo->GetPort().SubPort != _controllerPort.SubPort) {
					_controllerPort = gameInfo->GetPort();
				}
				ClearInputData();
			}
			_gameLoaded = AttemptLoadGame(gameInfo->GetRomFilename(), gameInfo->GetCrc32());
			if(!_gameLoaded) {
				_emu->Stop(true);
			} else {
				_emu->UnregisterInputProvider(this);
				_emu->RegisterInputProvider(this);
				if(gameInfo->IsPaused()) {
					_emu->Pause();
				} else {
					_emu->Resume();
				}
			}
			break;
		default:
			break;
	}
}
bool GameClientConnection::AttemptLoadGame(string filename, uint32_t crc32)
{
	if(filename.size() > 0) {
		if(!RomFinder::LoadMatchingRom(_emu, filename, crc32)) {
			MessageManager::DisplayMessage("NetPlay", "CouldNotFindRom", filename);
			return false;
		} else {
			return true;
		}
	}
	return false;
}
void GameClientConnection::PushControllerState(uint8_t port, ControlDeviceState state)
{
	LockHandler lock = _writeLock.AcquireSafe();
	_inputData[port].push_back(state);
	_inputSize[port]++;
	if(_inputData[port].size() >= _minimumQueueSize) {
		_waitForInput[port].Signal();
	}
}
void GameClientConnection::DisableControllers()
{
	_enableControllers = false;
	ClearInputData();
	for(int i = 0; i < BaseControlDevice::PortCount; i++) {
		_waitForInput[i].Signal();
	}
}
bool GameClientConnection::SetInput(BaseControlDevice *device)
{
	if(_enableControllers) {
		uint8_t port = device->GetPort();
		while(_inputSize[port] == 0) {
			_waitForInput[port].Wait();
			if(port == 0 && _minimumQueueSize < 10) {
				_minimumQueueSize++;
			}
			if(_shutdown || !_enableControllers) {
				return true;
			}
		}
		LockHandler lock = _writeLock.AcquireSafe();
		if(_shutdown || !_enableControllers || _inputSize[port] == 0) {
			return true;
		}
		ControlDeviceState state = _inputData[port].front();
		_inputData[port].pop_front();
		_inputSize[port]--;
		if(_inputData[port].size() > _minimumQueueSize) {
			_emu->GetSettings()->SetFlag(EmulationFlags::MaximumSpeed);
		} else {
			_emu->GetSettings()->ClearFlag(EmulationFlags::MaximumSpeed);
		}
		device->SetRawState(state);
	}
	return true;
}
void GameClientConnection::InitControlDevice()
{
	shared_ptr<IConsole> console = _emu->GetConsole();
	if(!console) {
		return;
	}
	BaseControlManager* controlManager = console->GetControlManager();
	shared_ptr<BaseControlDevice> device = controlManager->GetControlDevice(_controllerPort.Port, _controllerPort.SubPort);
	if(device) {
		_controllerType = device->GetControllerType();
	} else {
		_controllerType = ControllerType::None;
	}
}
void GameClientConnection::ProcessNotification(ConsoleNotificationType type, void* parameter)
{
	if(type == ConsoleNotificationType::ConfigChanged) {
		InitControlDevice();
	} else if(type == ConsoleNotificationType::GameLoaded) {
		_emu->RegisterInputProvider(this);
	}
}
void GameClientConnection::SendInput()
{
	if(_gameLoaded) {
		if(!_controlDevice || _controllerType != _controlDevice->GetControllerType()) {
			shared_ptr<IConsole> console = _emu->GetConsole();
			if(!console) {
				return;
			}
			_controlDevice = console->GetControlManager()->CreateControllerDevice(_controllerType, 0);
		}
		ControlDeviceState inputState;
		if(_controlDevice) {
			_controlDevice->SetStateFromInput();
			inputState = _controlDevice->GetRawState();
		}
		if(_lastInputSent != inputState) {
			InputDataMessage message(inputState);
			SendNetMessage(message);
			_lastInputSent = inputState;
		}
	}
}
void GameClientConnection::SelectController(NetplayControllerInfo controller)
{
	SendControllerSelection(controller);
}
vector<NetplayControllerUsageInfo> GameClientConnection::GetControllerList()
{
	return GameServer::GetControllerList(_emu, _playerList);
}
NetplayControllerInfo GameClientConnection::GetControllerPort()
{
	return _controllerPort;
}
```

## File: Core/Netplay/GameClientConnection.h
```
#pragma once
#include "pch.h"
#include <deque>
#include "Utilities/AutoResetEvent.h"
#include "Utilities/SimpleLock.h"
#include "Shared/BaseControlDevice.h"
#include "Shared/Interfaces/INotificationListener.h"
#include "Shared/Interfaces/IInputProvider.h"
#include "Shared/ControlDeviceState.h"
#include "Netplay/GameConnection.h"
#include "Netplay/ClientConnectionData.h"
#include "Netplay/NetplayTypes.h"
class Emulator;
class GameClientConnection final : public GameConnection, public INotificationListener, public IInputProvider
{
private:
	std::deque<ControlDeviceState> _inputData[BaseControlDevice::PortCount];
	atomic<uint32_t> _inputSize[BaseControlDevice::PortCount];
	AutoResetEvent _waitForInput[BaseControlDevice::PortCount];
	SimpleLock _writeLock;
	atomic<bool> _shutdown;
	atomic<bool> _enableControllers;
	atomic<uint32_t> _minimumQueueSize;
	vector<PlayerInfo> _playerList;
	shared_ptr<BaseControlDevice> _controlDevice;
	atomic<ControllerType> _controllerType;
	ControlDeviceState _lastInputSent = {};
	bool _gameLoaded = false;
	NetplayControllerInfo _controllerPort = { GameConnection::SpectatorPort, 0 };
	ClientConnectionData _connectionData = {};
	string _serverSalt;
private:
	void SendHandshake();
	void SendControllerSelection(NetplayControllerInfo controller);
	void ClearInputData();
	void PushControllerState(uint8_t port, ControlDeviceState state);
	void DisableControllers();
	bool AttemptLoadGame(string filename, uint32_t crc32);
protected:
	void ProcessMessage(NetMessage* message) override;
public:
	GameClientConnection(Emulator* emu, unique_ptr<Socket> socket, ClientConnectionData &connectionData);
	virtual ~GameClientConnection();
	void Shutdown();
	void ProcessNotification(ConsoleNotificationType type, void* parameter) override;
	bool SetInput(BaseControlDevice *device) override;
	void InitControlDevice();
	void SendInput();
	void SelectController(NetplayControllerInfo controller);
	vector<NetplayControllerUsageInfo> GetControllerList();
	NetplayControllerInfo GetControllerPort();
};
```

## File: Core/Netplay/GameConnection.cpp
```cpp
#include "pch.h"
#include "Netplay/GameConnection.h"
#include "Netplay/HandShakeMessage.h"
#include "Netplay/InputDataMessage.h"
#include "Netplay/MovieDataMessage.h"
#include "Netplay/GameInformationMessage.h"
#include "Netplay/SaveStateMessage.h"
#include "Netplay/PlayerListMessage.h"
#include "Netplay/SelectControllerMessage.h"
#include "Netplay/ClientConnectionData.h"
#include "Netplay/ForceDisconnectMessage.h"
#include "Netplay/ServerInformationMessage.h"
GameConnection::GameConnection(Emulator* emu, unique_ptr<Socket> socket)
{
	_emu = emu;
	_socket.swap(socket);
}
GameConnection::~GameConnection()
{
	Disconnect();
}
void GameConnection::ReadSocket()
{
	auto lock = _socketLock.AcquireSafe();
	int bytesReceived = _socket->Recv((char*)_readBuffer + _readPosition, GameConnection::MaxMsgLength - _readPosition, 0);
	if(bytesReceived > 0) {
		_readPosition += bytesReceived;
	}
}
bool GameConnection::ExtractMessage(void *buffer, uint32_t &messageLength)
{
	messageLength = _readBuffer[0] | (_readBuffer[1] << 8) | (_readBuffer[2] << 16) | (_readBuffer[3] << 24);
	if(messageLength > GameConnection::MaxMsgLength) {
		MessageManager::Log("[Netplay] Invalid data received, closing connection.");
		Disconnect();
		return false;
	}
	int packetLength = messageLength + sizeof(messageLength);
	if(_readPosition >= packetLength) {
		memcpy(buffer, _readBuffer+sizeof(messageLength), messageLength);
		memmove(_readBuffer, _readBuffer + packetLength, _readPosition - packetLength);
		_readPosition -= packetLength;
		return true;
	}
	return false;
}
NetMessage* GameConnection::ReadMessage()
{
	ReadSocket();
	if(_readPosition > 4) {
		uint32_t messageLength;
		if(ExtractMessage(_messageBuffer, messageLength)) {
			switch((MessageType)_messageBuffer[0]) {
				case MessageType::HandShake: return new HandShakeMessage(_messageBuffer, messageLength);
				case MessageType::SaveState: return new SaveStateMessage(_messageBuffer, messageLength);
				case MessageType::InputData: return new InputDataMessage(_messageBuffer, messageLength);
				case MessageType::MovieData: return new MovieDataMessage(_messageBuffer, messageLength);
				case MessageType::GameInformation: return new GameInformationMessage(_messageBuffer, messageLength);
				case MessageType::PlayerList: return new PlayerListMessage(_messageBuffer, messageLength);
				case MessageType::SelectController: return new SelectControllerMessage(_messageBuffer, messageLength);
				case MessageType::ForceDisconnect: return new ForceDisconnectMessage(_messageBuffer, messageLength);
				case MessageType::ServerInformation: return new ServerInformationMessage(_messageBuffer, messageLength);
			}
		}
	}
	return nullptr;
}
void GameConnection::SendNetMessage(NetMessage &message)
{
	auto lock = _socketLock.AcquireSafe();
	message.Send(*_socket.get());
}
void GameConnection::Disconnect()
{
	auto lock = _socketLock.AcquireSafe();
	_socket->Close();
}
bool GameConnection::ConnectionError()
{
	return _socket->ConnectionError();
}
void GameConnection::ProcessMessages()
{
	NetMessage* message;
	while((message = ReadMessage()) != nullptr) {
		message->Initialize();
		ProcessMessage(message);
		delete message;
	}
}
```

## File: Core/Netplay/GameConnection.h
```
#pragma once
#include "pch.h"
#include "Utilities/SimpleLock.h"
class Socket;
class NetMessage;
class Emulator;
class GameConnection
{
protected:
	static constexpr int MaxMsgLength = 1500000;
	unique_ptr<Socket> _socket;
	Emulator* _emu;
	uint8_t _readBuffer[GameConnection::MaxMsgLength] = {};
	uint8_t _messageBuffer[GameConnection::MaxMsgLength] = {};
	int _readPosition = 0;
	SimpleLock _socketLock;
private:
	void ReadSocket();
	bool ExtractMessage(void *buffer, uint32_t &messageLength);
	NetMessage* ReadMessage();
	virtual void ProcessMessage(NetMessage* message) = 0;
protected:
	void Disconnect();
public:
	static constexpr uint8_t SpectatorPort = 0xFF;
	GameConnection(Emulator* emu, unique_ptr<Socket> socket);
	virtual ~GameConnection();
	bool ConnectionError();
	void ProcessMessages();
	void SendNetMessage(NetMessage &message);
};
```

## File: Core/Netplay/GameInformationMessage.h
```
#pragma once
#include "pch.h"
#include "Shared/MessageManager.h"
#include "Netplay/NetMessage.h"
#include "Netplay/NetplayTypes.h"
#include "Utilities/FolderUtilities.h"
class GameInformationMessage : public NetMessage
{
private:
	string _romFilename;
	uint32_t _crc32 = 0;
	NetplayControllerInfo _controller = {};
	bool _paused = false;
protected:
	void Serialize(Serializer &s) override
	{
		SV(_romFilename); SV(_crc32); SV(_controller.Port); SV(_controller.SubPort); SV(_paused);
	}
public:
	GameInformationMessage(void* buffer, uint32_t length) : NetMessage(buffer, length) { }
	GameInformationMessage(string filepath, uint32_t crc32, NetplayControllerInfo controller, bool paused) : NetMessage(MessageType::GameInformation)
	{
		_romFilename = FolderUtilities::GetFilename(filepath, true);
		_crc32 = crc32;
		_controller = controller;
		_paused = paused;
	}
	NetplayControllerInfo GetPort()
	{
		return _controller;
	}
	string GetRomFilename()
	{
		return _romFilename;
	}
	uint32_t GetCrc32()
	{
		return _crc32;
	}
	bool IsPaused()
	{
		return _paused;
	}
};
```

## File: Core/Netplay/GameServer.cpp
```cpp
#include "pch.h"
#include "Netplay/GameServer.h"
#include "Netplay/GameServerConnection.h"
#include "Netplay/PlayerListMessage.h"
#include "Shared/Emulator.h"
#include "Shared/BaseControlManager.h"
#include "Shared/NotificationManager.h"
#include "Shared/MessageManager.h"
#include "Utilities/Socket.h"
#include "Shared/ControllerHub.h"
GameServer::GameServer(Emulator* emu)
{
	_emu = emu;
	_stop = false;
	_initialized = false;
	_hostControllerPort = {};
}
GameServer::~GameServer()
{
}
void GameServer::RegisterServerInput()
{
	_emu->RegisterInputProvider(this);
	_emu->RegisterInputRecorder(this);
}
void GameServer::AcceptConnections()
{
	while(true) {
		unique_ptr<Socket> socket = _listener->Accept();
		if(!socket->ConnectionError()) {
			_openConnections.push_back(unique_ptr<GameServerConnection>(new GameServerConnection(this, _emu, std::move(socket), _password)));
		} else {
			break;
		}
	}
	_listener->Listen(10);
}
void GameServer::UpdateConnections()
{
	vector<unique_ptr<GameServerConnection>> connectionsToRemove;
	for(int i = (int)_openConnections.size() - 1; i >= 0; i--) {
		if(_openConnections[i]->ConnectionError()) {
			auto lock = _emu->AcquireLock();
			_openConnections.erase(_openConnections.begin() + i);
		} else {
			_openConnections[i]->ProcessMessages();
		}
	}
}
bool GameServer::SetInput(BaseControlDevice *device)
{
	uint8_t port = device->GetPort();
	IControllerHub* hub = dynamic_cast<IControllerHub*>(device);
	if(hub) {
		for(int i = 0, len = hub->GetHubPortCount(); i < len; i++) {
			NetplayControllerInfo controller { port, (uint8_t)i };
			GameServerConnection* connection = GetNetPlayDevice(controller);
			if(connection) {
				shared_ptr<BaseControlDevice> hubController = hub->GetController(i);
				if(hubController) {
					hubController->SetRawState(connection->GetState());
				}
			}
		}
		hub->RefreshHubState();
	} else {
		NetplayControllerInfo controller { port, 0 };
		GameServerConnection* connection = GetNetPlayDevice(controller);
		if(connection) {
			device->SetRawState(connection->GetState());
			return true;
		}
	}
	return false;
}
void GameServer::RecordInput(vector<shared_ptr<BaseControlDevice>> devices)
{
	for(shared_ptr<BaseControlDevice> &device : devices) {
		for(unique_ptr<GameServerConnection>& connection : _openConnections) {
			if(!connection->ConnectionError()) {
				connection->SendMovieData(device->GetPort(), device->GetRawState());
			}
		}
	}
}
void GameServer::ProcessNotification(ConsoleNotificationType type, void * parameter)
{
	for(unique_ptr<GameServerConnection>& connection : _openConnections) {
		connection->ProcessNotification(type, parameter);
	}
	if(type == ConsoleNotificationType::GameLoaded) {
		RegisterServerInput();
	}
}
void GameServer::Exec()
{
	_listener.reset(new Socket());
	_listener->Bind(_port);
	_listener->Listen(10);
	_stop = false;
	_initialized = true;
	MessageManager::DisplayMessage("NetPlay" , "ServerStarted", std::to_string(_port));
	while(!_stop) {
		AcceptConnections();
		UpdateConnections();
		std::this_thread::sleep_for(std::chrono::duration<int, std::milli>(1));
	}
}
void GameServer::StartServer(uint16_t port, string password)
{
	_port = port;
	_password = password;
	_emu->GetNotificationManager()->RegisterNotificationListener(shared_from_this());
	RegisterServerInput();
	_serverThread.reset(new thread(&GameServer::Exec, this));
}
void GameServer::StopServer()
{
	if(!_serverThread) {
		return;
	}
	_stop = true;
	if(_serverThread) {
		_serverThread->join();
		_serverThread.reset();
	}
	_openConnections.clear();
	_initialized = false;
	_listener.reset();
	MessageManager::DisplayMessage("NetPlay", "ServerStopped");
	_emu->UnregisterInputRecorder(this);
	_emu->UnregisterInputProvider(this);
}
bool GameServer::Started()
{
	return _initialized;
}
NetplayControllerInfo GameServer::GetHostControllerPort()
{
	return _hostControllerPort;
}
void GameServer::SetHostControllerPort(NetplayControllerInfo controller)
{
	if(Started()) {
		auto lock = _emu->AcquireLock();
		if(controller.Port != GameConnection::SpectatorPort) {
			for(NetplayControllerUsageInfo& c : GetControllerList()) {
				if(c.InUse && controller.Port == c.Port.Port && controller.SubPort == c.Port.SubPort) {
					return;
				}
			}
		}
		_hostControllerPort = controller;
		SendPlayerList();
	}
}
vector<NetplayControllerUsageInfo> GameServer::GetControllerList()
{
	vector<PlayerInfo> players = GetPlayerList();
	return GetControllerList(_emu, players);
}
vector<NetplayControllerUsageInfo> GameServer::GetControllerList(Emulator* emu, vector<PlayerInfo>& players)
{
	vector<NetplayControllerUsageInfo> controllers;
	shared_ptr<IConsole> console = emu->GetConsole();
	if(!console) {
		return controllers;
	}
	for(uint8_t i = 0; i < BaseControlDevice::PortCount; i++) {
		for(uint8_t j = 0; j < IControllerHub::MaxSubPorts; j++) {
			shared_ptr<BaseControlDevice> controller = console->GetControlManager()->GetControlDevice(i, j);
			if(controller) {
				NetplayControllerUsageInfo result = {};
				result.Port.Port = i;
				result.Port.SubPort = j;
				result.Type = controller->GetControllerType();
				result.InUse = false;
				for(PlayerInfo& player : players) {
					if(player.ControllerPort.Port == i && player.ControllerPort.SubPort == j) {
						result.InUse = true;
						break;
					}
				}
				controllers.push_back(result);
			}
		}
	}
	return controllers;
}
vector<PlayerInfo> GameServer::GetPlayerList()
{
	vector<PlayerInfo> playerList;
	PlayerInfo playerInfo;
	playerInfo.ControllerPort = GetHostControllerPort();
	playerInfo.IsHost = true;
	playerList.push_back(playerInfo);
	for(unique_ptr<GameServerConnection>& connection : _openConnections) {
		playerInfo.ControllerPort = connection->GetControllerPort();
		playerInfo.IsHost = false;
		playerList.push_back(playerInfo);
	}
	return playerList;
}
void GameServer::SendPlayerList()
{
	vector<PlayerInfo> playerList = GetPlayerList();
	for(unique_ptr<GameServerConnection>& connection : _openConnections) {
		PlayerListMessage message(playerList);
		connection->SendNetMessage(message);
	}
}
void GameServer::RegisterNetPlayDevice(GameServerConnection* device, NetplayControllerInfo controller)
{
	_netPlayDevices[controller.Port][controller.SubPort] = device;
}
void GameServer::UnregisterNetPlayDevice(GameServerConnection* device)
{
	if(device != nullptr) {
		for(int i = 0; i < BaseControlDevice::PortCount; i++) {
			for(int j = 0; j < IControllerHub::MaxSubPorts; j++) {
				if(_netPlayDevices[i][j] == device) {
					_netPlayDevices[i][j] = nullptr;
					return;
				}
			}
		}
	}
}
GameServerConnection* GameServer::GetNetPlayDevice(NetplayControllerInfo controller)
{
	return _netPlayDevices[controller.Port][controller.SubPort];
}
NetplayControllerInfo GameServer::GetFirstFreeControllerPort()
{
	for(NetplayControllerUsageInfo& c : GetControllerList()) {
		if(!c.InUse) {
			return c.Port;
		}
	}
	return NetplayControllerInfo { GameConnection::SpectatorPort, 0 };
}
```

## File: Core/Netplay/GameServer.h
```
#pragma once
#include "pch.h"
#include <thread>
#include "Netplay/GameServerConnection.h"
#include "Netplay/NetplayTypes.h"
#include "Shared/Interfaces/INotificationListener.h"
#include "Shared/Interfaces/IInputProvider.h"
#include "Shared/Interfaces/IInputRecorder.h"
#include "Shared/IControllerHub.h"
class Emulator;
class GameServer : public IInputRecorder, public IInputProvider, public INotificationListener, public std::enable_shared_from_this<GameServer>
{
private:
	Emulator* _emu;
	unique_ptr<thread> _serverThread;
	unique_ptr<Socket> _listener;
	atomic<bool> _stop;
	uint16_t _port = 0;
	string _password;
	vector<unique_ptr<GameServerConnection>> _openConnections;
	bool _initialized = false;
	GameServerConnection* _netPlayDevices[BaseControlDevice::PortCount][IControllerHub::MaxSubPorts] = {};
	NetplayControllerInfo _hostControllerPort = {};
	void AcceptConnections();
	void UpdateConnections();
	void Exec();
public:
	GameServer(Emulator* emu);
	virtual ~GameServer();
	void RegisterServerInput();
	void StartServer(uint16_t port, string password);
	void StopServer();
	bool Started();
	NetplayControllerInfo GetHostControllerPort();
	void SetHostControllerPort(NetplayControllerInfo controller);
	vector<NetplayControllerUsageInfo> GetControllerList();
	vector<PlayerInfo> GetPlayerList();
	void SendPlayerList();
	static vector<NetplayControllerUsageInfo> GetControllerList(Emulator* emu, vector<PlayerInfo>& players);
	bool SetInput(BaseControlDevice *device) override;
	void RecordInput(vector<shared_ptr<BaseControlDevice>> devices) override;
	virtual void ProcessNotification(ConsoleNotificationType type, void * parameter) override;
	void RegisterNetPlayDevice(GameServerConnection* connection, NetplayControllerInfo controller);
	void UnregisterNetPlayDevice(GameServerConnection* device);
	NetplayControllerInfo GetFirstFreeControllerPort();
	GameServerConnection* GetNetPlayDevice(NetplayControllerInfo controller);
};
```

## File: Core/Netplay/GameServerConnection.cpp
```cpp
#include "pch.h"
#include <random>
#include "Netplay/GameServerConnection.h"
#include "Netplay/HandShakeMessage.h"
#include "Netplay/InputDataMessage.h"
#include "Netplay/MovieDataMessage.h"
#include "Netplay/GameInformationMessage.h"
#include "Netplay/SaveStateMessage.h"
#include "Netplay/ClientConnectionData.h"
#include "Netplay/SelectControllerMessage.h"
#include "Netplay/PlayerListMessage.h"
#include "Netplay/GameServer.h"
#include "Netplay/ForceDisconnectMessage.h"
#include "Netplay/ServerInformationMessage.h"
#include "Netplay/NetplayTypes.h"
#include "Shared/MessageManager.h"
#include "Shared/Emulator.h"
#include "Shared/EmuSettings.h"
#include "Shared/BaseControlDevice.h"
GameServerConnection::GameServerConnection(GameServer* gameServer, Emulator* emu, unique_ptr<Socket> socket, string serverPassword) : GameConnection(emu, std::move(socket))
{
	_server = gameServer;
	_serverPassword = serverPassword;
	_controllerPort = NetplayControllerInfo { GameConnection::SpectatorPort, 0 };
	SendServerInformation();
}
GameServerConnection::~GameServerConnection()
{
	MessageManager::DisplayMessage("NetPlay", "Player disconnected.");
	_server->UnregisterNetPlayDevice(this);
}
void GameServerConnection::SendServerInformation()
{
	std::random_device rd;
	std::mt19937 engine(rd());
	std::uniform_int_distribution<> dist((int)' ', (int)'~');
	string hash(50, ' ');
	for(int i = 0; i < 50; i++) {
		int random = dist(engine);
		hash[i] = (char)random;
	}
	_connectionHash = hash;
	ServerInformationMessage message(hash);
	SendNetMessage(message);
}
void GameServerConnection::SendGameInformation()
{
	auto lock = _emu->AcquireLock();
	RomInfo romInfo = _emu->GetRomInfo();
	GameInformationMessage gameInfo(romInfo.RomFile.GetFileName(), _emu->GetCrc32(), _controllerPort, _emu->IsPaused());
	SendNetMessage(gameInfo);
	SaveStateMessage saveState(_emu);
	SendNetMessage(saveState);
}
void GameServerConnection::SendMovieData(uint8_t port, ControlDeviceState state)
{
	if(_handshakeCompleted) {
		MovieDataMessage message(state, port);
		SendNetMessage(message);
	}
}
void GameServerConnection::SendForceDisconnectMessage(string disconnectMessage)
{
	ForceDisconnectMessage message(disconnectMessage);
	SendNetMessage(message);
	Disconnect();
}
void GameServerConnection::PushState(ControlDeviceState state)
{
	auto lock = _inputLock.AcquireSafe();
	_inputData = state;
}
ControlDeviceState GameServerConnection::GetState()
{
	ControlDeviceState stateData;
	{
		auto lock = _inputLock.AcquireSafe();
		stateData = _inputData;
	}
	return stateData;
}
void GameServerConnection::ProcessHandshakeResponse(HandShakeMessage* message)
{
	if(message->IsValid(_emu->GetSettings()->GetVersion())) {
		if(message->CheckPassword(_serverPassword, _connectionHash)) {
			auto lock = _emu->AcquireLock();
			_controllerPort = message->IsSpectator() ? NetplayControllerInfo { GameConnection::SpectatorPort, 0 } : _server->GetFirstFreeControllerPort();
			MessageManager::DisplayMessage("NetPlay", "Player connected.");
			if(_emu->IsRunning()) {
				SendGameInformation();
			}
			_handshakeCompleted = true;
			_server->RegisterNetPlayDevice(this, _controllerPort);
			_server->SendPlayerList();
		} else {
			SendForceDisconnectMessage("The password you provided did not match - you have been disconnected.");
		}
	} else {
		SendForceDisconnectMessage("Server is using a different version of Mesen (" + _emu->GetSettings()->GetVersionString() + ") - you have been disconnected.");
		MessageManager::DisplayMessage("NetPlay", + "NetplayVersionMismatch");
	}
}
void GameServerConnection::ProcessMessage(NetMessage* message)
{
	switch(message->GetType()) {
		case MessageType::HandShake:
			ProcessHandshakeResponse((HandShakeMessage*)message);
			break;
		case MessageType::InputData:
			if(!_handshakeCompleted) {
				SendForceDisconnectMessage("Handshake has not been completed - invalid packet");
				return;
			}
			PushState(((InputDataMessage*)message)->GetInputState());
			break;
		case MessageType::SelectController:
			if(!_handshakeCompleted) {
				SendForceDisconnectMessage("Handshake has not been completed - invalid packet");
				return;
			}
			SelectControllerPort(((SelectControllerMessage*)message)->GetController());
			break;
		default:
			break;
	}
}
void GameServerConnection::SelectControllerPort(NetplayControllerInfo controller)
{
	auto lock = _emu->AcquireLock();
	if(controller.Port == GameConnection::SpectatorPort) {
		_server->UnregisterNetPlayDevice(this);
		_controllerPort = controller;
	} else {
		GameServerConnection* netPlayDevice = _server->GetNetPlayDevice(controller);
		if(netPlayDevice == this) {
		} else if(netPlayDevice == nullptr) {
			_server->UnregisterNetPlayDevice(this);
			_server->RegisterNetPlayDevice(this, controller);
			_controllerPort = controller;
		} else {
		}
	}
	SendGameInformation();
	_server->SendPlayerList();
}
void GameServerConnection::ProcessNotification(ConsoleNotificationType type, void* parameter)
{
	switch(type) {
		case ConsoleNotificationType::GamePaused:
		case ConsoleNotificationType::GameLoaded:
		case ConsoleNotificationType::GameResumed:
		case ConsoleNotificationType::GameReset:
		case ConsoleNotificationType::StateLoaded:
		case ConsoleNotificationType::CheatsChanged:
		case ConsoleNotificationType::ConfigChanged:
			SendGameInformation();
			break;
		case ConsoleNotificationType::PpuFrameDone: {
			Serializer s(0, true);
			EmuSettings* settings = _emu->GetSettings();
			s.Stream(*settings, "", -1);
			stringstream currentConfig;
			s.SaveTo(currentConfig, 0);
			if(_previousConfig != currentConfig.str()) {
				SendGameInformation();
			}
			_previousConfig = currentConfig.str();
			break;
		}
		case ConsoleNotificationType::BeforeEmulationStop: {
			//Make clients unload the current game
			GameInformationMessage gameInfo("", 0, _controllerPort, true);
			SendNetMessage(gameInfo);
			break;
		}
		default:
			break;
	}
}
NetplayControllerInfo GameServerConnection::GetControllerPort()
{
	return _controllerPort;
}
```

## File: Core/Netplay/GameServerConnection.h
```
#pragma once
#include "pch.h"
#include <deque>
#include "Netplay/GameConnection.h"
#include "Netplay/NetplayTypes.h"
#include "Shared/Interfaces/INotificationListener.h"
#include "Shared/BaseControlDevice.h"
#include "Shared/ControlDeviceState.h"
#include "Utilities/SimpleLock.h"
class HandShakeMessage;
class GameServer;
class GameServerConnection final : public GameConnection, public INotificationListener
{
private:
	GameServer* _server = nullptr;
	SimpleLock _inputLock;
	ControlDeviceState _inputData = {};
	string _previousConfig = "";
	NetplayControllerInfo _controllerPort = {};
	string _connectionHash;
	string _serverPassword;
	bool _handshakeCompleted = false;
	void PushState(ControlDeviceState state);
	void SendServerInformation();
	void SendGameInformation();
	void SelectControllerPort(NetplayControllerInfo port);
	void SendForceDisconnectMessage(string disconnectMessage);
	void ProcessHandshakeResponse(HandShakeMessage* message);
protected:
	void ProcessMessage(NetMessage* message) override;
public:
	GameServerConnection(GameServer* gameServer, Emulator* emu, unique_ptr<Socket> socket, string serverPassword);
	virtual ~GameServerConnection();
	ControlDeviceState GetState();
	void SendMovieData(uint8_t port, ControlDeviceState state);
	NetplayControllerInfo GetControllerPort();
	virtual void ProcessNotification(ConsoleNotificationType type, void* parameter) override;
};
```

## File: Core/Netplay/HandShakeMessage.h
```
#pragma once
#include "pch.h"
#include "Netplay/NetMessage.h"
#include "Utilities/sha1.h"
class HandShakeMessage : public NetMessage
{
private:
	static constexpr int CurrentVersion = 200;
	uint32_t _emuVersion = 0;
	uint32_t _protocolVersion = CurrentVersion;
	string _hashedPassword;
	bool _spectator = false;
protected:
	void Serialize(Serializer &s) override
	{
		SV(_emuVersion); SV(_protocolVersion); SV(_hashedPassword); SV(_spectator);
	}
public:
	HandShakeMessage(void* buffer, uint32_t length) : NetMessage(buffer, length) {}
	HandShakeMessage(string hashedPassword, bool spectator, uint32_t emuVersion) : NetMessage(MessageType::HandShake)
	{
		_emuVersion = emuVersion;
		_protocolVersion = HandShakeMessage::CurrentVersion;
		_hashedPassword = hashedPassword;
		_spectator = spectator;
	}
	bool IsValid(uint32_t emuVersion)
	{
		return _protocolVersion == CurrentVersion && _emuVersion == emuVersion;
	}
	bool CheckPassword(string serverPassword, string connectionHash)
	{
		return GetPasswordHash(serverPassword, connectionHash) == string(_hashedPassword);
	}
	bool IsSpectator()
	{
		return _spectator;
	}
	static string GetPasswordHash(string serverPassword, string connectionHash)
	{
		string saltedPassword = serverPassword + connectionHash;
		vector<uint8_t> dataToHash = vector<uint8_t>(saltedPassword.c_str(), saltedPassword.c_str() + saltedPassword.size());
		return SHA1::GetHash(dataToHash);
	}
};
```

## File: Core/Netplay/InputDataMessage.h
```
#pragma once
#include "pch.h"
#include "Netplay/NetMessage.h"
#include "Shared/ControlDeviceState.h"
class InputDataMessage : public NetMessage
{
private:
	ControlDeviceState _inputState;
protected:
	void Serialize(Serializer &s) override
	{
		SVVector(_inputState.State);
	}
public:
	InputDataMessage(void* buffer, uint32_t length) : NetMessage(buffer, length) { }
	InputDataMessage(ControlDeviceState inputState) : NetMessage(MessageType::InputData)
	{
		_inputState = inputState;
	}
	ControlDeviceState GetInputState()
	{
		return _inputState;
	}
};
```

## File: Core/Netplay/MessageType.h
```
#pragma once
#include "pch.h"
enum class MessageType : uint8_t
{
	HandShake = 0,
	SaveState = 1,
	InputData = 2,
	MovieData = 3,
	GameInformation = 4,
	PlayerList = 5,
	SelectController = 6,
	ForceDisconnect = 7,
	ServerInformation = 8
};
```

## File: Core/Netplay/MovieDataMessage.h
```
#pragma once
#include "pch.h"
#include "Netplay/NetMessage.h"
#include "Shared/ControlDeviceState.h"
class MovieDataMessage : public NetMessage
{
private:
	uint8_t _portNumber = 0;
	ControlDeviceState _inputState = {};
protected:
	void Serialize(Serializer &s) override
	{
		SV(_portNumber);
		SVVector(_inputState.State);
	}
public:
	MovieDataMessage(void* buffer, uint32_t length) : NetMessage(buffer, length) { }
	MovieDataMessage(ControlDeviceState state, uint8_t port) : NetMessage(MessageType::MovieData)
	{
		_portNumber = port;
		_inputState = state;
	}
	uint8_t GetPortNumber()
	{
		return _portNumber;
	}
	ControlDeviceState GetInputState()
	{
		return _inputState;
	}
};
```

## File: Core/Netplay/NetMessage.h
```
#pragma once
#include "pch.h"
#include "Netplay/MessageType.h"
#include "Shared/SaveStateManager.h"
#include "Utilities/Socket.h"
#include "Utilities/Serializer.h"
class NetMessage
{
protected:
	MessageType _type;
	stringstream _receivedData;
	NetMessage(MessageType type)
	{
		_type = type;
	}
	NetMessage(void* buffer, uint32_t length)
	{
		_type = (MessageType)((uint8_t*)buffer)[0];
		_receivedData.write((char*)buffer + 1, length - 1);
	}
public:
	virtual ~NetMessage()
	{
	}
	void Initialize()
	{
		Serializer s(SaveStateManager::FileFormatVersion, false);
		if(s.LoadFrom(_receivedData)) {
			Serialize(s);
		}
	}
	MessageType GetType()
	{
		return _type;
	}
	void Send(Socket &socket)
	{
		Serializer s(SaveStateManager::FileFormatVersion, true);
		Serialize(s);
		stringstream out;
		s.SaveTo(out);
		string data = out.str();
		uint32_t messageLength = (uint32_t)data.size() + 1;
		data = string((char*)&messageLength, 4) + (char)_type + data;
		socket.Send((char*)data.c_str(), (int)data.size(), 0);
	}
protected:
	virtual void Serialize(Serializer &s) = 0;
};
```

## File: Core/Netplay/NetplayTypes.h
```
#pragma once
#include "pch.h"
#include "Shared/SettingTypes.h"
struct NetplayControllerInfo
{
	uint8_t Port = 0;
	uint8_t SubPort = 0;
};
struct NetplayControllerUsageInfo
{
	NetplayControllerInfo Port = {};
	ControllerType Type = ControllerType::None;
	bool InUse = false;
};
struct PlayerInfo
{
	NetplayControllerInfo ControllerPort = {};
	bool IsHost = false;
};
```

## File: Core/Netplay/PlayerListMessage.h
```
#pragma once
#include "pch.h"
#include "Netplay/NetMessage.h"
class PlayerListMessage : public NetMessage
{
private:
	vector<PlayerInfo> _playerList;
protected:
	void Serialize(Serializer &s) override
	{
		if(s.IsSaving()) {
			uint32_t playerCount = (uint32_t)_playerList.size();
			SV(playerCount);
			for(uint32_t i = 0; i < playerCount; i++) {
				SVI(_playerList[i].ControllerPort.Port);
				SVI(_playerList[i].ControllerPort.SubPort);
				SVI(_playerList[i].IsHost);
			}
		} else {
			uint32_t playerCount = 0;
			SV(playerCount);
			_playerList.resize(playerCount);
			for(uint32_t i = 0; i < playerCount; i++) {
				SVI(_playerList[i].ControllerPort.Port);
				SVI(_playerList[i].ControllerPort.SubPort);
				SVI(_playerList[i].IsHost);
			}
		}
	}
public:
	PlayerListMessage(void* buffer, uint32_t length) : NetMessage(buffer, length) { }
	PlayerListMessage(vector<PlayerInfo> playerList) : NetMessage(MessageType::PlayerList)
	{
		_playerList = playerList;
	}
	vector<PlayerInfo> GetPlayerList()
	{
		return _playerList;
	}
};
```

## File: Core/Netplay/SaveStateMessage.h
```
#pragma once
#include "pch.h"
#include "Netplay/NetMessage.h"
#include "Shared/Emulator.h"
#include "Shared/EmuSettings.h"
#include "Shared/CheatManager.h"
#include "Shared/SaveStateManager.h"
class SaveStateMessage : public NetMessage
{
private:
	vector<CheatCode> _activeCheats;
	vector<uint8_t> _stateData;
protected:
	void Serialize(Serializer &s) override
	{
		SVVector(_stateData);
		SVVector(_activeCheats);
	}
public:
	SaveStateMessage(void* buffer, uint32_t length) : NetMessage(buffer, length) { }
	SaveStateMessage(Emulator* emu) : NetMessage(MessageType::SaveState)
	{
		stringstream state;
		{
			auto lock = emu->AcquireLock();
			_activeCheats = emu->GetCheatManager()->GetCheats();
			emu->Serialize(state, true);
		}
		uint32_t dataSize = (uint32_t)state.tellp();
		_stateData.resize(dataSize);
		state.read((char*)_stateData.data(), dataSize);
	}
	void LoadState(Emulator* emu)
	{
		std::stringstream ss;
		ss.write((char*)_stateData.data(), _stateData.size());
		emu->Deserialize(ss, SaveStateManager::FileFormatVersion, true);
		emu->GetCheatManager()->SetCheats(_activeCheats);
	}
};
```

## File: Core/Netplay/SelectControllerMessage.h
```
#pragma once
#include "pch.h"
#include "Netplay/NetMessage.h"
class SelectControllerMessage : public NetMessage
{
private:
	NetplayControllerInfo _controller = {};
protected:
	void Serialize(Serializer &s) override
	{
		SV(_controller.Port);
		SV(_controller.SubPort);
	}
public:
	SelectControllerMessage(void* buffer, uint32_t length) : NetMessage(buffer, length) { }
	SelectControllerMessage(NetplayControllerInfo controller) : NetMessage(MessageType::SelectController)
	{
		_controller = controller;
	}
	NetplayControllerInfo GetController()
	{
		return _controller;
	}
};
```

## File: Core/Netplay/ServerInformationMessage.h
```
#pragma once
#include "pch.h"
#include "Netplay/NetMessage.h"
class ServerInformationMessage : public NetMessage
{
private:
	string _hashSalt;
protected:
	void Serialize(Serializer &s) override
	{
		SV(_hashSalt);
	}
public:
	ServerInformationMessage(void* buffer, uint32_t length) : NetMessage(buffer, length) {}
	ServerInformationMessage(string hashSalt) : NetMessage(MessageType::ServerInformation)
	{
		_hashSalt = hashSalt;
	}
	string GetHashSalt()
	{
		return _hashSalt;
	}
};
```

## File: Core/pch.cpp
```cpp
#include "pch.h"
```

## File: Core/pch.h
```
#pragma once
#ifdef _MSC_VER
#pragma warning( disable : 4100 )
#pragma warning( disable : 4244 )
#pragma warning( disable : 4245 )
#endif
#ifdef __clang__
#pragma clang diagnostic ignored "-Wswitch"
#endif
#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <memory>
#include <optional>
#include <iostream>
#include <iomanip>
#include <fstream>
#include <string>
#include <cctype>
#include <cmath>
#include <vector>
#include <unordered_map>
#include <unordered_set>
#include <sstream>
#include <list>
#include <atomic>
#include <thread>
#include <deque>
#include <algorithm>
#include <assert.h>
#include "Utilities/UTF8Util.h"
#ifdef _MSC_VER
	#define __noinline __declspec(noinline)
#elif !defined(__MINGW32__) && (defined(__clang__) || defined(__GNUC__))
	#define __noinline __attribute__((noinline))
	#ifdef HAVE_LTO
		#define __forceinline __attribute__((always_inline)) inline
	#else
		#define __forceinline inline
	#endif
#else
	#define __forceinline inline
	#define __noinline
#endif
using std::vector;
using std::unordered_map;
using std::unordered_set;
using std::shared_ptr;
using std::unique_ptr;
using std::weak_ptr;
using std::ios;
using std::istream;
using std::ostream;
using std::stringstream;
using utf8::ifstream;
using utf8::ofstream;
using std::list;
using std::max;
using std::string;
using std::atomic_flag;
using std::atomic;
using std::thread;
using std::deque;
using std::optional;
```

## File: Core/Shared/ArmEnums.h
```
#pragma once
#include "pch.h"
enum class ArmOpCategory
{
	BranchExchangeRegister,
	Branch,
	Msr,
	Mrs,
	DataProcessing,
	Multiply,
	MultiplyLong,
	SingleDataTransfer,
	SignedHalfDataTransfer,
	BlockDataTransfer,
	SingleDataSwap,
	SoftwareInterrupt,
	InvalidOp,
};
enum class ArmAluOperation : uint8_t
{
	And,
	Eor,
	Sub,
	Rsb,
	Add,
	Adc,
	Sbc,
	Rsc,
	Tst,
	Teq,
	Cmp,
	Cmn,
	Orr,
	Mov,
	Bic,
	Mvn
};
```

## File: Core/Shared/Audio/AudioPlayerHud.cpp
```cpp
#include "pch.h"
#include "Shared/Audio/AudioPlayerHud.h"
#include "Shared/Audio/SoundMixer.h"
#include "Shared/Video/DebugHud.h"
#include "Shared/Emulator.h"
#include "Shared/EmuSettings.h"
#include "Shared/Video/DrawStringCommand.h"
static constexpr double PI = 3.14159265358979323846;
AudioPlayerHud::AudioPlayerHud(Emulator* emu)
{
	_emu = emu;
	_mixer = emu->GetSoundMixer();
	_hud = emu->GetDebugHud();
	for(int i = 0; i < N; i++) {
		_hannWindow[i] = 0.5f * (1.0f - cos(2.0f * PI * (float)(i) / (float)(N - 1.0f)));
	}
}
string AudioPlayerHud::FormatSeconds(uint32_t s)
{
	string seconds = std::to_string(s % 60);
	if(seconds.size() == 1) {
		seconds = "0" + seconds;
	}
	return std::to_string(s / 60) + ":" + seconds;
}
void AudioPlayerHud::Draw(uint32_t frameCounter, double fps)
{
	AudioTrackInfo trackInfo = _emu->GetAudioTrackInfo();
	if(trackInfo.Position <= 1) {
		_changeTrackPending = false;
	}
	_hud->DrawRectangle(0, 0, 256, 240, 0, true, 1);
	int y = 12;
	auto drawLabel = [=, &y](string label, string content) {
		if(content.size() > 0 && content[0] != 0) {
			_hud->DrawString(10, y, label, 0xBBBBBB, 0, 1);
			_hud->DrawString(57, y, content, 0xFFFFFF, 0, 1);
			y += 10;
		}
	};
	drawLabel("Game:", trackInfo.GameTitle);
	drawLabel("Artist:", trackInfo.Artist);
	drawLabel("Comment:", trackInfo.Comment);
	string position = FormatSeconds((uint32_t)trackInfo.Position);
	string track = "Track: " + std::to_string(trackInfo.TrackNumber) + " / " + std::to_string(trackInfo.TrackCount);
	TextSize size = DrawStringCommand::MeasureString(track);
	uint32_t trackPosX = 256 - size.X - 14;
	_hud->DrawString(trackPosX, 218, track, 0xFFFFFF, 0, 1);
	string trackName;
	if(trackInfo.SongTitle.size() > 0 && trackInfo.SongTitle[0] != 0) {
		trackName = trackInfo.SongTitle;
	} else {
		trackName = _emu->GetRomInfo().RomFile.GetFileName();
	}
	_hud->DrawString(15, 208, trackName, 0xFFFFFF, 0, 1, -1, trackPosX - 20);
	if(trackInfo.Length <= 0) {
		_hud->DrawString(215, 208, " " + position + "   ", 0xFFFFFF, 0, 1);
	} else {
		position += " / " + FormatSeconds((uint32_t)trackInfo.Length);
		_hud->DrawString(177, 208, " " + position + "   ", 0xFFFFFF, 0, 1);
		constexpr int barWidth = 222;
		_hud->DrawRectangle(15, 199, barWidth + 4, 6, 0xBBBBBB, false, 1);
		_hud->DrawRectangle(17, 201, (int)(std::min(1.0, trackInfo.Position / trackInfo.Length) * barWidth), 2, 0x77BBFF, false, 1);
	}
	static constexpr double ranges[8][3] {
		{ 20, 150, 0.5 },
		{ 150, 400, 0.5 },
		{ 400, 700, 0.75 },
		{ 700, 1000, 0.75 },
		{ 1000, 2000, 1 },
		{ 2000, 4000, 1 },
		{ 4000, 6000, 1.25 },
		{ 6000, 20000, 1.25 }
	};
	static constexpr int maxVal = 140;
	int top = 191 - maxVal;
	int bottom = 190;
	int fgColor = 0x555555;
	int fgColor2 = 0x666666;
	int bgColor = 0x222222;
	_hud->DrawLine(0, top - 1, 255, top - 1, fgColor, 1);
	_hud->DrawLine(0, bottom + 1, 255, bottom + 1, fgColor, 1);
	_hud->DrawRectangle(0, top, 256, 140, bgColor, true, 1);
	_hud->DrawLine(192, top, 192, bottom, fgColor, 1);
	_hud->DrawLine(128, top, 128, bottom, fgColor, 1);
	_hud->DrawLine(64, top, 64, bottom, fgColor, 1);
	_hud->DrawLine(224, top, 224, bottom, fgColor2, 1);
	_hud->DrawLine(160, top, 160, bottom, fgColor2, 1);
	_hud->DrawLine(96, top, 96, bottom, fgColor2, 1);
	_hud->DrawLine(32, top, 32, bottom, fgColor2, 1);
	_hud->DrawString(3, top + 10, "20Hz", fgColor, bgColor, 1);
	_hud->DrawString(19, top + 30, "150Hz", fgColor2, bgColor, 1);
	_hud->DrawString(51, top + 10, "400Hz", fgColor, bgColor, 1);
	_hud->DrawString(83, top + 30, "700Hz", fgColor2, bgColor, 1);
	_hud->DrawString(117, top + 10, "1kHz", fgColor, bgColor, 1);
	_hud->DrawString(150, top + 30, "2kHz", fgColor2, bgColor, 1);
	_hud->DrawString(182, top + 10, "4kHz", fgColor, bgColor, 1);
	_hud->DrawString(214, top + 30, "6kHz", fgColor2, bgColor, 1);
	_hud->DrawString(228, top + 10, "20kHz", fgColor, bgColor, 1);
	if(_amplitudes.size() >= N / 2) {
		bool silent = true;
		for(int i = 0; i < 8; i++) {
			for(int j = 0; j < 32; j++) {
				double freqRange = ranges[i][1] - ranges[i][0];
				double startFreq = ranges[i][0] + freqRange * j / 32;
				double endFreq = ranges[i][0] + freqRange * (j + 1) / 32;
				int startIndex = (int)(startFreq / (_sampleRate / N));
				int endIndex = (int)(endFreq / (_sampleRate / N));
				double avgAmp = 0;
				for(int ampIndex = startIndex; ampIndex <= endIndex && ampIndex < _amplitudes.size(); ampIndex++) {
					avgAmp += _amplitudes[ampIndex];
				}
				avgAmp /= (endIndex - startIndex + 1);
				avgAmp *= ranges[i][2];
				avgAmp = std::min<double>(maxVal, avgAmp);
				if(avgAmp >= 1) {
					silent = false;
				}
				int red = std::min(255, (int)(256 * (avgAmp / maxVal) * 2));
				int green = std::max(0, std::min(255, (int)(256 * ((maxVal - avgAmp) / maxVal) * 2)));
				_hud->DrawRectangle(i*32+j, 190, 1, (int)-avgAmp, red << 16 | green << 8, true, 1);
			}
		}
		if(_prevFrameCounter + 1 != frameCounter || _prevFps != fps || _lastAudioFrame > frameCounter) {
			_prevFrameCounter = frameCounter;
			_lastAudioFrame = frameCounter;
			_prevFps = fps;
		} else {
			_prevFrameCounter = frameCounter;
			if(!silent) {
				_lastAudioFrame = frameCounter;
			} else {
				AudioConfig audioCfg = _emu->GetSettings()->GetAudioConfig();
				double silenceLength = (double)(frameCounter - _lastAudioFrame) / fps;
				if(audioCfg.AudioPlayerAutoDetectSilence && silenceLength >= audioCfg.AudioPlayerSilenceDelay) {
					MoveToNextTrack();
				}
			}
		}
	}
}
void AudioPlayerHud::MoveToNextTrack()
{
	if(!_changeTrackPending) {
		_changeTrackPending = true;
		AudioPlayerActionParams params = {};
		AudioPlayerConfig cfg = _emu->GetSettings()->GetAudioPlayerConfig();
		AudioTrackInfo track = _emu->GetAudioTrackInfo();
		if(!cfg.Repeat) {
			if(cfg.Shuffle) {
				std::random_device rd;
				std::mt19937 mt(rd());
				std::uniform_int_distribution<> dist(0, track.TrackCount - 1);
				params.Action = AudioPlayerAction::SelectTrack;
				params.TrackNumber = dist(mt);
			} else {
				params.Action = AudioPlayerAction::NextTrack;
			}
		} else {
			params.Action = AudioPlayerAction::SelectTrack;
			params.TrackNumber = track.TrackNumber - 1;
		}
		_emu->ProcessAudioPlayerAction(params);
	}
}
uint32_t AudioPlayerHud::GetVolume()
{
	AudioTrackInfo info = _emu->GetAudioTrackInfo();
	if(info.Length > 0) {
		if(info.Position >= info.Length) {
			MoveToNextTrack();
			return 0;
		} else if(info.Position >= info.Length - info.FadeLength) {
			double fadeStart = info.Length - info.FadeLength;
			double ratio = 1.0 - ((info.Position - fadeStart) / info.FadeLength);
			return (uint32_t)(ratio * _emu->GetSettings()->GetAudioPlayerConfig().Volume);
		}
	}
	return _emu->GetSettings()->GetAudioPlayerConfig().Volume;
}
void AudioPlayerHud::ProcessSamples(int16_t* samples, size_t sampleCount, uint32_t sampleRate)
{
	_sampleRate = sampleRate;
	for(int i = 0; i < sampleCount; i++) {
		_samples.push_back((samples[i * 2] + samples[i * 2 + 1]) / 2);
		if(_samples.size() > N) {
			_samples.pop_front();
		}
	}
	if(_samples.size() >= N) {
		for(int i = 0; i < N; i++) {
			_input[i] = _samples[i] * _hannWindow[i];
		}
		_fft.transform_real(_input, _out);
		_amplitudes.clear();
		for(int i = 0; i < N / 2; i++) {
			std::complex<double> c = _out[i];
			double amp = sqrt(c.real() * c.real() + c.imag() * c.imag());
			_amplitudes.push_back(amp / N);
		}
	}
}
```

## File: Core/Shared/Audio/AudioPlayerHud.h
```
#pragma once
#include "pch.h"
#include <complex>
#include "Utilities/kissfft.h"
#include "Utilities/Timer.h"
class Emulator;
class SoundMixer;
class DebugHud;
class AudioPlayerHud
{
private:
	static constexpr int N = 2048*4;
	Emulator* _emu = nullptr;
	DebugHud* _hud = nullptr;
	SoundMixer* _mixer = nullptr;
	kissfft<double> _fft = kissfft<double>(N / 2, false);
	std::vector<double> _amplitudes;
	std::deque<int16_t> _samples;
	uint32_t _prevFrameCounter = 0;
	uint32_t _lastAudioFrame = 0;
	double _prevFps = 0;
	bool _changeTrackPending = false;
	uint32_t _sampleRate = 48000;
	double _hannWindow[N] = {};
	double _input[N] = {};
	std::complex<double> _out[N] = {};
	string FormatSeconds(uint32_t s);
	void MoveToNextTrack();
public:
	AudioPlayerHud(Emulator* emu);
	void Draw(uint32_t frameCounter, double fps);
	uint32_t GetVolume();
	void ProcessSamples(int16_t* samples, size_t sampleCount, uint32_t sampleRate);
};
```

## File: Core/Shared/Audio/AudioPlayerTypes.h
```
#pragma once
#include "pch.h"
struct AudioTrackInfo
{
	string GameTitle;
	string SongTitle;
	string Artist;
	string Comment;
	double Position;
	double Length;
	double FadeLength;
	uint32_t TrackNumber;
	uint32_t TrackCount;
};
enum class AudioPlayerAction
{
	NextTrack,
	PrevTrack,
	SelectTrack,
};
struct AudioPlayerActionParams
{
	AudioPlayerAction Action;
	uint32_t TrackNumber;
};
```

## File: Core/Shared/Audio/BaseSoundManager.cpp
```cpp
#include "pch.h"
#include "Shared/Audio/BaseSoundManager.h"
void BaseSoundManager::ProcessLatency(uint32_t readPosition, uint32_t writePosition)
{
	int32_t cursorGap;
	if(writePosition < readPosition) {
		cursorGap = writePosition - readPosition + _bufferSize;
	} else {
		cursorGap = writePosition - readPosition;
	}
	_cursorGaps[_cursorGapIndex] = cursorGap;
	_cursorGapIndex = (_cursorGapIndex + 1) % 60;
	if(_cursorGapIndex == 0) {
		_cursorGapFilled = true;
	}
	if(_cursorGapFilled) {
		uint32_t bytesPerSample = _isStereo ? 4 : 2;
		int32_t gapSum = 0;
		for(int i = 0; i < 60; i++) {
			gapSum += _cursorGaps[i];
		}
		int32_t gapAverage = gapSum / 60;
		_averageLatency = (gapAverage / bytesPerSample) / (double)_sampleRate * 1000;
	}
}
AudioStatistics BaseSoundManager::GetStatistics()
{
	AudioStatistics stats;
	stats.AverageLatency = _averageLatency;
	stats.BufferUnderrunEventCount = _bufferUnderrunEventCount;
	stats.BufferSize = _bufferSize;
	return stats;
}
void BaseSoundManager::ResetStats()
{
	_cursorGapIndex = 0;
	_cursorGapFilled = false;
	_bufferUnderrunEventCount = 0;
	_averageLatency = 0;
}
```

## File: Core/Shared/Audio/BaseSoundManager.h
```
#pragma once
#include "Core/Shared/Interfaces/IAudioDevice.h"
class BaseSoundManager : public IAudioDevice
{
public:
	void ProcessLatency(uint32_t readPosition, uint32_t writePosition);
	AudioStatistics GetStatistics();
protected:
	bool _isStereo;
	uint32_t _sampleRate = 0;
	double _averageLatency = 0;
	uint32_t _bufferSize = 0x10000;
	uint32_t _bufferUnderrunEventCount = 0;
	int32_t _cursorGaps[60];
	int32_t _cursorGapIndex = 0;
	bool _cursorGapFilled = false;
	void ResetStats();
};
```

## File: Core/Shared/Audio/PcmReader.cpp
```cpp
#include "pch.h"
#include "Shared/Audio/PcmReader.h"
#include "Utilities/VirtualFile.h"
#include "Utilities/Audio/HermiteResampler.h"
PcmReader::PcmReader()
{
	_done = true;
	_loopOffset = 8;
	_outputBuffer = new int16_t[20000];
}
PcmReader::~PcmReader()
{
	delete[] _outputBuffer;
}
bool PcmReader::Init(string filename, bool loop, uint32_t startOffset)
{
	if(_file) {
		_file.close();
	}
	_file.open(filename, ios::binary);
	if(_file) {
		_file.seekg(0, ios::end);
		_fileSize = (uint32_t)_file.tellg();
		if(_fileSize < 12) {
			return false;
		}
		_file.seekg(4, ios::beg);
		uint32_t loopOffset = (uint8_t)_file.get();
		loopOffset |= ((uint8_t)_file.get()) << 8;
		loopOffset |= ((uint8_t)_file.get()) << 16;
		loopOffset |= ((uint8_t)_file.get()) << 24;
		_loopOffset = (uint32_t)loopOffset;
		_prevLeft = 0;
		_prevRight = 0;
		_done = false;
		_loop = loop;
		_fileOffset = startOffset;
		_file.seekg(_fileOffset, ios::beg);
		_leftoverSampleCount = 0;
		_pcmBuffer.clear();
		_resampler.Reset();
		return true;
	} else {
		_done = true;
		return false;
	}
}
bool PcmReader::IsPlaybackOver()
{
	return _done;
}
void PcmReader::SetSampleRate(uint32_t sampleRate)
{
	if(sampleRate != _sampleRate) {
		_sampleRate = sampleRate;
		_resampler.SetSampleRates(PcmReader::PcmSampleRate, _sampleRate);
	}
}
void PcmReader::SetLoopFlag(bool loop)
{
	_loop = loop;
}
void PcmReader::ReadSample(int16_t &left, int16_t &right)
{
	uint8_t val[4];
	_file.get(((char*)val)[0]);
	_file.get(((char*)val)[1]);
	_file.get(((char*)val)[2]);
	_file.get(((char*)val)[3]);
	left = val[0] | (val[1] << 8);
	right = val[2] | (val[3] << 8);
}
void PcmReader::LoadSamples(uint32_t samplesToLoad)
{
	uint32_t samplesRead = 0;
	int16_t left = 0;
	int16_t right = 0;
	for(uint32_t i = _fileOffset; i < _fileSize && samplesRead < samplesToLoad; i+=4) {
		ReadSample(left, right);
		_pcmBuffer.push_back(left);
		_pcmBuffer.push_back(right);
		_prevLeft = left;
		_prevRight = right;
		_fileOffset += 4;
		samplesRead++;
		if(samplesRead < samplesToLoad && i + 4 >= _fileSize) {
			if(_loop) {
				i = _loopOffset * 4 + 8;
				_fileOffset = i;
				_file.seekg(_fileOffset, ios::beg);
			} else {
				_done = true;
			}
		}
	}
}
void PcmReader::ApplySamples(int16_t *buffer, size_t sampleCount, uint8_t volume)
{
	if(_done) {
		return;
	}
	int32_t samplesNeeded = (int32_t)sampleCount - _resampler.GetPendingCount();
	if(samplesNeeded > 0) {
		uint32_t samplesToLoad = samplesNeeded * PcmReader::PcmSampleRate / _sampleRate + 2;
		LoadSamples(samplesToLoad);
	}
	uint32_t samplesRead = _resampler.Resample<false>(_pcmBuffer.data(), (uint32_t)_pcmBuffer.size() / 2, _outputBuffer, sampleCount);
	_pcmBuffer.clear();
	uint32_t samplesToProcess = (uint32_t)samplesRead * 2;
	for(uint32_t i = 0; i < samplesToProcess; i++) {
		buffer[i] += (int16_t)((int32_t)_outputBuffer[i] * volume / 255);
	}
}
uint32_t PcmReader::GetOffset()
{
	return _fileOffset;
}
```

## File: Core/Shared/Audio/PcmReader.h
```
#pragma once
#include "pch.h"
#include "Utilities/Audio/stb_vorbis.h"
#include "Utilities/Audio/HermiteResampler.h"
class PcmReader
{
private:
	static constexpr int PcmSampleRate = 44100;
	static constexpr int SamplesToRead = 100;
	int16_t* _outputBuffer = nullptr;
	ifstream _file;
	uint32_t _fileOffset = 0;
	uint32_t _fileSize = 0;
	uint32_t _loopOffset = 0;
	int16_t _prevLeft = 0;
	int16_t _prevRight = 0;
	bool _loop = false;
	bool _done = false;
	HermiteResampler _resampler;
	vector<int16_t> _pcmBuffer;
	uint32_t _leftoverSampleCount = 0;
	uint32_t _sampleRate = 0;
	void LoadSamples(uint32_t samplesToLoad);
	void ReadSample(int16_t &left, int16_t &right);
public:
	PcmReader();
	~PcmReader();
	bool Init(string filename, bool loop, uint32_t startOffset = 0);
	bool IsPlaybackOver();
	void SetSampleRate(uint32_t sampleRate);
	void SetLoopFlag(bool loop);
	void ApplySamples(int16_t* buffer, size_t sampleCount, uint8_t volume);
	uint32_t GetOffset();
};
```

## File: Core/Shared/Audio/SoundMixer.cpp
```cpp
#include "pch.h"
#include "Shared/Audio/SoundMixer.h"
#include "Shared/Audio/AudioPlayerHud.h"
#include "Shared/Emulator.h"
#include "Shared/EmuSettings.h"
#include "Shared/Audio/SoundResampler.h"
#include "Shared/RewindManager.h"
#include "Shared/Video/VideoRenderer.h"
#include "Shared/Audio/WaveRecorder.h"
#include "Shared/Interfaces/IAudioProvider.h"
#include "Utilities/Audio/Equalizer.h"
#include "Utilities/Audio/ReverbFilter.h"
#include "Utilities/Audio/CrossFeedFilter.h"
SoundMixer::SoundMixer(Emulator* emu)
{
	_emu = emu;
	_audioDevice = nullptr;
	_resampler.reset(new SoundResampler(emu));
	_sampleBuffer = new int16_t[0x10000];
	_pitchAdjustBuffer = new int16_t[0x8000];
	_reverbFilter.reset(new ReverbFilter());
	_crossFeedFilter.reset(new CrossFeedFilter());
}
SoundMixer::~SoundMixer()
{
	delete[] _sampleBuffer;
	delete[] _pitchAdjustBuffer;
}
void SoundMixer::RegisterAudioDevice(IAudioDevice *audioDevice)
{
	_audioDevice = audioDevice;
}
void SoundMixer::RegisterAudioProvider(IAudioProvider* provider)
{
	_audioProviders.push_back(provider);
}
void SoundMixer::UnregisterAudioProvider(IAudioProvider* provider)
{
	vector<IAudioProvider*>& vec = _audioProviders;
	vec.erase(std::remove(vec.begin(), vec.end(), provider), vec.end());
}
AudioStatistics SoundMixer::GetStatistics()
{
	if(_audioDevice) {
		return _audioDevice->GetStatistics();
	} else {
		return AudioStatistics();
	}
}
void SoundMixer::StopAudio(bool clearBuffer)
{
	if(_audioDevice) {
		if(clearBuffer) {
			_audioDevice->Stop();
		} else {
			_audioDevice->Pause();
		}
	}
}
void SoundMixer::PlayAudioBuffer(int16_t* samples, uint32_t sampleCount, uint32_t sourceRate)
{
	if(sampleCount == 0) {
		return;
	}
	EmuSettings* settings = _emu->GetSettings();
	AudioPlayerHud* audioPlayer = _emu->GetAudioPlayerHud();
	AudioConfig cfg = settings->GetAudioConfig();
	bool isRecording = _waveRecorder || _emu->GetVideoRenderer()->IsRecording();
	uint32_t masterVolume = audioPlayer ? audioPlayer->GetVolume() : cfg.MasterVolume;
	if(!isRecording) {
		if(!audioPlayer && settings->CheckFlag(EmulationFlags::InBackground)) {
			if(cfg.MuteSoundInBackground) {
				masterVolume = 0;
			} else if(cfg.ReduceSoundInBackground) {
				masterVolume = cfg.VolumeReduction == 100 ? 0 : masterVolume * (100 - cfg.VolumeReduction) / 100;
			}
		} else if(cfg.ReduceSoundInFastForward && settings->CheckFlag(EmulationFlags::TurboOrRewind)) {
			masterVolume = cfg.VolumeReduction == 100 ? 0 : masterVolume * (100 - cfg.VolumeReduction) / 100;
		}
	}
	_leftSample = samples[0];
	_rightSample = samples[1];
	int16_t *out = _sampleBuffer;
	uint32_t count = _resampler->Resample(samples, sampleCount, sourceRate, cfg.SampleRate, out, 0x10000 / 2);
	uint32_t targetRate = (uint32_t)(cfg.SampleRate * _resampler->GetRateAdjustment());
	for(IAudioProvider* provider : _audioProviders) {
		provider->MixAudio(out, count, targetRate);
	}
	if(cfg.EnableEqualizer) {
		ProcessEqualizer(out, count, targetRate);
	}
	if(audioPlayer) {
		audioPlayer->ProcessSamples(out, count, targetRate);
	}
	if(cfg.ReverbEnabled) {
		if(cfg.ReverbStrength > 0) {
			_reverbFilter->ApplyFilter(out, count, cfg.SampleRate, cfg.ReverbStrength / 10.0, cfg.ReverbDelay / 10.0);
		} else {
			_reverbFilter->ResetFilter();
		}
	}
	if(cfg.CrossFeedEnabled) {
		_crossFeedFilter->ApplyFilter(out, count, cfg.CrossFeedRatio);
	}
	if(masterVolume < 100) {
		for(uint32_t i = 0; i < count * 2; i++) {
			out[i] = (int32_t)out[i] * (int32_t)masterVolume / 100;
		}
	}
	RewindManager* rewindManager = _emu->GetRewindManager();
	if(!_emu->IsRunAheadFrame() && rewindManager && rewindManager->SendAudio(out, count)) {
		if(isRecording) {
			shared_ptr<WaveRecorder> recorder = _waveRecorder.lock();
			if(recorder) {
				if(!recorder->WriteSamples(out, count, cfg.SampleRate, true)) {
					StopRecording();
				}
			}
			_emu->GetVideoRenderer()->AddRecordingSound(out, count, cfg.SampleRate);
		}
		if(!_emu->IsPaused() && _audioDevice) {
			if(cfg.EnableAudio) {
				uint32_t emulationSpeed = _emu->GetSettings()->GetEmulationSpeed();
				if(emulationSpeed > 0 && emulationSpeed < 100) {
					_pitchAdjust.SetSampleRates(targetRate, targetRate * 100.0 / emulationSpeed);
					count = _pitchAdjust.Resample<false>(_sampleBuffer, count, _pitchAdjustBuffer, 0x8000 / 2);
					if(count >= 0x4000) {
						memset(_pitchAdjustBuffer, 0, 0x8000 * sizeof(int16_t));
					}
					out = _pitchAdjustBuffer;
				}
				_audioDevice->PlayBuffer(out, count, cfg.SampleRate, true);
				_audioDevice->ProcessEndOfFrame();
			} else {
				_audioDevice->Stop();
			}
		}
	}
}
void SoundMixer::ProcessEqualizer(int16_t* samples, uint32_t sampleCount, uint32_t targetRate)
{
	AudioConfig cfg = _emu->GetSettings()->GetAudioConfig();
	if(!_equalizer) {
		_equalizer.reset(new Equalizer());
	}
	vector<double> bandGains = {
		cfg.Band1Gain, cfg.Band2Gain, cfg.Band3Gain, cfg.Band4Gain, cfg.Band5Gain,
		cfg.Band6Gain, cfg.Band7Gain, cfg.Band8Gain, cfg.Band9Gain, cfg.Band10Gain,
		cfg.Band11Gain, cfg.Band12Gain, cfg.Band13Gain, cfg.Band14Gain, cfg.Band15Gain,
		cfg.Band16Gain, cfg.Band17Gain, cfg.Band18Gain, cfg.Band19Gain, cfg.Band20Gain
	};
	_equalizer->UpdateEqualizers(bandGains, cfg.SampleRate);
	_equalizer->ApplyEqualizer(sampleCount, samples);
}
double SoundMixer::GetRateAdjustment()
{
	return _resampler->GetRateAdjustment();
}
void SoundMixer::StartRecording(string filepath)
{
	_waveRecorder.reset(new WaveRecorder(filepath, _emu->GetSettings()->GetAudioConfig().SampleRate, true));
}
void SoundMixer::StopRecording()
{
	_waveRecorder.reset();
}
bool SoundMixer::IsRecording()
{
	return _waveRecorder != nullptr;
}
void SoundMixer::GetLastSamples(int16_t &left, int16_t &right)
{
	left = _leftSample;
	right = _rightSample;
}
```

## File: Core/Shared/Audio/SoundMixer.h
```
#pragma once
#include "pch.h"
#include "Core/Shared/Interfaces/IAudioDevice.h"
#include "Utilities/safe_ptr.h"
#include "Utilities/Audio/HermiteResampler.h"
class Emulator;
class Equalizer;
class SoundResampler;
class WaveRecorder;
class IAudioProvider;
class CrossFeedFilter;
class ReverbFilter;
class SoundMixer
{
private:
	IAudioDevice *_audioDevice;
	vector<IAudioProvider*> _audioProviders;
	Emulator *_emu;
	unique_ptr<Equalizer> _equalizer;
	unique_ptr<SoundResampler> _resampler;
	safe_ptr<WaveRecorder> _waveRecorder;
	int16_t *_sampleBuffer = nullptr;
	HermiteResampler _pitchAdjust;
	int16_t* _pitchAdjustBuffer = nullptr;
	int16_t _leftSample = 0;
	int16_t _rightSample = 0;
	unique_ptr<CrossFeedFilter> _crossFeedFilter;
	unique_ptr<ReverbFilter> _reverbFilter;
	void ProcessEqualizer(int16_t *samples, uint32_t sampleCount, uint32_t targetRate);
public:
	SoundMixer(Emulator *emu);
	~SoundMixer();
	void PlayAudioBuffer(int16_t *samples, uint32_t sampleCount, uint32_t sourceRate);
	void StopAudio(bool clearBuffer = false);
	void RegisterAudioDevice(IAudioDevice *audioDevice);
	void RegisterAudioProvider(IAudioProvider* provider);
	void UnregisterAudioProvider(IAudioProvider* provider);
	AudioStatistics GetStatistics();
	double GetRateAdjustment();
	void StartRecording(string filepath);
	void StopRecording();
	bool IsRecording();
	void GetLastSamples(int16_t &left, int16_t &right);
};
```

## File: Core/Shared/Audio/SoundResampler.cpp
```cpp
#include "pch.h"
#include "Shared/Emulator.h"
#include "Shared/EmuSettings.h"
#include "Shared/Audio/SoundMixer.h"
#include "Shared/Audio/SoundResampler.h"
#include "Shared/Video/VideoRenderer.h"
#include "Utilities/Audio/HermiteResampler.h"
SoundResampler::SoundResampler(Emulator* emu)
{
	_emu = emu;
}
SoundResampler::~SoundResampler()
{
}
double SoundResampler::GetRateAdjustment()
{
	return _rateAdjustment;
}
uint32_t SoundResampler::GetTargetRate()
{
	return (uint32_t)_previousTargetRate;
}
double SoundResampler::GetTargetRateAdjustment()
{
	AudioConfig cfg = _emu->GetSettings()->GetAudioConfig();
	bool isRecording = _emu->GetSoundMixer()->IsRecording() || _emu->GetVideoRenderer()->IsRecording();
	if(!isRecording && !cfg.DisableDynamicSampleRate) {
		AudioStatistics stats = _emu->GetSoundMixer()->GetStatistics();
		if(stats.AverageLatency > 0 && _emu->GetSettings()->GetEmulationSpeed() == 100) {
			constexpr int32_t maxGap = 3;
			constexpr int32_t maxSubAdjustment = 3600;
			int32_t requestedLatency = (int32_t)cfg.AudioLatency;
			double latencyGap = stats.AverageLatency - requestedLatency;
			double adjustment = std::min(0.0025, (std::ceil((std::abs(latencyGap) - maxGap) * 8)) * 0.00003125);
			if(latencyGap < 0 && _underTarget < maxSubAdjustment) {
				_underTarget++;
			} else if(latencyGap > 0 && _underTarget > -maxSubAdjustment) {
				_underTarget--;
			}
			double subAdjustment = 0.00003125 * _underTarget / 180;
			if(adjustment > 0) {
				if(latencyGap > maxGap) {
					_rateAdjustment = 1 - adjustment + subAdjustment;
				} else if(latencyGap < -maxGap) {
					_rateAdjustment = 1 + adjustment + subAdjustment;
				}
			} else if(std::abs(latencyGap) < 1) {
				_rateAdjustment = 1.0 + subAdjustment;
			}
		} else {
			_underTarget = 0;
			_rateAdjustment = 1.0;
		}
	} else {
		_underTarget = 0;
		_rateAdjustment = 1.0;
	}
	return _rateAdjustment;
}
void SoundResampler::UpdateTargetSampleRate(uint32_t sourceRate, uint32_t sampleRate)
{
	double inputRate = sourceRate;
	if(_emu->GetSettings()->GetVideoConfig().IntegerFpsMode) {
		double baseFps = _emu->GetConsoleUnsafe()->GetFps();
		double roundedFps = _emu->GetFps();
		inputRate = sourceRate * (roundedFps / baseFps);
	}
	double targetRate = sampleRate * GetTargetRateAdjustment();
	if(targetRate != _previousTargetRate || inputRate != _prevInputRate) {
		_previousTargetRate = targetRate;
		_prevInputRate = inputRate;
		_resampler.SetSampleRates(inputRate, targetRate);
	}
}
uint32_t SoundResampler::Resample(int16_t *inSamples, uint32_t sampleCount, uint32_t sourceRate, uint32_t sampleRate, int16_t *outSamples, uint32_t maxOutCount)
{
	UpdateTargetSampleRate(sourceRate, sampleRate);
	return _resampler.Resample<false>(inSamples, sampleCount, outSamples, maxOutCount);
}
```

## File: Core/Shared/Audio/SoundResampler.h
```
#pragma once
#include "pch.h"
#include "Utilities/Audio/HermiteResampler.h"
class Emulator;
class SoundResampler
{
private:
	Emulator *_emu;
	double _rateAdjustment = 1.0;
	double _previousTargetRate = 0;
	double _prevInputRate = 0;
	int32_t _underTarget = 0;
	HermiteResampler _resampler;
	double GetTargetRateAdjustment();
	void UpdateTargetSampleRate(uint32_t sourceRate, uint32_t sampleRate);
public:
	SoundResampler(Emulator *emu);
	~SoundResampler();
	double GetRateAdjustment();
	uint32_t GetTargetRate();
	uint32_t Resample(int16_t *inSamples, uint32_t sampleCount, uint32_t sourceRate, uint32_t sampleRate, int16_t *outSamples, uint32_t maxOutCount);
};
```

## File: Core/Shared/Audio/WaveRecorder.cpp
```cpp
#include "pch.h"
#include "Shared/Audio/WaveRecorder.h"
#include "Shared/MessageManager.h"
WaveRecorder::WaveRecorder(string outputFile, uint32_t sampleRate, bool isStereo)
{
	_stream = ofstream(outputFile, ios::out | ios::binary);
	_outputFile = outputFile;
	_streamSize = 0;
	_sampleRate = sampleRate;
	_isStereo = isStereo;
	if(_stream) {
		WriteHeader();
		MessageManager::DisplayMessage("SoundRecorder", "SoundRecorderStarted", _outputFile);
	}
}
WaveRecorder::~WaveRecorder()
{
	CloseFile();
}
void WaveRecorder::WriteHeader()
{
	_stream << "RIFF";
	uint32_t size = 0;
	_stream.write((char*)&size, sizeof(size));
	_stream << "WAVE";
	_stream << "fmt ";
	uint32_t chunkSize = 16;
	_stream.write((char*)&chunkSize, sizeof(chunkSize));
	uint16_t format = 1;
	uint16_t channelCount = _isStereo ? 2 : 1;
	uint16_t bytesPerSample = 2;
	uint16_t blockAlign = channelCount * bytesPerSample;
	uint32_t byteRate = _sampleRate * channelCount * bytesPerSample;
	uint16_t bitsPerSample = bytesPerSample * 8;
	_stream.write((char*)&format, sizeof(format));
	_stream.write((char*)&channelCount, sizeof(channelCount));
	_stream.write((char*)&_sampleRate, sizeof(_sampleRate));
	_stream.write((char*)&byteRate, sizeof(byteRate));
	_stream.write((char*)&blockAlign, sizeof(blockAlign));
	_stream.write((char*)&bitsPerSample, sizeof(bitsPerSample));
	_stream << "data";
	_stream.write((char*)&size, sizeof(size));
}
bool WaveRecorder::WriteSamples(int16_t * samples, uint32_t sampleCount, uint32_t sampleRate, bool isStereo)
{
	if(_sampleRate != sampleRate || _isStereo != isStereo) {
		return false;
	} else {
		uint32_t sampleBytes = sampleCount * (isStereo ? 4 : 2);
		_stream.write((char*)samples, sampleBytes);
		_streamSize += sampleBytes;
		return true;
	}
}
void WaveRecorder::UpdateSizeValues()
{
	_stream.seekp(4, ios::beg);
	uint32_t fileSize = _streamSize + 36;
	_stream.write((char*)&fileSize, sizeof(fileSize));
	_stream.seekp(40, ios::beg);
	_stream.write((char*)&_streamSize, sizeof(_streamSize));
}
void WaveRecorder::CloseFile()
{
	if(_stream && _stream.is_open()) {
		UpdateSizeValues();
		_stream.close();
		MessageManager::DisplayMessage("SoundRecorder", "SoundRecorderStopped", _outputFile);
	}
}
```

## File: Core/Shared/Audio/WaveRecorder.h
```
#include "pch.h"
class WaveRecorder
{
private:
	std::ofstream _stream;
	uint32_t _streamSize;
	uint32_t _sampleRate;
	bool _isStereo;
	string _outputFile;
	void WriteHeader();
	void UpdateSizeValues();
	void CloseFile();
public:
	WaveRecorder(string outputFile, uint32_t sampleRate, bool isStereo);
	~WaveRecorder();
	bool WriteSamples(int16_t* samples, uint32_t sampleCount, uint32_t sampleRate, bool isStereo);
};
```

## File: Core/Shared/BaseControlDevice.cpp
```cpp
#include "pch.h"
#include "Shared/BaseControlDevice.h"
#include "Shared/Emulator.h"
#include "Shared/KeyManager.h"
#include "Shared/EmuSettings.h"
#include "Shared/InputHud.h"
#include "Utilities/StringUtilities.h"
#include "Utilities/Serializer.h"
BaseControlDevice::BaseControlDevice(Emulator* emu, ControllerType type, uint8_t port, KeyMappingSet keyMappingSet)
{
	_emu = emu;
	_type = type;
	_port = port;
	_strobe = false;
	_keyMappings = keyMappingSet.GetKeyMappingArray();
}
BaseControlDevice::~BaseControlDevice()
{
}
uint8_t BaseControlDevice::GetPort()
{
	return _port;
}
ControllerType BaseControlDevice::GetControllerType()
{
	return _type;
}
void BaseControlDevice::SetStateFromInput()
{
	ClearState();
	InternalSetStateFromInput();
}
void BaseControlDevice::InternalSetStateFromInput()
{
}
bool BaseControlDevice::IsCurrentPort(uint16_t addr)
{
	return _port == (addr - 0x4016);
}
bool BaseControlDevice::IsExpansionDevice()
{
	return _port == BaseControlDevice::ExpDevicePort;
}
void BaseControlDevice::StrobeProcessRead()
{
	if(_strobe) {
		RefreshStateBuffer();
	}
}
void BaseControlDevice::StrobeProcessWrite(uint8_t value)
{
	bool prevStrobe = _strobe;
	_strobe = (value & 0x01) == 0x01;
	if(prevStrobe && !_strobe) {
		RefreshStateBuffer();
	}
}
void BaseControlDevice::ClearState()
{
	auto lock = _stateLock.AcquireSafe();
	_state = ControlDeviceState();
}
ControlDeviceState BaseControlDevice::GetRawState()
{
	auto lock = _stateLock.AcquireSafe();
	return _state;
}
void BaseControlDevice::DrawController(InputHud& hud)
{
	InputConfig& cfg = _emu->GetSettings()->GetInputConfig();
	if(hud.GetControllerIndex() < 8 && cfg.DisplayInputPort[hud.GetControllerIndex()]) {
		InternalDrawController(hud);
	}
	hud.EndDrawController();
}
void BaseControlDevice::SetRawState(ControlDeviceState state)
{
	auto lock = _stateLock.AcquireSafe();
	_state = state;
}
void BaseControlDevice::SetTextState(string textState)
{
	auto lock = _stateLock.AcquireSafe();
	ClearState();
	if(IsRawString()) {
		_state.State.insert(_state.State.end(), textState.begin(), textState.end());
	} else {
		if(HasCoordinates()) {
			vector<string> data = StringUtilities::Split(textState, ' ');
			if(data.size() >= 3) {
				MousePosition pos;
				try {
					pos.X = (int16_t)std::stol(data[0]);
					pos.Y = (int16_t)std::stol(data[1]);
				} catch(std::exception&) {
					pos.X = -1;
					pos.Y = -1;
				}
				SetCoordinates(pos);
				textState = data[2];
			}
		}
		int i = 0;
		for(char c : textState) {
			if(c != ':') {
				if(c != '.') {
					SetBit(i);
				}
				i++;
			}
		}
	}
}
string BaseControlDevice::GetTextState()
{
	auto lock = _stateLock.AcquireSafe();
	if(IsRawString()) {
		return string((char*)_state.State.data(), _state.State.size());
	} else {
		string keyNames = GetKeyNames();
		string output = "";
		if(HasCoordinates()) {
			MousePosition pos = GetCoordinates();
			output += std::to_string(pos.X) + " " + std::to_string(pos.Y) + " ";
		}
		int keyNumber = 0;
		for(size_t i = 0; i < keyNames.size(); i++) {
			if(keyNames[i] != ':') {
				output += IsPressed((uint8_t)keyNumber) ? keyNames[i] : '.';
				keyNumber++;
			} else {
				output += ':';
			}
		}
		return output;
	}
}
void BaseControlDevice::EnsureCapacity(int32_t minBitCount)
{
	auto lock = _stateLock.AcquireSafe();
	uint32_t minByteCount = minBitCount / 8 + 1 + (HasCoordinates() ? 32 : 0);
	int32_t gap = minByteCount - (int32_t)_state.State.size();
	if(gap > 0) {
		_state.State.insert(_state.State.end(), gap, 0);
	}
}
bool BaseControlDevice::HasCoordinates()
{
	return false;
}
bool BaseControlDevice::IsRawString()
{
	return false;
}
uint32_t BaseControlDevice::GetByteIndex(uint8_t bit)
{
	return bit / 8 + (HasCoordinates() ? 4 : 0);
}
bool BaseControlDevice::IsPressed(uint8_t bit)
{
	auto lock = _stateLock.AcquireSafe();
	EnsureCapacity(bit);
	uint8_t bitMask = 1 << (bit % 8);
	return (_state.State[GetByteIndex(bit)] & bitMask) != 0;
}
void BaseControlDevice::SetBitValue(uint8_t bit, bool set)
{
	if(set) {
		SetBit(bit);
	} else {
		ClearBit(bit);
	}
}
void BaseControlDevice::SetBit(uint8_t bit)
{
	auto lock = _stateLock.AcquireSafe();
	EnsureCapacity(bit);
	uint8_t bitMask = 1 << (bit % 8);
	_state.State[GetByteIndex(bit)] |= bitMask;
}
void BaseControlDevice::ClearBit(uint8_t bit)
{
	auto lock = _stateLock.AcquireSafe();
	EnsureCapacity(bit);
	uint8_t bitMask = 1 << (bit % 8);
	_state.State[GetByteIndex(bit)] &= ~bitMask;
}
void BaseControlDevice::InvertBit(uint8_t bit)
{
	if(IsPressed(bit)) {
		ClearBit(bit);
	} else {
		SetBit(bit);
	}
}
void BaseControlDevice::SetPressedState(uint8_t bit, uint16_t keyCode)
{
	if(KeyManager::IsKeyPressed(keyCode)) {
		SetBit(bit);
	}
}
void BaseControlDevice::SetPressedState(uint8_t bit, bool enabled)
{
	if(enabled) {
		SetBit(bit);
	}
}
void BaseControlDevice::SetCoordinates(MousePosition pos)
{
	if(!_emu->GetSettings()->IsInputEnabled()) {
		return;
	}
	auto lock = _stateLock.AcquireSafe();
	EnsureCapacity(-1);
	_state.State[0] = pos.X & 0xFF;
	_state.State[1] = (pos.X >> 8) & 0xFF;
	_state.State[2] = pos.Y & 0xFF;
	_state.State[3] = (pos.Y >> 8) & 0xFF;
}
MousePosition BaseControlDevice::GetCoordinates()
{
	auto lock = _stateLock.AcquireSafe();
	EnsureCapacity(-1);
	MousePosition pos;
	pos.X = _state.State[0] | (_state.State[1] << 8);
	pos.Y = _state.State[2] | (_state.State[3] << 8);
	return pos;
}
void BaseControlDevice::Connect()
{
	_connected = true;
}
void BaseControlDevice::Disconnect()
{
	_connected = false;
}
bool BaseControlDevice::IsConnected()
{
	return _connected;
}
void BaseControlDevice::SetMovement(MouseMovement mov)
{
	if(!_emu->GetSettings()->IsInputEnabled()) {
		return;
	}
	MouseMovement prev = GetMovement();
	mov.dx += prev.dx;
	mov.dy += prev.dy;
	SetCoordinates({ mov.dx, mov.dy });
}
MouseMovement BaseControlDevice::GetMovement()
{
	MousePosition pos = GetCoordinates();
	SetCoordinates({ 0, 0 });
	return { pos.X, pos.Y };
}
bool BaseControlDevice::HasControllerType(ControllerType type)
{
	return _type == type;
}
void BaseControlDevice::SwapButtons(shared_ptr<BaseControlDevice> state1, uint8_t button1, shared_ptr<BaseControlDevice> state2, uint8_t button2)
{
	bool pressed1 = state1->IsPressed(button1);
	bool pressed2 = state2->IsPressed(button2);
	state1->ClearBit(button1);
	state2->ClearBit(button2);
	if(pressed1) {
		state2->SetBit(button2);
	}
	if(pressed2) {
		state1->SetBit(button1);
	}
}
void BaseControlDevice::Serialize(Serializer &s)
{
	auto lock = _stateLock.AcquireSafe();
	SV(_strobe);
	SVVector(_state.State);
}
```

## File: Core/Shared/BaseControlManager.cpp
```cpp
#include "pch.h"
#include "Shared/BaseControlManager.h"
#include "Shared/Emulator.h"
#include "Shared/EmuSettings.h"
#include "Shared/KeyManager.h"
#include "Shared/ControllerHub.h"
#include "Shared/Interfaces/IKeyManager.h"
#include "Shared/Interfaces/IInputProvider.h"
#include "Shared/Interfaces/IInputRecorder.h"
#include "Shared/SystemActionManager.h"
#include "Shared/EventType.h"
#include "Shared/MessageManager.h"
#include "Utilities/Serializer.h"
BaseControlManager::BaseControlManager(Emulator* emu, CpuType cpuType)
{
	_emu = emu;
	_cpuType = cpuType;
	_pollCounter = 0;
	AddSystemControlDevice(_emu->GetSystemActionManager());
	UpdateControlDevices();
}
BaseControlManager::~BaseControlManager()
{
}
void BaseControlManager::AddSystemControlDevice(shared_ptr<BaseControlDevice> device)
{
	_controlDevices.clear();
	_systemDevices.push_back(device);
	UpdateControlDevices();
}
void BaseControlManager::RegisterInputProvider(IInputProvider* provider)
{
	auto lock = _deviceLock.AcquireSafe();
	_inputProviders.push_back(provider);
}
void BaseControlManager::UnregisterInputProvider(IInputProvider* provider)
{
	auto lock = _deviceLock.AcquireSafe();
	vector<IInputProvider*>& vec = _inputProviders;
	vec.erase(std::remove(vec.begin(), vec.end(), provider), vec.end());
}
void BaseControlManager::RegisterInputRecorder(IInputRecorder* provider)
{
	auto lock = _deviceLock.AcquireSafe();
	_inputRecorders.push_back(provider);
}
void BaseControlManager::UnregisterInputRecorder(IInputRecorder* provider)
{
	auto lock = _deviceLock.AcquireSafe();
	vector<IInputRecorder*>& vec = _inputRecorders;
	vec.erase(std::remove(vec.begin(), vec.end(), provider), vec.end());
}
vector<ControllerData> BaseControlManager::GetPortStates()
{
	vector<ControllerData> states;
	for(shared_ptr<BaseControlDevice>& device : _controlDevices) {
		states.push_back({
			device->GetControllerType(),
			device->GetRawState(),
			device->GetPort()
		});
	}
	return states;
}
shared_ptr<BaseControlDevice> BaseControlManager::GetControlDevice(uint8_t port, uint8_t subPort)
{
	auto lock = _deviceLock.AcquireSafe();
	for(size_t i = 0; i < _controlDevices.size(); i++) {
		if(_controlDevices[i] && _controlDevices[i]->GetPort() == port) {
			shared_ptr<IControllerHub> hub = std::dynamic_pointer_cast<IControllerHub>(_controlDevices[i]);
			if(hub) {
				return hub->GetController(subPort);
			} else {
				return subPort == 0 ? _controlDevices[i] : nullptr;
			}
		}
	}
	return nullptr;
}
shared_ptr<BaseControlDevice> BaseControlManager::GetControlDeviceByIndex(uint8_t index)
{
	auto lock = _deviceLock.AcquireSafe();
	int counter = 0;
	for(size_t i = 0; i < _controlDevices.size(); i++) {
		if(_controlDevices[i] && _controlDevices[i]->GetPort() <= 2) {
			shared_ptr<IControllerHub> hub = std::dynamic_pointer_cast<IControllerHub>(_controlDevices[i]);
			if(hub) {
				int portCount = hub->GetHubPortCount();
				for(int j = 0; j < portCount; j++) {
					shared_ptr<BaseControlDevice> device = hub->GetController(j);
					if(counter == index) {
						return device;
					}
					counter++;
				}
			} else {
				if(counter == index) {
					return _controlDevices[i];
				}
				counter++;
			}
		}
	}
	return nullptr;
}
void BaseControlManager::RefreshHubState()
{
	auto lock = _deviceLock.AcquireSafe();
	for(size_t i = 0; i < _controlDevices.size(); i++) {
		if(_controlDevices[i] && _controlDevices[i]->GetPort() <= 2) {
			shared_ptr<IControllerHub> hub = std::dynamic_pointer_cast<IControllerHub>(_controlDevices[i]);
			if(hub) {
				hub->RefreshHubState();
			}
		}
	}
}
vector<shared_ptr<BaseControlDevice>> BaseControlManager::GetControlDevices()
{
	return _controlDevices;
}
void BaseControlManager::Serialize(Serializer& s)
{
	SV(_pollCounter);
}
void BaseControlManager::RegisterControlDevice(shared_ptr<BaseControlDevice> controlDevice)
{
	controlDevice->Init();
	_controlDevices.push_back(controlDevice);
}
void BaseControlManager::ClearDevices()
{
	_controlDevices.clear();
	for(shared_ptr<BaseControlDevice> device : _systemDevices) {
		RegisterControlDevice(device);
	}
}
void BaseControlManager::UpdateInputState()
{
	KeyManager::RefreshKeyState();
	auto lock = _deviceLock.AcquireSafe();
	for(shared_ptr<BaseControlDevice>& device : _controlDevices) {
		device->ClearState();
		device->SetStateFromInput();
		for(size_t i = 0; i < _inputProviders.size(); i++) {
			IInputProvider* provider = _inputProviders[i];
			if(provider->SetInput(device.get())) {
				break;
			}
		}
		device->OnAfterSetState();
	}
	_emu->ProcessEvent(EventType::InputPolled, _cpuType);
	if(!_emu->IsRunAheadFrame()) {
		for(IInputRecorder* recorder : _inputRecorders) {
			recorder->RecordInput(_controlDevices);
		}
	}
	_pollCounter++;
}
void BaseControlManager::ProcessEndOfFrame()
{
	if(!_wasInputRead) {
		_lagCounter++;
	}
	_wasInputRead = false;
}
void BaseControlManager::SetInputReadFlag()
{
	_wasInputRead = true;
}
uint32_t BaseControlManager::GetLagCounter()
{
	return _lagCounter;
}
void BaseControlManager::ResetLagCounter()
{
	_lagCounter = 0;
}
bool BaseControlManager::HasControlDevice(ControllerType type)
{
	auto lock = _deviceLock.AcquireSafe();
	for(shared_ptr<BaseControlDevice>& device : _controlDevices) {
		if(device->HasControllerType(type)) {
			return true;
		}
	}
	return false;
}
uint32_t BaseControlManager::GetPollCounter()
{
	return _pollCounter;
}
void BaseControlManager::SetPollCounter(uint32_t value)
{
	_pollCounter = value;
}
```

## File: Core/Shared/BaseControlManager.h
```
#pragma once
#include "pch.h"
#include "Utilities/SimpleLock.h"
#include "Utilities/ISerializable.h"
class BaseControlDevice;
class IInputRecorder;
class IInputProvider;
class Emulator;
enum class CpuType : uint8_t;
struct ControllerData;
enum class ControllerType;
class BaseControlManager : public ISerializable
{
private:
	vector<IInputRecorder*> _inputRecorders;
	vector<IInputProvider*> _inputProviders;
protected:
	Emulator* _emu = nullptr;
	CpuType _cpuType = {};
	SimpleLock _deviceLock;
	vector<shared_ptr<BaseControlDevice>> _systemDevices;
	vector<shared_ptr<BaseControlDevice>> _controlDevices;
	uint32_t _pollCounter = 0;
	uint32_t _lagCounter = 0;
	bool _wasInputRead = false;
	void RegisterControlDevice(shared_ptr<BaseControlDevice> controlDevice);
	void ClearDevices();
public:
	BaseControlManager(Emulator* emu, CpuType cpuType);
	virtual ~BaseControlManager();
	void Serialize(Serializer& s) override;
	void AddSystemControlDevice(shared_ptr<BaseControlDevice> device);
	virtual void UpdateControlDevices() {}
	virtual void UpdateInputState();
	void ProcessEndOfFrame();
	void SetInputReadFlag();
	uint32_t GetLagCounter();
	void ResetLagCounter();
	bool HasControlDevice(ControllerType type);
	virtual bool IsKeyboardConnected() { return false; }
	uint32_t GetPollCounter();
	void SetPollCounter(uint32_t value);
	virtual void Reset(bool softReset) {}
	void RegisterInputProvider(IInputProvider* provider);
	void UnregisterInputProvider(IInputProvider* provider);
	void RegisterInputRecorder(IInputRecorder* recorder);
	void UnregisterInputRecorder(IInputRecorder* recorder);
	virtual shared_ptr<BaseControlDevice> CreateControllerDevice(ControllerType type, uint8_t port) = 0;
	vector<ControllerData> GetPortStates();
	shared_ptr<BaseControlDevice> GetControlDevice(uint8_t port, uint8_t subPort = 0);
	shared_ptr<BaseControlDevice> GetControlDeviceByIndex(uint8_t index);
	void RefreshHubState();
	vector<shared_ptr<BaseControlDevice>> GetControlDevices();
	template<typename T>
	shared_ptr<T> GetControlDevice()
	{
		auto lock = _deviceLock.AcquireSafe();
		for (shared_ptr<BaseControlDevice>& device : _controlDevices) {
			shared_ptr<T> typedDevice = std::dynamic_pointer_cast<T>(device);
			if (typedDevice) {
				return typedDevice;
			}
		}
		return nullptr;
	}
};
```

## File: Core/Shared/BaseState.h
```
#pragma once
struct BaseState
{
};
```

## File: Core/Shared/BatteryManager.cpp
```cpp
#include "pch.h"
#include "Shared/BatteryManager.h"
#include "Utilities/VirtualFile.h"
#include "Utilities/FolderUtilities.h"
#include "Utilities/StringUtilities.h"
void BatteryManager::Initialize(string romName, bool setBatteryFlag)
{
	_romName = romName;
	_hasBattery = setBatteryFlag;
}
string BatteryManager::GetBasePath(string& extension)
{
	if(StringUtilities::StartsWith(extension, ".")) {
		return FolderUtilities::CombinePath(FolderUtilities::GetSaveFolder(), _romName + extension);
	} else {
		return FolderUtilities::CombinePath(FolderUtilities::GetSaveFolder(), extension);
	}
}
void BatteryManager::SetBatteryProvider(shared_ptr<IBatteryProvider> provider)
{
	_provider = provider;
}
void BatteryManager::SetBatteryRecorder(shared_ptr<IBatteryRecorder> recorder)
{
	_recorder = recorder;
}
void BatteryManager::SaveBattery(string extension, uint8_t* data, uint32_t length)
{
	if(_romName.empty()) {
		return;
	}
	_hasBattery = true;
	ofstream out(GetBasePath(extension), ios::binary);
	if(out) {
		out.write((char*)data, length);
	}
}
vector<uint8_t> BatteryManager::LoadBattery(string extension)
{
	if(_romName.empty()) {
		return {};
	}
	shared_ptr<IBatteryProvider> provider = _provider.lock();
	vector<uint8_t> batteryData;
	if(provider) {
		batteryData = provider->LoadBattery(extension);
	} else {
		VirtualFile file = GetBasePath(extension);
		if(file.IsValid()) {
			file.ReadFile(batteryData);
		}
	}
	if(!batteryData.empty()) {
		shared_ptr<IBatteryRecorder> recorder = _recorder.lock();
		if(recorder) {
			recorder->OnLoadBattery(extension, batteryData);
		}
	}
	_hasBattery = true;
	return batteryData;
}
void BatteryManager::LoadBattery(string extension, uint8_t* data, uint32_t length)
{
	vector<uint8_t> batteryData = LoadBattery(extension);
	memcpy(data, batteryData.data(), std::min((uint32_t)batteryData.size(), length));
}
uint32_t BatteryManager::GetBatteryFileSize(string extension)
{
	return (uint32_t)LoadBattery(extension).size();
}
```

## File: Core/Shared/BatteryManager.h
```
#pragma once
#include "pch.h"
class IBatteryProvider
{
public:
	virtual vector<uint8_t> LoadBattery(string extension) = 0;
};
class IBatteryRecorder
{
public:
	virtual void OnLoadBattery(string extension, vector<uint8_t> batteryData) = 0;
};
class BatteryManager
{
private:
	string _romName;
	bool _hasBattery = false;
	std::weak_ptr<IBatteryProvider> _provider;
	std::weak_ptr<IBatteryRecorder> _recorder;
	string GetBasePath(string& extension);
public:
	void Initialize(string romName, bool setBatteryFlag = false);
	bool HasBattery() { return _hasBattery; }
	void SetBatteryProvider(shared_ptr<IBatteryProvider> provider);
	void SetBatteryRecorder(shared_ptr<IBatteryRecorder> recorder);
	void SaveBattery(string extension, uint8_t* data, uint32_t length);
	vector<uint8_t> LoadBattery(string extension);
	void LoadBattery(string extension, uint8_t* data, uint32_t length);
	uint32_t GetBatteryFileSize(string extension);
};
```

## File: Core/Shared/CheatManager.cpp
```cpp
#include "pch.h"
#include <regex>
#include "Shared/CheatManager.h"
#include "Shared/MessageManager.h"
#include "Shared/Emulator.h"
#include "Shared/NotificationManager.h"
#include "Utilities/HexUtilities.h"
#include "Utilities/StringUtilities.h"
using std::regex;
CheatManager::CheatManager(Emulator* emu)
{
	_emu = emu;
}
optional<InternalCheatCode> CheatManager::TryConvertCode(CheatCode code)
{
	switch(code.Type) {
		case CheatType::NesGameGenie: return ConvertFromNesGameGenie(code.Code);
		case CheatType::NesProActionRocky: return ConvertFromNesProActionRocky(code.Code);
		case CheatType::NesCustom: return ConvertFromNesCustomCode(code.Code);
		case CheatType::SnesProActionReplay: return ConvertFromSnesProActionReplay(code.Code);
		case CheatType::SnesGameGenie: return ConvertFromSnesGameGenie(code.Code);
		case CheatType::GbGameGenie: return ConvertFromGbGameGenie(code.Code);
		case CheatType::GbGameShark: return ConvertFromGbGameShark(code.Code);
		case CheatType::PceRaw: return ConvertFromPceRaw(code.Code);
		case CheatType::PceAddress: return ConvertFromPceAddress(code.Code);
		case CheatType::SmsGameGenie: return ConvertFromSmsGameGenie(code.Code);
		case CheatType::SmsProActionReplay: return ConvertFromSmsProActionReplay(code.Code);
		default: throw std::runtime_error("unsupported cheat type");
	}
}
bool CheatManager::AddCheat(CheatCode code)
{
	optional<InternalCheatCode> convertedCode = TryConvertCode(code);
	if(!convertedCode.has_value()) {
		return false;
	}
	_cheats.push_back(code);
	int cpuIndex = (int)convertedCode->Cpu;
	if(convertedCode->IsRamCode) {
		_ramRefreshCheats[cpuIndex].push_back(convertedCode.value());
	} else {
		_cheatsByAddress[cpuIndex].emplace(convertedCode->Address, convertedCode.value());
		_hasCheats[cpuIndex] = true;
		_bankHasCheats[cpuIndex][convertedCode->Address >> GetBankShift(convertedCode->Cpu)] = true;
	}
	return true;
}
void CheatManager::SetCheats(vector<CheatCode>& codes)
{
	auto lock = _emu->AcquireLock();
	bool hasCheats = !_cheats.empty();
	ClearCheats(false);
	for(CheatCode &code : codes) {
		if(!AddCheat(code)) {
			MessageManager::DisplayMessage("Cheats", "Invalid cheat: " + string(code.Code));
		}
	}
	if(codes.size() > 1) {
		MessageManager::DisplayMessage("Cheats", "CheatsApplied", std::to_string(codes.size()));
	} else if(codes.size() == 1) {
		MessageManager::DisplayMessage("Cheats", "CheatApplied");
	} else if(hasCheats) {
		MessageManager::DisplayMessage("Cheats", "CheatsDisabled");
	}
	_emu->GetNotificationManager()->SendNotification(ConsoleNotificationType::CheatsChanged);
}
void CheatManager::SetCheats(CheatCode codes[], uint32_t length)
{
	vector<CheatCode> cheats(codes, codes+length);
	SetCheats(cheats);
}
void CheatManager::InternalClearCheats()
{
	_cheats.clear();
	for(int i = 0; i < CpuTypeUtilities::GetCpuTypeCount(); i++) {
		_cheatsByAddress[i].clear();
		_ramRefreshCheats[i].clear();
	}
	memset(_hasCheats, 0, sizeof(_hasCheats));
	memset(_bankHasCheats, 0, sizeof(_bankHasCheats));
}
void CheatManager::ClearCheats(bool showMessage)
{
	auto lock = _emu->AcquireLock();
	bool hadCheats = !_cheats.empty();
	InternalClearCheats();
	if(showMessage && hadCheats) {
		MessageManager::DisplayMessage("Cheats", "CheatsDisabled");
		_emu->GetNotificationManager()->SendNotification(ConsoleNotificationType::CheatsChanged);
	}
}
optional<InternalCheatCode> CheatManager::ConvertFromNesGameGenie(string code)
{
	static regex _validator = regex("^([APZLGITYEOXUKSVN]{6})|([APZLGITYEOXUKSVN]{8})$", std::regex_constants::icase);
	if(!std::regex_match(code, _validator)) {
		return std::nullopt;
	}
	static string ggLetters = "APZLGITYEOXUKSVN";
	auto decodeValue = [](int code, int bitIndexes[], int count) -> int {
		int result = 0;
		for(int i = 0; i < count; i++) {
			result <<= 1;
			result |= (code >> bitIndexes[i]) & 0x01;
		}
		return result;
	};
	int addressBits[15] = { 14, 13, 12, 19, 22, 21, 20, 7, 10, 9, 8, 15, 18, 17, 16 };
	int valueBits[8] = { 3, 6, 5, 4, 23, 2, 1, 0 };
	int rawCode = 0;
	for(int i = 0, len = (int)code.size(); i < len; i++) {
		rawCode |= ggLetters.find(std::toupper(code[i])) << (i * 4);
	}
	int compareValue = -1;
	if(code.size() == 8) {
		valueBits[4] = 31;
		int compareValueBits[8] = { 27, 30, 29, 28, 23, 26, 25, 24 };
		compareValue = decodeValue(rawCode, compareValueBits, 8);
	}
	int address = decodeValue(rawCode, addressBits, 15) + 0x8000;
	int value = decodeValue(rawCode, valueBits, 8);
	InternalCheatCode cheat = {};
	cheat.Type = CheatType::NesGameGenie;
	cheat.Cpu = CpuType::Nes;
	cheat.Address = address;
	cheat.Value = value;
	cheat.Compare = compareValue;
	return cheat;
}
optional<InternalCheatCode> CheatManager::ConvertFromNesProActionRocky(string code)
{
	static regex _validator = regex("^[a-f0-9]{8}$", std::regex_constants::icase);
	if(!std::regex_match(code, _validator)) {
		return std::nullopt;
	}
	int shiftValues[31] = {
		3, 13, 14, 1, 6, 9, 5, 0, 12, 7, 2, 8, 10, 11, 4,
		19, 21, 23, 22, 20, 17, 16, 18,
		29, 31, 24, 26, 25, 30, 27, 28
	};
	uint32_t key = 0x7E5EE93A;
	uint32_t xorValue = 0x5C184B91;
	uint32_t parCode = HexUtilities::FromHex(code);
	parCode >>= 1;
	uint32_t result = 0;
	for(int i = 30; i >= 0; i--) {
		if((((key ^ parCode) >> 30) & 0x01) != 0) {
			result |= (uint32_t)(0x01 << shiftValues[i]);
			key ^= xorValue;
		}
		parCode <<= 1;
		key <<= 1;
	}
	InternalCheatCode cheat = {};
	cheat.Type = CheatType::NesCustom;
	cheat.Cpu = CpuType::Nes;
	cheat.Address = (result & 0x7FFF) + 0x8000;
	cheat.Value = (result >> 24) & 0xFF;
	cheat.Compare = (result >> 16) & 0xFF;
	return cheat;
}
optional<InternalCheatCode> CheatManager::ConvertFromNesCustomCode(string code)
{
	static regex _validator = regex("^[a-f0-9]{4}:[a-f0-9]{2}(:[a-f0-9]{2}){0,1}$", std::regex_constants::icase);
	if(!std::regex_match(code, _validator)) {
		return std::nullopt;
	}
	vector<string> parts = StringUtilities::Split(code, ':');
	uint32_t address = HexUtilities::FromHex(parts[0]);
	uint32_t value = HexUtilities::FromHex(parts[1]);
	int32_t compare = parts.size() == 3 ? HexUtilities::FromHex(parts[2]) : -1;
	InternalCheatCode cheat = {};
	cheat.Type = CheatType::NesCustom;
	cheat.Cpu = CpuType::Nes;
	cheat.Address = address;
	cheat.Value = value;
	cheat.Compare = compare;
	return cheat;
}
optional<InternalCheatCode> CheatManager::ConvertFromGbGameGenie(string code)
{
	static regex _validator = regex("^[a-f0-9]{3}-[a-f0-9]{3}(-[a-f0-9]{3}){0,1}$", std::regex_constants::icase);
	if(!std::regex_match(code, _validator)) {
		return std::nullopt;
	}
	uint8_t value = (uint8_t)HexUtilities::FromHex(code.substr(0, 2));
	int16_t compare = -1;
	if(code.length() > 7) {
		compare = (uint8_t)HexUtilities::FromHex(code.substr(8, 1) + code[10]);
		compare = (uint8_t)(((compare >> 2) | ((compare & 0x03) << 6)) ^ 0xBA);
	}
	uint16_t address = (uint16_t)(HexUtilities::FromHex(code.substr(6, 1) + code[2] + code[4] + code[5]) ^ 0xF000);
	InternalCheatCode cheat = {};
	cheat.Type = CheatType::GbGameGenie;
	cheat.Cpu = CpuType::Gameboy;
	cheat.Address = address;
	cheat.Value = value;
	cheat.Compare = compare;
	return cheat;
}
optional<InternalCheatCode> CheatManager::ConvertFromGbGameShark(string code)
{
	static regex _validator = regex("^[a-f0-9]{8}$", std::regex_constants::icase);
	if(!std::regex_match(code, _validator)) {
		return std::nullopt;
	}
	uint32_t codeValue = HexUtilities::FromHex(code);
	uint8_t codeType = codeValue >> 24;
	uint8_t value = (uint8_t)HexUtilities::FromHex(code.substr(2, 2));
	uint16_t address = (uint16_t)HexUtilities::FromHex(code.substr(6, 2) + code.substr(4, 2));
	InternalCheatCode cheat = {};
	cheat.Type = CheatType::GbGameShark;
	cheat.Cpu = CpuType::Gameboy;
	cheat.Value = value;
	cheat.IsRamCode = true;
	if(codeType >= 0x80) {
		uint32_t bank = (codeType & 0x0F);
		uint32_t absAddress;
		if(address >= 0xA000 && address < 0xC000) {
			cheat.MemType = MemoryType::GbCartRam;
			absAddress = (bank * 0x2000) + address - 0xA000;
		} else if(address >= 0xD000 && address < 0xE000) {
			cheat.MemType = MemoryType::GbWorkRam;
			absAddress = (bank * 0x1000) + address - 0xD000;
		} else if(address >= 0xC000 && address < 0xD000) {
			cheat.MemType = MemoryType::GbWorkRam;
			bank = 0;
			absAddress = address - 0xC000;
		} else {
			return std::nullopt;
		}
		cheat.IsAbsoluteAddress = true;
		cheat.Address = absAddress;
	} else if(codeType == 0x01) {
		cheat.Address = address;
	} else {
		return std::nullopt;
	}
	return cheat;
}
optional<InternalCheatCode> CheatManager::ConvertFromSnesProActionReplay(string code)
{
	static regex _validator = regex("^[a-f0-9]{8}$", std::regex_constants::icase);
	if(!std::regex_match(code, _validator)) {
		return std::nullopt;
	}
	uint32_t codeValue = HexUtilities::FromHex(code);
	InternalCheatCode cheat = {};
	cheat.Type = CheatType::SnesProActionReplay;
	cheat.Cpu = CpuType::Snes;
	cheat.Address = (codeValue >> 8) & 0xFFFFFF;
	cheat.Value = (uint8_t)(codeValue & 0xFF);
	if(cheat.Address >= 0x7E0000 && cheat.Address <= 0x7FFFFF) {
		cheat.IsRamCode = true;
		cheat.IsAbsoluteAddress = true;
		cheat.MemType = MemoryType::SnesWorkRam;
		cheat.Address -= 0x7E0000;
	}
	return cheat;
}
optional<InternalCheatCode> CheatManager::ConvertFromSnesGameGenie(string code)
{
	static regex _validator = regex("^[a-f0-9]{4}-[a-f0-9]{4}$", std::regex_constants::icase);
	static string _convertTable = "DF4709156BC8A23E";
	if(!std::regex_match(code, _validator)) {
		return std::nullopt;
	}
	uint32_t rawValue = 0;
	for(int i = 0; i < (int)code.size(); i++) {
		if(code[i] != '-') {
			rawValue <<= 4;
			rawValue |= (uint32_t)_convertTable.find_first_of(std::toupper(code[i]));
		}
	}
	InternalCheatCode cheat = {};
	cheat.Type = CheatType::SnesGameGenie;
	cheat.Cpu = CpuType::Snes;
	cheat.Address = (
		((rawValue & 0x3C00) << 10) |
		((rawValue & 0x3C) << 14) |
		((rawValue & 0xF00000) >> 8) |
		((rawValue & 0x03) << 10) |
		((rawValue & 0xC000) >> 6) |
		((rawValue & 0xF0000) >> 12) |
		((rawValue & 0x3C0) >> 6)
	);
	cheat.Value = rawValue >> 24;
	return cheat;
}
optional<InternalCheatCode> CheatManager::ConvertFromPceRaw(string code)
{
	static regex _validator = regex("^[a-f0-9]{6}:[a-f0-9]{2}$", std::regex_constants::icase);
	if(!std::regex_match(code, _validator)) {
		return std::nullopt;
	}
	InternalCheatCode cheat = {};
	cheat.Type = CheatType::PceRaw;
	cheat.Cpu = CpuType::Pce;
	cheat.Value = (uint8_t)HexUtilities::FromHex(code.substr(7, 2));
	cheat.Address = HexUtilities::FromHex(code.substr(0, 6));
	return cheat;
}
optional<InternalCheatCode> CheatManager::ConvertFromPceAddress(string code)
{
	static regex _validator = regex("^[a-f0-9]{6}:[a-f0-9]{2}$", std::regex_constants::icase);
	if(!std::regex_match(code, _validator)) {
		return std::nullopt;
	}
	InternalCheatCode cheat = {};
	cheat.Type = CheatType::PceAddress;
	cheat.Cpu = CpuType::Pce;
	cheat.Value = (uint8_t)HexUtilities::FromHex(code.substr(7, 2));
	uint32_t address = HexUtilities::FromHex(code.substr(0, 6));
	cheat.Address = ((address & 0xFF0000) >> 3) | (address & 0x1FFF);
	return cheat;
}
optional<InternalCheatCode> CheatManager::ConvertFromSmsGameGenie(string code)
{
	static regex _validator = regex("^[a-f0-9]{3}-[a-f0-9]{3}(-[a-f0-9]{3}){0,1}$", std::regex_constants::icase);
	if(!std::regex_match(code, _validator)) {
		return std::nullopt;
	}
	uint8_t value = (uint8_t)HexUtilities::FromHex(code.substr(0, 2));
	int16_t compare = -1;
	if(code.length() > 7) {
		compare = (uint8_t)HexUtilities::FromHex(code.substr(8, 1) + code[10]);
		compare = (uint8_t)(((compare >> 2) | ((compare & 0x03) << 6)) ^ 0xBA);
	}
	uint16_t address = (uint16_t)(HexUtilities::FromHex(code.substr(6, 1) + code[2] + code[4] + code[5]) ^ 0xF000);
	InternalCheatCode cheat = {};
	cheat.Type = CheatType::SmsGameGenie;
	cheat.Cpu = CpuType::Sms;
	cheat.Address = address;
	cheat.Value = value;
	cheat.Compare = compare;
	return cheat;
}
optional<InternalCheatCode> CheatManager::ConvertFromSmsProActionReplay(string code)
{
	static regex _validator = regex("^[a-f0-9]{8}$", std::regex_constants::icase);
	if(!std::regex_match(code, _validator)) {
		return std::nullopt;
	}
	uint32_t codeValue = HexUtilities::FromHex(code);
	InternalCheatCode cheat = {};
	cheat.Type = CheatType::SmsProActionReplay;
	cheat.Cpu = CpuType::Sms;
	cheat.Address = (codeValue >> 8) & 0xFFFF;
	cheat.Value = (uint8_t)(codeValue & 0xFF);
	cheat.IsRamCode = true;
	cheat.IsAbsoluteAddress = false;
	return cheat;
}
vector<CheatCode> CheatManager::GetCheats()
{
	return _cheats;
}
vector<InternalCheatCode>& CheatManager::GetRamRefreshCheats(CpuType cpuType)
{
	return _ramRefreshCheats[(int)cpuType];
}
bool CheatManager::GetConvertedCheat(CheatCode input, InternalCheatCode& output)
{
	optional<InternalCheatCode> convertedCode = TryConvertCode(input);
	if(convertedCode.has_value()) {
		output = convertedCode.value();
		return true;
	}
	return false;
}
void CheatManager::RefreshRamCheats(CpuType cpuType)
{
	for(InternalCheatCode& code : _ramRefreshCheats[(int)cpuType]) {
		if(code.IsAbsoluteAddress) {
			ConsoleMemoryInfo mem = _emu->GetMemory(code.MemType);
			if(code.Address < mem.Size) {
				((uint8_t*)mem.Memory)[code.Address] = code.Value;
			}
		}
	}
}
template<CpuType cpuType>
void CheatManager::ApplyCheat(uint32_t addr, uint8_t& value)
{
	if(_bankHasCheats[(int)cpuType][addr >> GetBankShift(cpuType)]) {
		auto result = _cheatsByAddress[(int)cpuType].find(addr);
		if(result != _cheatsByAddress[(int)cpuType].end()) {
			if(result->second.Compare == -1 || result->second.Compare == value) {
				value = result->second.Value;
				_emu->GetConsoleUnsafe()->ProcessCheatCode(result->second, addr, value);
			}
		}
	}
}
template void CheatManager::ApplyCheat<CpuType::Nes>(uint32_t addr, uint8_t& value);
template void CheatManager::ApplyCheat<CpuType::Snes>(uint32_t addr, uint8_t& value);
template void CheatManager::ApplyCheat<CpuType::Pce>(uint32_t addr, uint8_t& value);
template void CheatManager::ApplyCheat<CpuType::Gameboy>(uint32_t addr, uint8_t& value);
template void CheatManager::ApplyCheat<CpuType::Sms>(uint32_t addr, uint8_t& value);
```

## File: Core/Shared/CheatManager.h
```
#pragma once
#include "pch.h"
#include <optional>
#include "Shared/CpuType.h"
using std::optional;
class Emulator;
enum class MemoryType;
enum class CheatType : uint8_t
{
	NesGameGenie = 0,
	NesProActionRocky,
	NesCustom,
	GbGameGenie,
	GbGameShark,
	SnesGameGenie,
	SnesProActionReplay,
	PceRaw,
	PceAddress,
	SmsProActionReplay,
	SmsGameGenie
};
struct InternalCheatCode
{
	MemoryType MemType = {};
	uint32_t Address = 0;
	int16_t Compare = -1;
	uint8_t Value = 0;
	CheatType Type = {};
	CpuType Cpu = {};
	bool IsRamCode = false;
	bool IsAbsoluteAddress = false;
};
struct CheatCode
{
	CheatType Type;
	char Code[16];
};
class CheatManager
{
private:
	Emulator* _emu;
	bool _hasCheats[CpuTypeUtilities::GetCpuTypeCount()] = {};
	bool _bankHasCheats[CpuTypeUtilities::GetCpuTypeCount()][0x100] = {};
	vector<CheatCode> _cheats;
	vector<InternalCheatCode> _ramRefreshCheats[CpuTypeUtilities::GetCpuTypeCount()];
	unordered_map<uint32_t, InternalCheatCode> _cheatsByAddress[CpuTypeUtilities::GetCpuTypeCount()];
	optional<InternalCheatCode> TryConvertCode(CheatCode code);
	optional<InternalCheatCode> ConvertFromSnesGameGenie(string code);
	optional<InternalCheatCode> ConvertFromSnesProActionReplay(string code);
	optional<InternalCheatCode> ConvertFromGbGameGenie(string code);
	optional<InternalCheatCode> ConvertFromGbGameShark(string code);
	optional<InternalCheatCode> ConvertFromPceRaw(string code);
	optional<InternalCheatCode> ConvertFromPceAddress(string code);
	optional<InternalCheatCode> ConvertFromNesGameGenie(string code);
	optional<InternalCheatCode> ConvertFromNesProActionRocky(string code);
	optional<InternalCheatCode> ConvertFromNesCustomCode(string code);
	optional<InternalCheatCode> ConvertFromSmsGameGenie(string code);
	optional<InternalCheatCode> ConvertFromSmsProActionReplay(string code);
	__forceinline constexpr int GetBankShift(CpuType cpuType)
	{
		switch(cpuType) {
			case CpuType::Snes: return 16;
			case CpuType::Gameboy: return 8;
			case CpuType::Nes: return 8;
			case CpuType::Pce: return 13;
			case CpuType::Sms: return 8;
			default: throw std::runtime_error("unsupported cpu type");
		}
	}
public:
	CheatManager(Emulator* emu);
	bool AddCheat(CheatCode code);
	void InternalClearCheats();
	void SetCheats(vector<CheatCode>& codes);
	void SetCheats(CheatCode codes[], uint32_t length);
	void ClearCheats(bool showMessage = true);
	vector<CheatCode> GetCheats();
	bool GetConvertedCheat(CheatCode input, InternalCheatCode& output);
	vector<InternalCheatCode>& GetRamRefreshCheats(CpuType cpuType);
	void RefreshRamCheats(CpuType cpuType);
	template<CpuType cpuType>
	__forceinline bool HasCheats()
	{
		return _hasCheats[(int)cpuType];
	}
	template<CpuType cpuType>
	__noinline void ApplyCheat(uint32_t addr, uint8_t& value);
};
```

## File: Core/Shared/ColorUtilities.h
```
#pragma once
#include "pch.h"
class ColorUtilities
{
public:
	static uint8_t Convert5BitTo8Bit(uint8_t color)
	{
		return (color << 3) + (color >> 2);
	}
	static uint8_t Convert4BitTo8Bit(uint8_t color)
	{
		return (color << 4) | color;
	}
	static uint32_t Rgb555ToArgb(uint16_t rgb555)
	{
		uint8_t b = Convert5BitTo8Bit((rgb555 >> 10) & 0x1F);
		uint8_t g = Convert5BitTo8Bit((rgb555 >> 5) & 0x1F);
		uint8_t r = Convert5BitTo8Bit(rgb555 & 0x1F);
		return 0xFF000000 | (r << 16) | (g << 8) | b;
	}
	static uint16_t Rgb222To555(uint8_t value)
	{
		return (
			((value & 0x30) << 9) | ((value & 0x30) << 7) | ((value & 0x20) << 5) |
			((value & 0x0C) << 6) | ((value & 0x0C) << 4) | ((value & 0x08) << 2) |
			((value & 0x03) << 3) | ((value & 0x03) << 1) | ((value & 0x02) >> 1)
		);
	}
	static uint16_t Rgb444To555(uint16_t value)
	{
		return (
			((value & 0xF00) << 3) | ((value & 0x800) >> 1) |
			((value & 0x0F0) << 2) | ((value & 0x080) >> 2) |
			((value & 0x00F) << 1) | ((value & 0x008) >> 3)
		);
	}
	static uint32_t Rgb222ToArgb(uint8_t rgb222)
	{
		return Rgb555ToArgb(Rgb222To555(rgb222));
	}
	static uint32_t Rgb444ToArgb(uint16_t rgb444)
	{
		return Rgb555ToArgb(Rgb444To555(rgb444));
	}
	static uint32_t Bgr444ToArgb(uint16_t bgr444)
	{
		uint8_t b = (bgr444 & 0x00F);
		uint8_t g = (bgr444 & 0x0F0) >> 4;
		uint8_t r = (bgr444 & 0xF00) >> 8;
		return 0xFF000000 | (r << 20) | (r << 16) | (g << 12) | (g << 8) | (b << 4) | (b << 0);
	}
	static uint16_t Rgb888To555(uint32_t rgb888)
	{
		uint8_t r = (rgb888 >> 19) & 0x1F;
		uint8_t g = (rgb888 >> 11) & 0x1F;
		uint8_t b = (rgb888 >> 3) & 0x1F;
		return (b << 10) | (g << 5) | r;
	}
};
```

## File: Core/Shared/ControlDeviceState.h
```
#pragma once
#include "pch.h"
#include <cstring>
#include "Shared/SettingTypes.h"
struct ControlDeviceState
{
	vector<uint8_t> State;
	bool operator!=(ControlDeviceState &other)
	{
		return State.size() != other.State.size() || memcmp(State.data(), other.State.data(), State.size()) != 0;
	}
};
struct ControllerData
{
	ControllerType Type;
	ControlDeviceState State;
	uint8_t Port;
};
```

## File: Core/Shared/ControllerHub.h
```
#pragma once
#include "pch.h"
#include "Shared/BaseControlDevice.h"
#include "Shared/InputHud.h"
#include "Shared/IControllerHub.h"
#include "SNES/Input/SnesController.h"
#include "SNES/Input/SnesMouse.h"
#include "NES/Input/NesController.h"
#include "PCE/Input/PceController.h"
#include "PCE/Input/PceAvenuePad6.h"
#include "Utilities/Serializer.h"
#include "Utilities/StringUtilities.h"
template<int HubPortCount>
class ControllerHub : public BaseControlDevice, public IControllerHub
{
protected:
	shared_ptr<BaseControlDevice> _ports[HubPortCount];
	void InternalSetStateFromInput() override
	{
		for(int i = 0; i < HubPortCount; i++) {
			if(_ports[i]) {
				_ports[i]->SetStateFromInput();
			}
		}
		UpdateStateFromPorts();
	}
	void UpdateStateFromPorts()
	{
		for(int i = 0; i < HubPortCount; i++) {
			if(_ports[i]) {
				ControlDeviceState portState = _ports[i]->GetRawState();
				_state.State.push_back((uint8_t)portState.State.size());
				_state.State.insert(_state.State.end(), portState.State.begin(), portState.State.end());
			}
		}
	}
	uint8_t ReadPort(int i)
	{
		if(_ports[i]) {
			return _ports[i]->ReadRam(0x4016);
		} else {
			return 0;
		}
	}
	void WritePort(int i, uint8_t value)
	{
		if(_ports[i]) {
			_ports[i]->WriteRam(0x4016, value);
		}
	}
public:
	ControllerHub(Emulator* emu, ControllerType type, int port, ControllerConfig controllers[]) : BaseControlDevice(emu, type, port)
	{
		static_assert(HubPortCount <= MaxSubPorts, "Port count too large");
		for(int i = 0; i < HubPortCount; i++) {
			switch(controllers[i].Type) {
				case ControllerType::FamicomController:
				case ControllerType::FamicomControllerP2:
				case ControllerType::NesController:
					_ports[i].reset(new NesController(emu, controllers[i].Type, 0, controllers[i].Keys));
					break;
				case ControllerType::SnesController:
					_ports[i].reset(new SnesController(emu, 0, controllers[i].Keys));
					break;
				case ControllerType::SnesMouse:
					_ports[i].reset(new SnesMouse(emu, 0, controllers[i].Keys));
					break;
				case ControllerType::PceController:
					_ports[i].reset(new PceController(emu, 0, controllers[i].Keys));
					break;
				case ControllerType::PceAvenuePad6:
					_ports[i].reset(new PceAvenuePad6(emu, 0, controllers[i].Keys));
					break;
			}
		}
	}
	void WriteRam(uint16_t addr, uint8_t value) override
	{
		StrobeProcessWrite(value);
		for(int i = 0; i < HubPortCount; i++) {
			if(_ports[i]) {
				_ports[i]->WriteRam(addr, value);
			}
		}
	}
	void DrawController(InputHud& hud) override
	{
		for(int i = 0; i < HubPortCount; i++) {
			if(_ports[i]) {
				_ports[i]->DrawController(hud);
			} else {
				hud.EndDrawController();
			}
		}
	}
	void SetTextState(string state) override
	{
		vector<string> portStates = StringUtilities::Split(state, ':');
		int i = 0;
		for(string& portState : portStates) {
			if(_ports[i]) {
				_ports[i]->SetTextState(portState);
			}
			i++;
		}
		UpdateStateFromPorts();
	}
	string GetTextState() override
	{
		auto lock = _stateLock.AcquireSafe();
		string state;
		for(int i = 0; i < HubPortCount; i++) {
			if(i != 0) {
				state += ":";
			}
			if(_ports[i]) {
				state += _ports[i]->GetTextState();
			}
		}
		return state;
	}
	void SetRawState(ControlDeviceState state) override
	{
		auto lock = _stateLock.AcquireSafe();
		_state = state;
		vector<uint8_t> data = state.State;
		int pos = 0;
		for(int i = 0; i < HubPortCount; i++) {
			if(_ports[i] && pos < data.size()) {
				int length = data[pos++];
				if(pos + length > data.size()) {
					break;
				}
				ControlDeviceState portState;
				portState.State.insert(portState.State.begin(), data.begin() + pos, data.begin() + pos + length);
				_ports[i]->SetRawState(portState);
				pos += length;
			}
		}
	}
	bool HasControllerType(ControllerType type) override
	{
		if(_type == type) {
			return true;
		}
		for(int i = 0; i < HubPortCount; i++) {
			if(_ports[i] && _ports[i]->HasControllerType(type)) {
				return true;
			}
		}
		return false;
	}
	void RefreshHubState() override
	{
		_state.State.clear();
		UpdateStateFromPorts();
	}
	int GetHubPortCount() override
	{
		return HubPortCount;
	}
	shared_ptr<BaseControlDevice> GetController(int index) override
	{
		if(index >= HubPortCount) {
			return nullptr;
		}
		return _ports[index];
	}
};
```

## File: Core/Shared/CpuType.h
```
#pragma once
#include "pch.h"
enum class CpuType : uint8_t
{
	Snes,
	Spc,
	NecDsp,
	Sa1,
	Gsu,
	Cx4,
	St018,
	Gameboy,
	Nes,
	Pce,
	Sms,
	Gba,
	Ws
};
class CpuTypeUtilities
{
public:
	static constexpr int GetCpuTypeCount()
	{
		return (int)CpuType::Ws + 1;
	}
};
```

## File: Core/Shared/DebuggerRequest.cpp
```cpp
#include "pch.h"
#include "Shared/Emulator.h"
#include "Shared/DebuggerRequest.h"
DebuggerRequest::DebuggerRequest(Emulator* emu)
{
	if(emu) {
		_emu = emu;
		_debugger = _emu->_debugger.lock();
		_emu->_debugRequestCount++;
	}
}
DebuggerRequest::DebuggerRequest(const DebuggerRequest& copy)
{
	_emu = copy._emu;
	_debugger = copy._emu->_debugger.lock();
	_emu->_debugRequestCount++;
}
DebuggerRequest::~DebuggerRequest()
{
	if(_emu) {
		_emu->_debugRequestCount--;
	}
}
```

## File: Core/Shared/DebuggerRequest.h
```
#pragma once
#include "pch.h"
class Debugger;
class Emulator;
class DebuggerRequest
{
private:
	shared_ptr<Debugger> _debugger;
	Emulator* _emu = nullptr;
public:
	DebuggerRequest(Emulator* emu);
	DebuggerRequest(const DebuggerRequest& copy);
	~DebuggerRequest();
	Debugger* GetDebugger() { return _debugger.get(); }
};
```

## File: Core/Shared/EmulatorLock.cpp
```cpp
#include "pch.h"
#include "Shared/EmulatorLock.h"
#include "Shared/Emulator.h"
#include "Shared/DebuggerRequest.h"
#include "Debugger/DebugBreakHelper.h"
EmulatorLock::EmulatorLock(Emulator *emu, bool allowDebuggerLock)
{
	_emu = emu;
	if(_emu->_runLock.IsLockedByCurrentThread()) {
		_emu->Lock();
	} else {
		if(allowDebuggerLock) {
			_debugger.reset(new DebuggerRequest(emu->GetDebugger(false)));
			if(_debugger->GetDebugger()) {
				_breakHelper.reset(new DebugBreakHelper(_debugger->GetDebugger(), true));
			} else {
				_debugger.reset();
				_emu->Lock();
			}
		} else {
			_emu->Lock();
		}
	}
}
EmulatorLock::~EmulatorLock()
{
	if(_debugger) {
		_breakHelper.reset();
	} else {
		_emu->Unlock();
	}
}
```

## File: Core/Shared/EmulatorLock.h
```
#pragma once
#include "pch.h"
class Emulator;
class DebuggerRequest;
class DebugBreakHelper;
class EmulatorLock
{
private:
	Emulator* _emu = nullptr;
	unique_ptr<DebuggerRequest> _debugger;
	unique_ptr<DebugBreakHelper> _breakHelper;
public:
	EmulatorLock(Emulator* emulator, bool allowDebuggerLock);
	~EmulatorLock();
};
```

## File: Core/Shared/EmuSettings.h
```
#pragma once
#include "pch.h"
#include "Shared/SettingTypes.h"
#include "Utilities/SimpleLock.h"
#include "Utilities/ISerializable.h"
#include <random>
class Emulator;
class EmuSettings final : public ISerializable
{
private:
	Emulator* _emu;
	std::mt19937 _mt;
	VideoConfig _video;
	AudioConfig _audio;
	InputConfig _input;
	EmulationConfig _emulation;
	PreferencesConfig _preferences;
	AudioPlayerConfig _audioPlayer;
	DebugConfig _debug;
	GameConfig _game;
	SnesConfig _snes;
	GameboyConfig _gameboy;
	NesConfig _nes;
	PcEngineConfig _pce;
	SmsConfig _sms;
	CvConfig _cv;
	GbaConfig _gba;
	WsConfig _ws;
	atomic<uint32_t> _flags;
	atomic<uint64_t> _debuggerFlags;
	string _audioDevice;
	string _saveFolder;
	string _saveStateFolder;
	string _screenshotFolder;
	std::unordered_map<uint32_t, KeyCombination> _emulatorKeys[3];
	std::unordered_map<uint32_t, vector<KeyCombination>> _shortcutSupersets[3];
	SimpleLock _updateShortcutsLock;
	void ProcessString(string &str, const char** strPointer);
	void ClearShortcutKeys();
	void SetShortcutKey(EmulatorShortcut shortcut, KeyCombination keyCombination, int keySetIndex);
public:
	EmuSettings(Emulator* emu);
	void CopySettings(EmuSettings& src);
	void Serialize(Serializer& s) override;
	uint32_t GetVersion();
	string GetVersionString();
	void SetVideoConfig(VideoConfig& config);
	VideoConfig& GetVideoConfig();
	void SetAudioConfig(AudioConfig& config);
	AudioConfig& GetAudioConfig();
	void SetInputConfig(InputConfig& config);
	InputConfig& GetInputConfig();
	void SetEmulationConfig(EmulationConfig& config);
	EmulationConfig& GetEmulationConfig();
	void SetSnesConfig(SnesConfig& config);
	SnesConfig& GetSnesConfig();
	void SetNesConfig(NesConfig& config);
	NesConfig& GetNesConfig();
	void SetGameboyConfig(GameboyConfig& config);
	GameboyConfig& GetGameboyConfig();
	void SetGbaConfig(GbaConfig& config);
	GbaConfig& GetGbaConfig();
	void SetPcEngineConfig(PcEngineConfig& config);
	PcEngineConfig& GetPcEngineConfig();
	void SetSmsConfig(SmsConfig& config);
	SmsConfig& GetSmsConfig();
	void SetCvConfig(CvConfig& config);
	CvConfig& GetCvConfig();
	void SetWsConfig(WsConfig& config);
	WsConfig& GetWsConfig();
	void SetGameConfig(GameConfig& config);
	GameConfig& GetGameConfig();
	void SetPreferences(PreferencesConfig& config);
	PreferencesConfig& GetPreferences();
	void SetAudioPlayerConfig(AudioPlayerConfig& config);
	AudioPlayerConfig& GetAudioPlayerConfig();
	void SetDebugConfig(DebugConfig& config);
	DebugConfig& GetDebugConfig();
	void SetShortcutKeys(vector<ShortcutKeyInfo> shortcuts);
	KeyCombination GetShortcutKey(EmulatorShortcut shortcut, int keySetIndex);
	vector<KeyCombination> GetShortcutSupersets(EmulatorShortcut shortcut, int keySetIndex);
	OverscanDimensions GetOverscan();
	uint32_t GetEmulationSpeed();
	double GetAspectRatio(ConsoleRegion region, FrameInfo baseFrameSize);
	void SetFlag(EmulationFlags flag);
	void SetFlagState(EmulationFlags flag, bool enabled);
	void ClearFlag(EmulationFlags flag);
	bool CheckFlag(EmulationFlags flag);
	void SetDebuggerFlag(DebuggerFlags flag, bool enabled);
	bool CheckDebuggerFlag(DebuggerFlags flags);
	bool HasRandomPowerOnState(ConsoleType consoleType);
	int GetRandomValue(int maxValue);
	bool GetRandomBool();
	void InitializeRam(RamState state, void* data, uint32_t length);
	bool IsInputEnabled();
	double GetControllerDeadzoneRatio();
	template<typename T>
	bool IsEqual(T& prevCfg, T& newCfg)
	{
		if(memcmp(&prevCfg, &newCfg, sizeof(T)) == 0) {
			return true;
		}
		memcpy(&prevCfg, &newCfg, sizeof(T));
		return false;
	}
};
```

## File: Core/Shared/EventType.h
```
#pragma once
enum class EventType
{
	Nmi,
	Irq,
	StartFrame,
	EndFrame,
	Reset,
	ScriptEnded,
	InputPolled,
	StateLoaded,
	StateSaved,
	CodeBreak,
	LastValue
};
```

## File: Core/Shared/FirmwareHelper.h
```
#pragma once
#include "pch.h"
#include "Shared/Emulator.h"
#include "Shared/MessageManager.h"
#include "Shared/NotificationManager.h"
#include "Utilities/FolderUtilities.h"
enum class FirmwareType
{
	DSP1,
	DSP1B,
	DSP2,
	DSP3,
	DSP4,
	ST010,
	ST011,
	ST018,
	Satellaview,
	SufamiTurbo,
	Gameboy,
	GameboyColor,
	GameboyAdvance,
	Sgb1GameboyCpu,
	Sgb2GameboyCpu,
	SGB1,
	SGB2,
	FDS,
	StudyBox,
	PceSuperCd,
	PceGamesExpress,
	ColecoVision,
	WonderSwan,
	WonderSwanColor,
	SwanCrystal,
	Ymf288AdpcmRom,
	SmsBootRom,
	GgBootRom
};
struct MissingFirmwareMessage
{
	const char* Filename = {};
	FirmwareType Firmware;
	uint32_t Size = 0;
	uint32_t AltSize = 0;
	MissingFirmwareMessage(const char* filename, FirmwareType type, uint32_t size, uint32_t altSize = 0)
	{
		Filename = filename;
		Firmware = type;
		Size = size;
		AltSize = altSize;
	}
};
class FirmwareHelper
{
private:
	static bool AttemptLoadDspFirmware(string combinedFilename, string splitFilenameProgram, string splitFilenameData, vector<uint8_t> &programRom, vector<uint8_t> &dataRom, uint32_t programSize, uint32_t dataSize)
	{
		VirtualFile combinedFirmware(FolderUtilities::CombinePath(FolderUtilities::GetFirmwareFolder(), combinedFilename));
		if(combinedFirmware.GetSize() == programSize + dataSize) {
			vector<uint8_t> firmwareData;
			combinedFirmware.ReadFile(firmwareData);
			programRom.insert(programRom.end(), firmwareData.begin(), firmwareData.begin() + programSize);
			dataRom.insert(dataRom.end(), firmwareData.begin() + programSize, firmwareData.end());
			return true;
		} else {
			VirtualFile splitFirmwareProg(FolderUtilities::CombinePath(FolderUtilities::GetFirmwareFolder(), splitFilenameProgram));
			VirtualFile splitFirmwareData(FolderUtilities::CombinePath(FolderUtilities::GetFirmwareFolder(), splitFilenameData));
			if(splitFirmwareProg.GetSize() == programSize && splitFirmwareData.GetSize() == dataSize) {
				splitFirmwareProg.ReadFile(programRom);
				splitFirmwareData.ReadFile(dataRom);
				return true;
			}
		}
		return false;
	}
	static bool AttemptLoadBsxFirmware(uint8_t** prgRom, uint32_t& prgSize)
	{
		VirtualFile firmware(FolderUtilities::CombinePath(FolderUtilities::GetFirmwareFolder(), "BS-X.bin"));
		if(firmware.IsValid() && firmware.GetSize() >= 0x8000) {
			*prgRom = new uint8_t[firmware.GetSize()];
			prgSize = (uint32_t)firmware.GetSize();
			firmware.ReadFile(*prgRom, (uint32_t)firmware.GetSize());
			return true;
		}
		return false;
	}
	static bool AttemptLoadFirmware(uint8_t** out, string filename, uint32_t size, string altFilename = "")
	{
		string path = FolderUtilities::CombinePath(FolderUtilities::GetFirmwareFolder(), filename);
		VirtualFile firmware(path);
		if((!firmware.IsValid() || firmware.GetSize() != size) && !altFilename.empty()) {
			string altPath = FolderUtilities::CombinePath(FolderUtilities::GetFirmwareFolder(), altFilename);
			firmware = VirtualFile(altPath);
		}
		if(firmware.IsValid() && firmware.GetSize() == size) {
			*out = new uint8_t[firmware.GetSize()];
			firmware.ReadFile(*out, (uint32_t)firmware.GetSize());
			return true;
		}
		return false;
	}
	static bool AttemptLoadFirmware(vector<uint8_t>& out, string filename, uint32_t size, string altFilename = "")
	{
		string path = FolderUtilities::CombinePath(FolderUtilities::GetFirmwareFolder(), filename);
		VirtualFile firmware(path);
		if((!firmware.IsValid() || firmware.GetSize() != size) && !altFilename.empty()) {
			string altPath = FolderUtilities::CombinePath(FolderUtilities::GetFirmwareFolder(), altFilename);
			firmware = VirtualFile(altPath);
		}
		if(firmware.IsValid() && firmware.GetSize() == size) {
			firmware.ReadFile(out);
			return true;
		}
		return false;
	}
public:
	static bool LoadDspFirmware(Emulator* emu, FirmwareType type, string combinedFilename, string splitFilenameProgram, string splitFilenameData, vector<uint8_t> &programRom, vector<uint8_t> &dataRom, vector<uint8_t> &embeddedFirmware, uint32_t programSize = 0x1800, uint32_t dataSize = 0x800)
	{
		if(embeddedFirmware.size() == programSize + dataSize) {
			programRom.insert(programRom.end(), embeddedFirmware.begin(), embeddedFirmware.begin() + programSize);
			dataRom.insert(dataRom.end(), embeddedFirmware.begin() + programSize, embeddedFirmware.end());
			return true;
		} else if(AttemptLoadDspFirmware(combinedFilename, splitFilenameProgram, splitFilenameData, programRom, dataRom, programSize, dataSize)) {
			return true;
		}
		MissingFirmwareMessage msg(combinedFilename.c_str(), type, programSize + dataSize);
		emu->GetNotificationManager()->SendNotification(ConsoleNotificationType::MissingFirmware, &msg);
		//Try again in case the user selected a valid firmware file
		if(AttemptLoadDspFirmware(combinedFilename, splitFilenameProgram, splitFilenameData, programRom, dataRom, programSize, dataSize)) {
			return true;
		}
		MessageManager::DisplayMessage("Error", "Could not find firmware file for DSP: " + combinedFilename);
		return false;
	}
	static bool LoadSt018Firmware(Emulator* emu, vector<uint8_t>& out)
	{
		string filename = "st018.rom";
		uint32_t size = 0x28000;
		if(AttemptLoadFirmware(out, filename, size)) {
			return true;
		}
		MissingFirmwareMessage msg(filename.c_str(), FirmwareType::ST018, size);
		emu->GetNotificationManager()->SendNotification(ConsoleNotificationType::MissingFirmware, &msg);
		if(AttemptLoadFirmware(out, filename, size)) {
			return true;
		}
		MessageManager::DisplayMessage("Error", "Could not find firmware file for ST018");
		return false;
	}
	static bool LoadBsxFirmware(Emulator* emu, uint8_t** prgRom, uint32_t& prgSize)
	{
		if(AttemptLoadBsxFirmware(prgRom, prgSize)) {
			return true;
		}
		MissingFirmwareMessage msg("BS-X.bin", FirmwareType::Satellaview, 1024*1024);
		emu->GetNotificationManager()->SendNotification(ConsoleNotificationType::MissingFirmware, &msg);
		if(AttemptLoadBsxFirmware(prgRom, prgSize)) {
			return true;
		}
		MessageManager::DisplayMessage("Error", "Could not find firmware file for BS-X");
		return false;
	}
	static bool LoadSufamiTurboFirmware(Emulator* emu, vector<uint8_t>& data)
	{
		string filename = "SufamiTurbo.sfc";
		if(AttemptLoadFirmware(data, filename, 0x40000)) {
			return true;
		}
		MissingFirmwareMessage msg(filename.c_str(), FirmwareType::SufamiTurbo, 0x40000);
		emu->GetNotificationManager()->SendNotification(ConsoleNotificationType::MissingFirmware, &msg);
		if(AttemptLoadFirmware(data, filename, 0x40000)) {
			return true;
		}
		MessageManager::DisplayMessage("Error", "Could not find firmware file for Sufami Turbo");
		return false;
	}
	static bool LoadSgbFirmware(Emulator* emu, uint8_t** prgRom, uint32_t& prgSize, bool useSgb2, bool promptForFirmware)
	{
		string filename = useSgb2 ? "SGB2.sfc" : "SGB1.sfc";
		prgSize = useSgb2 ? 0x80000 : 0x40000;
		if(AttemptLoadFirmware(prgRom, filename, prgSize)) {
			return true;
		}
		if(promptForFirmware) {
			MissingFirmwareMessage msg(filename.c_str(), useSgb2 ? FirmwareType::SGB2 : FirmwareType::SGB1, prgSize);
			emu->GetNotificationManager()->SendNotification(ConsoleNotificationType::MissingFirmware, &msg);
			if(AttemptLoadFirmware(prgRom, filename, prgSize)) {
				return true;
			}
			MessageManager::DisplayMessage("Error", "Could not find firmware file for Super Game Boy");
		}
		return false;
	}
	static bool LoadGbBootRom(Emulator* emu, uint8_t** bootRom, FirmwareType type)
	{
		string filename;
		string altFilename;
		switch(type) {
			default:
			case FirmwareType::Gameboy: filename = "dmg_boot.bin"; altFilename = "gb_bios.bin"; break;
			case FirmwareType::GameboyColor: filename = "cgb_boot.bin"; altFilename = "gbc_bios.bin"; break;
			case FirmwareType::Sgb1GameboyCpu: filename = "sgb_boot.bin"; altFilename = "sgb_bios.bin"; break;
			case FirmwareType::Sgb2GameboyCpu: filename = "sgb2_boot.bin"; altFilename = "sgb_bios.bin"; break;
		}
		uint32_t size = type == FirmwareType::GameboyColor ? 2304 : 256;
		if(AttemptLoadFirmware(bootRom, filename, size, altFilename)) {
			return true;
		}
		return false;
	}
	static bool LoadGbaBootRom(Emulator* emu, uint8_t** bootRom)
	{
		string filename = "gba_bios.bin";
		uint32_t size = 0x4000;
		if(AttemptLoadFirmware(bootRom, filename, size)) {
			return true;
		}
		MissingFirmwareMessage msg(filename.c_str(), FirmwareType::GameboyAdvance, size);
		emu->GetNotificationManager()->SendNotification(ConsoleNotificationType::MissingFirmware, &msg);
		if(AttemptLoadFirmware(bootRom, filename, size)) {
			return true;
		}
		MessageManager::DisplayMessage("Error", "Could not find BIOS rom: " + filename);
		return false;
	}
	static bool LoadFdsFirmware(Emulator* emu, uint8_t** biosRom)
	{
		string filename = "disksys.rom";
		uint32_t size = 0x2000;
		if(AttemptLoadFirmware(biosRom, filename, size, "FdsBios.bin")) {
			return true;
		}
		MissingFirmwareMessage msg(filename.c_str(), FirmwareType::FDS, size);
		emu->GetNotificationManager()->SendNotification(ConsoleNotificationType::MissingFirmware, &msg);
		if(AttemptLoadFirmware(biosRom, filename, size, "FdsBios.bin")) {
			return true;
		}
		MessageManager::DisplayMessage("Error", "Could not find firmware file for Famicom Disk System");
		return false;
	}
	static bool LoadStudyBoxFirmware(Emulator* emu, uint8_t** biosRom)
	{
		string filename = "StudyBox.bin";
		uint32_t size = 0x40000;
		if(AttemptLoadFirmware(biosRom, filename, size, "StudyBox.bin")) {
			return true;
		}
		MissingFirmwareMessage msg(filename.c_str(), FirmwareType::StudyBox, size);
		emu->GetNotificationManager()->SendNotification(ConsoleNotificationType::MissingFirmware, &msg);
		if(AttemptLoadFirmware(biosRom, filename, size, "StudyBox.bin")) {
			return true;
		}
		MessageManager::DisplayMessage("Error", "Could not find firmware file for Study Box");
		return false;
	}
	static bool LoadPceSuperCdFirmware(Emulator* emu, vector<uint8_t>& biosRom)
	{
		string filename = "[BIOS] Super CD-ROM System (Japan) (v3.0).pce";
		string altName = "syscard3.pce";
		uint32_t size = 0x40000;
		if(AttemptLoadFirmware(biosRom, filename, size, altName)) {
			return true;
		}
		MissingFirmwareMessage msg(filename.c_str(), FirmwareType::PceSuperCd, size);
		emu->GetNotificationManager()->SendNotification(ConsoleNotificationType::MissingFirmware, &msg);
		if(AttemptLoadFirmware(biosRom, filename, size, altName)) {
			return true;
		}
		MessageManager::DisplayMessage("Error", "Could not find firmware file for PC Engine CD-ROM");
		return false;
	}
	static bool LoadPceGamesExpressFirmware(Emulator* emu, vector<uint8_t>& biosRom)
	{
		string filename = "[BIOS] Games Express CD Card (Japan).pce";
		string altName = "gecard.pce";
		if(AttemptLoadFirmware(biosRom, filename, 0x8000, altName) || AttemptLoadFirmware(biosRom, filename, 0x4000, altName)) {
			return true;
		}
		MissingFirmwareMessage msg(filename.c_str(), FirmwareType::PceGamesExpress, 0x8000, 0x4000);
		emu->GetNotificationManager()->SendNotification(ConsoleNotificationType::MissingFirmware, &msg);
		if(AttemptLoadFirmware(biosRom, filename, 0x8000, altName) || AttemptLoadFirmware(biosRom, filename, 0x4000, altName)) {
			return true;
		}
		MessageManager::DisplayMessage("Error", "Could not find firmware file for the Games Express Card");
		return false;
	}
	static bool LoadSmsBios(Emulator* emu, vector<uint8_t>& biosRom, bool forGameGear)
	{
		string filename = forGameGear ? "bios.gg" : "bios.sms";
		string path = FolderUtilities::CombinePath(FolderUtilities::GetFirmwareFolder(), filename);
		VirtualFile firmware(path);
		if(firmware.IsValid()) {
			firmware.ReadFile(biosRom);
			return true;
		}
		return false;
	}
	static bool LoadColecoVisionBios(Emulator* emu, vector<uint8_t>& biosRom)
	{
		string filename = "bios.col";
		uint32_t size = 0x2000;
		if(AttemptLoadFirmware(biosRom, filename, size)) {
			return true;
		}
		MissingFirmwareMessage msg(filename.c_str(), FirmwareType::ColecoVision, size);
		emu->GetNotificationManager()->SendNotification(ConsoleNotificationType::MissingFirmware, &msg);
		if(AttemptLoadFirmware(biosRom, filename, size)) {
			return true;
		}
		MessageManager::DisplayMessage("Error", "Could not find firmware file for the ColecoVision");
		return false;
	}
	static bool LoadWsBootRom(Emulator* emu, vector<uint8_t>& bootRom, WsModel model)
	{
		string filename;
		FirmwareType firmwareType;
		switch(model) {
			default:
			case WsModel::Monochrome: filename = "bootrom.ws"; firmwareType = FirmwareType::WonderSwan; break;
			case WsModel::Color: filename = "bootrom.wsc"; firmwareType = FirmwareType::WonderSwanColor; break;
			case WsModel::SwanCrystal: filename = "bootrom_sc.wsc"; firmwareType = FirmwareType::SwanCrystal; break;
		}
		uint32_t size = model == WsModel::Monochrome ? 0x1000 : 0x2000;
		string path = FolderUtilities::CombinePath(FolderUtilities::GetFirmwareFolder(), filename);
		if(AttemptLoadFirmware(bootRom, filename, size)) {
			return true;
		}
		MissingFirmwareMessage msg(filename.c_str(), firmwareType, size);
		emu->GetNotificationManager()->SendNotification(ConsoleNotificationType::MissingFirmware, &msg);
		if(AttemptLoadFirmware(bootRom, filename, size)) {
			return true;
		}
		MessageManager::DisplayMessage("Error", "Could not find boot rom for the WonderSwan, skipping boot screen.");
		return false;
	}
	static bool LoadYmf288AdpcmRom(Emulator* emu, vector<uint8_t>& romData)
	{
		string filename = "ymf288_adpcm_rom.bin";
		uint32_t size = 0x2000;
		if(AttemptLoadFirmware(romData, filename, size)) {
			return true;
		}
		MissingFirmwareMessage msg(filename.c_str(), FirmwareType::Ymf288AdpcmRom, size);
		emu->GetNotificationManager()->SendNotification(ConsoleNotificationType::MissingFirmware, &msg);
		if(AttemptLoadFirmware(romData, filename, size)) {
			return true;
		}
		MessageManager::DisplayMessage("Error", "Could not find ADPCM ROM for YMF288 (EPSM) - sound emulation will be incorrect.");
		return false;
	}
};
```

## File: Core/Shared/FrameLimiter.h
```
#pragma once
#include "Utilities/Timer.h"
class FrameLimiter
{
private:
	Timer _clockTimer;
	double _targetTime;
	double _delay;
	bool _resetRunTimers;
public:
	FrameLimiter(double delay)
	{
		_delay = delay;
		_targetTime = _delay;
		_resetRunTimers = false;
	}
	void SetDelay(double delay)
	{
		_delay = delay;
		_resetRunTimers = true;
	}
	void ProcessFrame()
	{
		if(_resetRunTimers || (_clockTimer.GetElapsedMS() - _targetTime) > 100) {
			_clockTimer.Reset();
			_targetTime = 0;
			_resetRunTimers = false;
		}
		_targetTime += _delay;
	}
	bool WaitForNextFrame()
	{
		if(_targetTime - _clockTimer.GetElapsedMS() > 50) {
			_clockTimer.WaitUntil(_clockTimer.GetElapsedMS() + 40);
			return true;
		}
		_clockTimer.WaitUntil(_targetTime);
		return false;
	}
};
```

## File: Core/Shared/HistoryViewer.cpp
```cpp
#include "pch.h"
#include "Shared/HistoryViewer.h"
#include "Shared/RewindData.h"
#include "Shared/Emulator.h"
#include "Shared/EmuSettings.h"
#include "Shared/Video/VideoRenderer.h"
#include "Shared/BaseControlManager.h"
#include "Shared/RewindManager.h"
#include "Shared/CheatManager.h"
#include "Shared/BaseControlDevice.h"
#include "Shared/Audio/SoundMixer.h"
#include "Shared/NotificationManager.h"
#include "Shared/Movies/MovieRecorder.h"
#include "Shared/SaveStateManager.h"
HistoryViewer::HistoryViewer(Emulator* emu)
{
	_emu = emu;
	_position = 0;
	_pollCounter = 0;
}
HistoryViewer::~HistoryViewer()
{
}
bool HistoryViewer::Initialize(Emulator* mainEmu)
{
	auto mainLock = mainEmu->AcquireLock();
	auto subLock = _emu->AcquireLock();
	if(!_emu->LoadRom(mainEmu->GetRomInfo().RomFile, mainEmu->GetRomInfo().PatchFile)) {
		return false;
	}
	_mainEmu = mainEmu;
	vector<CheatCode> cheats = _mainEmu->GetCheatManager()->GetCheats();
	_emu->GetCheatManager()->SetCheats(cheats);
	_emu->GetSettings()->GetPreferences().RewindBufferSize = 0;
	_emu->GetBatteryManager()->Initialize("");
	_history = mainEmu->GetRewindManager()->GetHistory();
	_emu->UnregisterInputProvider(this);
	_emu->RegisterInputProvider(this);
	SeekTo(0);
	return true;
}
void HistoryViewer::SetOptions(HistoryViewerOptions options)
{
	if(options.IsPaused) {
		_emu->Pause();
	} else {
		_emu->Resume();
	}
	_emu->GetSettings()->GetAudioConfig().MasterVolume = options.Volume;
	_emu->GetVideoRenderer()->SetRendererSize(options.Width, options.Height);
}
HistoryViewerState HistoryViewer::GetState()
{
	HistoryViewerState state = {};
	state.Volume = _emu->GetSettings()->GetAudioConfig().MasterVolume;
	state.IsPaused = _emu->IsPaused();
	state.Position = _position * RewindManager::BufferSize;
	state.Length = (uint32_t)(_history.size() * RewindManager::BufferSize);
	state.Fps = _emu->GetTimingInfo(_emu->GetCpuTypes()[0]).Fps;
	uint32_t segmentCount = 0;
	for(size_t i = 0; i < _history.size(); i++) {
		if(_history[i].EndOfSegment || i == _history.size() - 1) {
			state.Segments[segmentCount] = (uint32_t)i * RewindManager::BufferSize;
			segmentCount++;
			if(segmentCount == 1000) {
				break;
			}
		}
	}
	state.SegmentCount = segmentCount;
	return state;
}
void HistoryViewer::SeekTo(uint32_t seekPosition)
{
	seekPosition /= RewindManager::BufferSize;
	if(seekPosition < _history.size()) {
		auto lock = _emu->AcquireLock();
		_position = seekPosition;
		RewindData rewindData = _history[_position];
		rewindData.LoadState(_emu, _history, _position);
		_emu->GetSoundMixer()->StopAudio(true);
		_pollCounter = 0;
	}
}
bool HistoryViewer::CreateSaveState(string outputFile, uint32_t position)
{
	if(_history.empty()) {
		return false;
	}
	position /= RewindManager::BufferSize;
	position = std::min(position, (uint32_t)_history.size() - 1);
	std::stringstream stateData;
	_emu->GetSaveStateManager()->GetSaveStateHeader(stateData);
	_history[position].GetStateData(stateData, _history, position);
	ofstream output(outputFile, ios::binary);
	if(output) {
		output << stateData.rdbuf();
		output.close();
		return true;
	}
	return false;
}
bool HistoryViewer::SaveMovie(string movieFile, uint32_t startPosition, uint32_t endPosition)
{
	startPosition /= RewindManager::BufferSize;
	endPosition /= RewindManager::BufferSize;
	stringstream state;
	auto lock = _emu->AcquireLock();
	_emu->Serialize(state, true, false);
	unique_ptr<MovieRecorder> recorder(new MovieRecorder(_emu));
	bool result = recorder->CreateMovie(movieFile, _history, startPosition, endPosition, _mainEmu->GetBatteryManager()->HasBattery());
	_emu->Deserialize(state, SaveStateManager::FileFormatVersion, true);
	return result;
}
void HistoryViewer::ResumeGameplay(uint32_t resumePosition)
{
	resumePosition /= RewindManager::BufferSize;
	auto lock = _mainEmu->AcquireLock();
	RomInfo mainRom = _mainEmu->GetRomInfo();
	RomInfo viewerRom = _emu->GetRomInfo();
	if(!_mainEmu->IsRunning() || (string)mainRom.RomFile != (string)viewerRom.RomFile || (string)mainRom.PatchFile != (string)viewerRom.PatchFile) {
		if(!_mainEmu->LoadRom(_emu->GetRomInfo().RomFile, _emu->GetRomInfo().PatchFile)) {
			return;
		}
	}
	if(resumePosition < _history.size()) {
		_history[resumePosition].LoadState(_mainEmu, _history, resumePosition);
	} else {
		_history[_history.size() - 1].LoadState(_mainEmu, _history, (int32_t)_history.size() - 1);
	}
}
bool HistoryViewer::SetInput(BaseControlDevice *device)
{
	uint8_t port = device->GetPort();
	if(_position < _history.size()) {
		std::deque<ControlDeviceState> &stateData = _history[_position].InputLogs[port];
		if(_pollCounter < stateData.size()) {
			ControlDeviceState state = stateData[_pollCounter];
			device->SetRawState(state);
		}
	}
	if(port == 0 && _pollCounter < RewindManager::BufferSize) {
		_pollCounter++;
	}
	return true;
}
void HistoryViewer::ProcessEndOfFrame()
{
	if(_history.empty()) {
		return;
	}
	if(_pollCounter >= (uint32_t)_history[_position].FrameCount) {
		_pollCounter = 0;
		_position++;
		if(_position >= _history.size()) {
			SeekTo(0);
			_emu->Pause();
			return;
		}
		RewindData rewindData = _history[_position];
		rewindData.LoadState(_emu, _history, _position);
	}
}
```

## File: Core/Shared/HistoryViewer.h
```
#pragma once
#include "pch.h"
#include <deque>
#include "Shared/Interfaces/IInputProvider.h"
#include "Shared/RewindData.h"
class Emulator;
class BaseControlDevice;
struct HistoryViewerState
{
	uint32_t Position = 0;
	uint32_t Length = 0;
	uint32_t Volume = 0;
	double Fps = 60.0;
	bool IsPaused = false;
	uint32_t SegmentCount = 0;
	uint32_t Segments[1000] = {};
};
struct HistoryViewerOptions
{
	bool IsPaused = false;
	uint32_t Volume = 100;
	uint32_t Width = 256;
	uint32_t Height = 240;
};
class HistoryViewer : public IInputProvider
{
private:
	Emulator* _emu = nullptr;
	Emulator* _mainEmu = nullptr;
	deque<RewindData> _history;
	uint32_t _position = 0;
	uint32_t _pollCounter = 0;
public:
	HistoryViewer(Emulator* emu);
	virtual ~HistoryViewer();
	bool Initialize(Emulator* mainEmu);
	void SetOptions(HistoryViewerOptions options);
	HistoryViewerState GetState();
	void SeekTo(uint32_t seekPosition);
	bool CreateSaveState(string outputFile, uint32_t position);
	bool SaveMovie(string movieFile, uint32_t startPosition, uint32_t endPosition);
	void ResumeGameplay(uint32_t resumePosition);
	void ProcessEndOfFrame();
	bool SetInput(BaseControlDevice* device) override;
};
```

## File: Core/Shared/IControllerHub.h
```
#pragma once
#include "pch.h"
class BaseControlDevice;
class IControllerHub
{
public:
	static constexpr int MaxSubPorts = 5;
	virtual void RefreshHubState() = 0;
	virtual int GetHubPortCount() = 0;
	virtual shared_ptr<BaseControlDevice> GetController(int index) = 0;
};
```

## File: Core/Shared/InputHud.cpp
```cpp
#include "pch.h"
#include "Shared/InputHud.h"
#include "Shared/Emulator.h"
#include "Shared/BaseControlManager.h"
#include "Shared/BaseControlDevice.h"
#include "Shared/EmuSettings.h"
#include "Shared/Video/DebugHud.h"
static constexpr int color[2] = { 0x00111111, 0x00FFFFFF };
InputHud::InputHud(Emulator* emu, DebugHud* hud)
{
	_emu = emu;
	_hud = hud;
}
void InputHud::DrawButton(int x, int y, int width, int height, bool pressed)
{
	_hud->DrawRectangle(_xOffset + x, _yOffset + y, width, height, color[pressed], true, 1);
}
void InputHud::DrawNumber(int number, int x, int y)
{
	switch(number) {
		case 1:
			_hud->DrawLine(x+1 + _xOffset, y + _yOffset, x+1 + _xOffset, 4 + y + _yOffset, color[0], 1);
			_hud->DrawLine(x + _xOffset, 4 + y + _yOffset, x+2 + _xOffset, 4 + y + _yOffset, color[0], 1);
			_hud->DrawPixel(x + _xOffset, 1 + y + _yOffset, color[0], 1);
			break;
		case 2:
			_hud->DrawLine(x + _xOffset, y + _yOffset, x+2 + _xOffset, y + _yOffset, color[0], 1);
			_hud->DrawPixel(x+2 + _xOffset, 1 + y + _yOffset, color[0], 1);
			_hud->DrawLine(x + _xOffset, 2 + y + _yOffset, x+2 + _xOffset, 2 + y + _yOffset, color[0], 1);
			_hud->DrawPixel(x + _xOffset, 3 + y + _yOffset, color[0], 1);
			_hud->DrawLine(x + _xOffset, 4 + y + _yOffset, x+2 + _xOffset, 4 + y + _yOffset, color[0], 1);
			break;
		case 3:
			_hud->DrawLine(x + _xOffset, y + _yOffset, x+2 + _xOffset, y + _yOffset, color[0], 1);
			_hud->DrawPixel(x+2 + _xOffset, 1 + y + _yOffset, color[0], 1);
			_hud->DrawLine(x + _xOffset, 2 + y + _yOffset, x+2 + _xOffset, 2 + y + _yOffset, color[0], 1);
			_hud->DrawPixel(x+2 + _xOffset, 3 + y + _yOffset, color[0], 1);
			_hud->DrawLine(x + _xOffset, 4 + y + _yOffset, x+2 + _xOffset, 4 + y + _yOffset, color[0], 1);
			break;
		case 4:
			_hud->DrawLine(x + _xOffset, y + _yOffset, x + _xOffset, 2 + y + _yOffset, color[0], 1);
			_hud->DrawLine(x+2 + _xOffset, y + _yOffset, x+2 + _xOffset, 4 + y + _yOffset, color[0], 1);
			_hud->DrawLine(x + _xOffset, 2 + y + _yOffset, x+2 + _xOffset, 2 + y + _yOffset, color[0], 1);
			break;
		case 5:
			_hud->DrawLine(x + _xOffset, y + _yOffset, x+2 + _xOffset, y + _yOffset, color[0], 1);
			_hud->DrawPixel(x + _xOffset, 1 + y + _yOffset, color[0], 1);
			_hud->DrawLine(x + _xOffset, 2 + y + _yOffset, x+2 + _xOffset, 2 + y + _yOffset, color[0], 1);
			_hud->DrawPixel(x+2 + _xOffset, 3 + y + _yOffset, color[0], 1);
			_hud->DrawLine(x + _xOffset, 4 + y + _yOffset, x+2 + _xOffset, 4 + y + _yOffset, color[0], 1);
			break;
		case 6:
			_hud->DrawLine(x + _xOffset, y + _yOffset, x + 2 + _xOffset, y + _yOffset, color[0], 1);
			_hud->DrawLine(x + _xOffset, 1 + y + _yOffset, x + _xOffset, y + _yOffset + 3, color[0], 1);
			_hud->DrawLine(x + _xOffset, 2 + y + _yOffset, x + 2 + _xOffset, 2 + y + _yOffset, color[0], 1);
			_hud->DrawPixel(x + 2 + _xOffset, 3 + y + _yOffset, color[0], 1);
			_hud->DrawLine(x + _xOffset, 4 + y + _yOffset, x + 2 + _xOffset, 4 + y + _yOffset, color[0], 1);
			break;
		case 7:
			_hud->DrawLine(x + _xOffset, y + _yOffset, x + 2 + _xOffset, y + _yOffset, color[0], 1);
			_hud->DrawLine(x + _xOffset + 2, y + _yOffset, x + _xOffset + 2, 4 + y + _yOffset, color[0], 1);
			break;
		case 8:
			_hud->DrawRectangle(x + _xOffset, y + _yOffset, 3, 5, color[0], false, 1);
			_hud->DrawPixel(x + _xOffset + 1, y + _yOffset + 2, color[0], 1);
			break;
		default:
			break;
	}
}
void InputHud::DrawMousePosition(MousePosition pos)
{
	if(pos.X >= 0 && pos.Y >= 0) {
		OverscanDimensions overscan = _emu->GetSettings()->GetOverscan();
		_emu->GetDebugHud()->DrawRectangle(pos.X - 1 - overscan.Left, pos.Y - 1 - overscan.Top, 3, 3, 0x00FF0000, true, 1);
		_emu->GetDebugHud()->DrawRectangle(pos.X - 1 - overscan.Left, pos.Y - 1 - overscan.Top, 3, 3, 0x00808080, false, 1);
	}
}
void InputHud::DrawOutline(int width, int height)
{
	InputConfig& cfg = _emu->GetSettings()->GetInputConfig();
	switch(cfg.DisplayInputPosition) {
		default:
		case InputDisplayPosition::TopLeft:
			break;
		case InputDisplayPosition::TopRight:
			_xOffset -= width + 1;
			break;
		case InputDisplayPosition::BottomLeft:
			_yOffset -= height + 1;
			break;
		case InputDisplayPosition::BottomRight:
			_yOffset -= height + 1;
			_xOffset -= width + 1;
			break;
	}
	_hud->DrawRectangle(_xOffset, _yOffset, width, height, 0x80CCCCCC, true, 1);
	_hud->DrawRectangle(_xOffset, _yOffset, width, height, color[0], false, 1);
	_outlineWidth = width;
	_outlineHeight = height;
}
void InputHud::DrawController(ControllerData& data, BaseControlManager* controlManager)
{
	shared_ptr<BaseControlDevice> controller = controlManager->CreateControllerDevice(data.Type, data.Port);
	if(!controller) {
		return;
	}
	controller->SetRawState(data.State);
	controller->DrawController(*this);
}
void InputHud::EndDrawController()
{
	if(_outlineHeight > 0 && _outlineWidth > 0) {
		InputConfig& cfg = _emu->GetSettings()->GetInputConfig();
		switch(cfg.DisplayInputPosition) {
			default:
			case InputDisplayPosition::TopLeft:
				if(cfg.DisplayInputHorizontally) {
					_xOffset += _outlineWidth + 1;
				} else {
					_yOffset += _outlineHeight + 1;
				}
				break;
			case InputDisplayPosition::TopRight:
				if(!cfg.DisplayInputHorizontally) {
					_xOffset += _outlineWidth + 1;
					_yOffset += _outlineHeight + 1;
				}
				break;
			case InputDisplayPosition::BottomLeft:
				if(cfg.DisplayInputHorizontally) {
					_xOffset += _outlineWidth + 1;
					_yOffset += _outlineHeight + 1;
				}
				break;
			case InputDisplayPosition::BottomRight:
				if(cfg.DisplayInputHorizontally) {
					_yOffset += _outlineHeight + 1;
				} else {
					_xOffset += _outlineWidth + 1;
				}
				break;
		}
		_outlineWidth = 0;
		_outlineHeight = 0;
	}
	_controllerIndex++;
}
void InputHud::DrawControllers(FrameInfo size, vector<ControllerData> controllerData)
{
	if(_emu->GetAudioPlayerHud()) {
		return;
	}
	shared_ptr<IConsole> console = _emu->GetConsole();
	if(!console) {
		return;
	}
	InputConfig& cfg = _emu->GetSettings()->GetInputConfig();
	bool hasVisiblePort = false;
	for(int i = 0; i < 8; i++) {
		hasVisiblePort |= cfg.DisplayInputPort[i];
	}
	if(!hasVisiblePort) {
		return;
	}
	switch(cfg.DisplayInputPosition) {
		default:
		case InputDisplayPosition::TopLeft:
			_xOffset = 2;
			_yOffset = 2;
			break;
		case InputDisplayPosition::TopRight:
			_xOffset = size.Width - 1;
			_yOffset = 2;
			break;
		case InputDisplayPosition::BottomLeft:
			_xOffset = 2;
			_yOffset = size.Height - 1;
			break;
		case InputDisplayPosition::BottomRight:
			_xOffset = size.Width - 1;
			_yOffset = size.Height - 1;
			break;
	}
	_controllerIndex = 0;
	for(ControllerData& portData : controllerData) {
		DrawController(portData, console->GetControlManager());
	}
}
```

## File: Core/Shared/InputHud.h
```
#pragma once
#include "pch.h"
#include "Shared/SettingTypes.h"
#include "Shared/ControlDeviceState.h"
#include "Shared/Interfaces/IKeyManager.h"
class Emulator;
class DebugHud;
class BaseControlManager;
class InputHud
{
private:
	Emulator* _emu = nullptr;
	DebugHud* _hud = nullptr;
	int _xOffset = 0;
	int _yOffset = 0;
	int _outlineWidth = 0;
	int _outlineHeight = 0;
	int _controllerIndex = 0;
	void DrawController(ControllerData& data, BaseControlManager* controlManager);
public:
	InputHud(Emulator *emu, DebugHud* hud);
	void DrawMousePosition(MousePosition pos);
	void DrawOutline(int width, int height);
	void DrawButton(int x, int y, int width, int height, bool pressed);
	void DrawNumber(int number, int x, int y);
	void EndDrawController();
	int GetControllerIndex() { return _controllerIndex; }
	void DrawControllers(FrameInfo size, vector<ControllerData> controllerData);
};
```

## File: Core/Shared/Interfaces/IAudioDevice.h
```
#pragma once
#include "pch.h"
struct AudioStatistics
{
	double AverageLatency = 0;
	uint32_t BufferUnderrunEventCount = 0;
	uint32_t BufferSize = 0;
};
class IAudioDevice
{
public:
	virtual ~IAudioDevice() {}
	virtual void PlayBuffer(int16_t *soundBuffer, uint32_t bufferSize, uint32_t sampleRate, bool isStereo) = 0;
	virtual void Stop() = 0;
	virtual void Pause() = 0;
	virtual void ProcessEndOfFrame() = 0;
	virtual string GetAvailableDevices() = 0;
	virtual void SetAudioDevice(string deviceName) = 0;
	virtual AudioStatistics GetStatistics() = 0;
};
```

## File: Core/Shared/Interfaces/IAudioProvider.h
```
#pragma once
#include "pch.h"
class IAudioProvider
{
public:
	virtual void MixAudio(int16_t* out, uint32_t sampleCount, uint32_t sampleRate) = 0;
};
```

## File: Core/Shared/Interfaces/IBarcodeReader.h
```
#pragma once
#include "pch.h"
class IBarcodeReader
{
public:
	virtual void InputBarcode(uint64_t barcode, uint32_t digitCount) = 0;
};
```

## File: Core/Shared/Interfaces/IBattery.h
```
#pragma once
class IBattery
{
public:
	virtual void SaveBattery() = 0;
};
```

## File: Core/Shared/Interfaces/IConsole.h
```
#pragma once
#include "pch.h"
#include "Utilities/ISerializable.h"
#include "Core/Debugger/DebugTypes.h"
#include "Shared/Audio/AudioPlayerTypes.h"
#include "Shared/Interfaces/INotificationListener.h"
#include "Shared/RomInfo.h"
#include "Shared/TimingInfo.h"
#include "Shared/SaveStateCompatInfo.h"
class BaseControlManager;
class VirtualFile;
class BaseVideoFilter;
struct BaseState;
struct InternalCheatCode;
enum class ConsoleType;
enum class ConsoleRegion;
enum class CpuType : uint8_t;
enum class EmulatorShortcut;
enum class HashType;
enum class LoadRomResult
{
	Success,
	Failure,
	UnknownType
};
struct PpuFrameInfo
{
	uint8_t* FrameBuffer;
	uint32_t Width;
	uint32_t Height;
	uint32_t FrameBufferSize;
	uint32_t FrameCount;
	uint32_t ScanlineCount;
	int32_t FirstScanline;
	uint32_t CycleCount;
};
enum class ShortcutState
{
	Disabled = 0,
	Enabled = 1,
	Default = 2
};
class IConsole : public ISerializable, public INotificationListener
{
public:
	virtual ~IConsole() {}
	virtual void Reset() = 0;
	virtual LoadRomResult LoadRom(VirtualFile& romFile) = 0;
	virtual void RunFrame() = 0;
	virtual void SaveBattery() = 0;
	virtual ShortcutState IsShortcutAllowed(EmulatorShortcut shortcut, uint32_t shortcutParam) { return ShortcutState::Default; }
	virtual BaseControlManager* GetControlManager() = 0;
	virtual DipSwitchInfo GetDipSwitchInfo() { return {}; }
	virtual ConsoleRegion GetRegion() = 0;
	virtual ConsoleType GetConsoleType() = 0;
	virtual vector<CpuType> GetCpuTypes() = 0;
	virtual uint64_t GetMasterClock() = 0;
	virtual uint32_t GetMasterClockRate() = 0;
	virtual double GetFps() = 0;
	virtual TimingInfo GetTimingInfo(CpuType cpuType)
	{
		TimingInfo info = {};
		info.MasterClock = GetMasterClock();
		info.MasterClockRate = GetMasterClockRate();
		info.Fps = GetFps();
		PpuFrameInfo frameInfo = GetPpuFrame();
		info.FrameCount = frameInfo.FrameCount;
		info.CycleCount = frameInfo.CycleCount;
		info.ScanlineCount = frameInfo.ScanlineCount;
		info.FirstScanline = frameInfo.FirstScanline;
		return info;
	}
	virtual BaseVideoFilter* GetVideoFilter(bool getDefaultFilter) = 0;
	virtual void GetScreenRotationOverride(uint32_t& rotation) {}
	virtual PpuFrameInfo GetPpuFrame() = 0;
	virtual string GetHash(HashType hashType) { return {}; }
	virtual RomFormat GetRomFormat() = 0;
	virtual AudioTrackInfo GetAudioTrackInfo() = 0;
	virtual void ProcessAudioPlayerAction(AudioPlayerActionParams p) = 0;
	virtual AddressInfo GetAbsoluteAddress(AddressInfo& relAddress) = 0;
	virtual AddressInfo GetRelativeAddress(AddressInfo& absAddress, CpuType cpuType) = 0;
	virtual void GetConsoleState(BaseState& state, ConsoleType consoleType) = 0;
	virtual SaveStateCompatInfo ValidateSaveStateCompatibility(ConsoleType stateConsoleType) { return {}; }
	virtual void ProcessCheatCode(InternalCheatCode& code, uint32_t addr, uint8_t& value) {}
	virtual void ProcessNotification(ConsoleNotificationType type, void* parameter) {}
};
```

## File: Core/Shared/Interfaces/IInputProvider.h
```
#pragma once
class BaseControlDevice;
class IInputProvider
{
public:
	virtual bool SetInput(BaseControlDevice* device) = 0;
};
```

## File: Core/Shared/Interfaces/IInputRecorder.h
```
#pragma once
#include "pch.h"
class BaseControlDevice;
class IInputRecorder
{
public:
	virtual void RecordInput(vector<shared_ptr<BaseControlDevice>> devices) = 0;
};
```

## File: Core/Shared/Interfaces/IMessageManager.h
```
#pragma once
#include "pch.h"
class IMessageManager
{
public:
	virtual void DisplayMessage(string title, string message) = 0;
};
```

## File: Core/Shared/Interfaces/IMouseManager.h
```
#pragma once
#include "pch.h"
enum class CursorImage
{
	Hidden,
	Arrow,
	Cross
};
struct SystemMouseState
{
	int32_t XPosition;
	int32_t YPosition;
	bool LeftButton;
	bool RightButton;
	bool MiddleButton;
	bool Button4;
	bool Button5;
};
class IMouseManager
{
public:
	virtual ~IMouseManager() {}
	virtual SystemMouseState GetSystemMouseState(void* rendererHandle) = 0;
	virtual bool CaptureMouse(int32_t x, int32_t y, int32_t width, int32_t height, void* rendererHandle) = 0;
	virtual void ReleaseMouse() = 0;
	virtual void SetSystemMousePosition(int32_t x, int32_t y) = 0;
	virtual void SetCursorImage(CursorImage cursor) = 0;
	virtual double GetPixelScale() = 0;
};
```

## File: Core/Shared/Interfaces/INotificationListener.h
```
#pragma once
#include "pch.h"
enum class EmulatorShortcut;
enum class ConsoleNotificationType
{
	GameLoaded,
	StateLoaded,
	GameReset,
	GamePaused,
	GameResumed,
	CodeBreak,
	DebuggerResumed,
	PpuFrameDone,
	ResolutionChanged,
	ConfigChanged,
	ExecuteShortcut,
	ReleaseShortcut,
	EmulationStopped,
	BeforeEmulationStop,
	ViewerRefresh,
	EventViewerRefresh,
	MissingFirmware,
	SufamiTurboFilePrompt,
	BeforeGameUnload,
	BeforeGameLoad,
	GameLoadFailed,
	CheatsChanged,
	RequestConfigChange,
	RefreshSoftwareRenderer,
};
struct GameLoadedEventParams
{
	bool IsPaused;
	bool IsPowerCycle;
};
class INotificationListener
{
public:
	virtual void ProcessNotification(ConsoleNotificationType type, void* parameter) = 0;
};
struct ExecuteShortcutParams
{
	EmulatorShortcut Shortcut;
	uint32_t Param;
	void* ParamPtr;
};
```

## File: Core/Shared/Interfaces/IRenderingDevice.h
```
#pragma once
#include "pch.h"
#include "Shared/SettingTypes.h"
struct RenderedFrame;
struct RenderSurfaceInfo
{
	uint32_t* Buffer = nullptr;
	uint32_t Width = 0;
	uint32_t Height = 0;
	bool IsDirty = true;
	bool UpdateSize(uint32_t width, uint32_t height)
	{
		if(Width != width || Height != height) {
			delete[] Buffer;
			Buffer = new uint32_t[height * width];
			Width = width;
			Height = height;
			Clear();
			return true;
		}
		return false;
	}
	void Clear()
	{
		memset(Buffer, 0, Width * Height * sizeof(uint32_t));
		IsDirty = true;
	}
	~RenderSurfaceInfo()
	{
		delete[] Buffer;
	}
};
class IRenderingDevice
{
	public:
		virtual ~IRenderingDevice() {}
		virtual void UpdateFrame(RenderedFrame& frame) = 0;
		virtual void ClearFrame() = 0;
		virtual void Render(RenderSurfaceInfo& emuHud, RenderSurfaceInfo& scriptHud) = 0;
		virtual void Reset() = 0;
		virtual void OnRendererThreadStarted() {}
		virtual void SetExclusiveFullscreenMode(bool fullscreen, void* windowHandle) = 0;
};
```

## File: Core/Shared/Interfaces/ITapeRecorder.h
```
#pragma once
#include "pch.h"
enum class TapeRecorderAction
{
	Play,
	StartRecord,
	StopRecord
};
class ITapeRecorder
{
public:
	virtual void ProcessTapeRecorderAction(TapeRecorderAction action, string filename) = 0;
	virtual bool IsRecording() = 0;
};
```

## File: Core/Shared/KeyDefinitions.h
```
#pragma once
#include "pch.h"
struct KeyDefinition
{
	string name;
	uint32_t keyCode;
	static vector<KeyDefinition> GetSharedKeyDefinitions()
	{
		return {
			{ "", 0 },
			{ "Cancel", 1 },
			{ "Backspace", 2 },
			{ "Tab", 3 },
			{ "Line Feed", 4 },
			{ "Clear", 5 },
			{ "Enter", 6 },
			{ "Pause", 7 },
			{ "Caps Lock", 8 },
			{ "Kana Mode", 9 },
			{ "Junja Mode", 10 },
			{ "Final Mode", 11 },
			{ "Kanji Mode", 12 },
			{ "Esc", 13 },
			{ "IME convert", 14 },
			{ "IME nonconvert", 15 },
			{ "IME accept", 16 },
			{ "IME mode change request", 17 },
			{ "Space", 18 },
			{ "Page Up", 19 },
			{ "Page Down", 20 },
			{ "End", 21 },
			{ "Home", 22 },
			{ "Left Arrow", 23 },
			{ "Up Arrow", 24 },
			{ "Right Arrow", 25 },
			{ "Down Arrow", 26 },
			{ "Select", 27 },
			{ "Print", 28 },
			{ "Execute", 29 },
			{ "Print Screen", 30 },
			{ "Insert", 31 },
			{ "Delete", 32 },
			{ "Help", 33 },
			{ "0", 34 },
			{ "1", 35 },
			{ "2", 36 },
			{ "3", 37 },
			{ "4", 38 },
			{ "5", 39 },
			{ "6", 40 },
			{ "7", 41 },
			{ "8", 42 },
			{ "9", 43 },
			{ "A", 44 },
			{ "B", 45 },
			{ "C", 46 },
			{ "D", 47 },
			{ "E", 48 },
			{ "F", 49 },
			{ "G", 50 },
			{ "H", 51 },
			{ "I", 52 },
			{ "J", 53 },
			{ "K", 54 },
			{ "L", 55 },
			{ "M", 56 },
			{ "N", 57 },
			{ "O", 58 },
			{ "P", 59 },
			{ "Q", 60 },
			{ "R", 61 },
			{ "S", 62 },
			{ "T", 63 },
			{ "U", 64 },
			{ "V", 65 },
			{ "W", 66 },
			{ "X", 67 },
			{ "Y", 68 },
			{ "Z", 69 },
			{ "Left Win", 70 },
			{ "Right Win", 71 },
			{ "Apps", 72 },
			{ "Sleep", 73 },
			{ "Numpad 0", 74 },
			{ "Numpad 1", 75 },
			{ "Numpad 2", 76 },
			{ "Numpad 3", 77 },
			{ "Numpad 4", 78 },
			{ "Numpad 5", 79 },
			{ "Numpad 6", 80 },
			{ "Numpad 7", 81 },
			{ "Numpad 8", 82 },
			{ "Numpad 9", 83 },
			{ "Numpad *", 84 },
			{ "Numpad +", 85 },
			{ "Separator", 86 },
			{ "Numpad -", 87 },
			{ "Numpad .", 88 },
			{ "Numpad /", 89 },
			{ "F1", 90 },
			{ "F2", 91 },
			{ "F3", 92 },
			{ "F4", 93 },
			{ "F5", 94 },
			{ "F6", 95 },
			{ "F7", 96 },
			{ "F8", 97 },
			{ "F9", 98 },
			{ "F10", 99 },
			{ "F11", 100 },
			{ "F12", 101 },
			{ "F13", 102 },
			{ "F14", 103 },
			{ "F15", 104 },
			{ "F16", 105 },
			{ "F17", 106 },
			{ "F18", 107 },
			{ "F19", 108 },
			{ "F20", 109 },
			{ "F21", 110 },
			{ "F22", 111 },
			{ "F23", 112 },
			{ "F24", 113 },
			{ "Num Lock", 114 },
			{ "Scroll Lock", 115 },
			{ "Left Shift", 116 },
			{ "Right Shift", 117 },
			{ "Left Ctrl", 118 },
			{ "Right Ctrl", 119 },
			{ "Left Alt", 120 },
			{ "Right Alt", 121 },
			{ "Browser Back", 122 },
			{ "Browser Forward", 123 },
			{ "Browser Refresh", 124 },
			{ "Browser Stop", 125 },
			{ "Browser Search", 126 },
			{ "Browser Favorites", 127 },
			{ "Browser Home", 128 },
			{ "Volume Mute", 129 },
			{ "Volume Down", 130 },
			{ "Volume Up", 131 },
			{ "Next Track", 132 },
			{ "Previous Track", 133 },
			{ "Stop", 134 },
			{ "Play/Pause", 135 },
			{ "Start Mail", 136 },
			{ "Select Media", 137 },
			{ "Start Application 1", 138 },
			{ "Start Application 2", 139 },
			{ ";", 140 },
			{ "=", 141 },
			{ ",", 142 },
			{ "-", 143 },
			{ ".", 144 },
			{ "/", 145 },
			{ "`", 146 },
			{ "AbntC1", 147 },
			{ "AbntC2", 148 },
			{ "[", 149 },
			{ "\\", 150 },
			{ "]", 151 },
			{ "'", 152 },
			{ "Oem8", 153 },
			{ "|", 154 },
			{ "IME Processed", 155 },
			{ "System", 156 },
			{ "OemAttn", 157 },
			{ "DbeAlphanumeric", 157 },
			{ "OemFinish", 158 },
			{ "DbeKatakana", 158 },
			{ "DbeHiragana", 159 },
			{ "OemCopy", 159 },
			{ "DbeSbcsChar", 160 },
			{ "OemAuto", 160 },
			{ "DbeDbcsChar", 161 },
			{ "OemEnlw", 161 },
			{ "OemBackTab", 162 },
			{ "DbeRoman", 162 },
			{ "DbeNoRoman", 163 },
			{ "Attn", 163 },
			{ "CrSel", 164 },
			{ "DbeEnterWordRegisterMode", 164 },
			{ "ExSel", 165 },
			{ "DbeEnterImeConfigureMode", 165 },
			{ "EraseEof", 166 },
			{ "DbeFlushString", 166 },
			{ "Play", 167 },
			{ "DbeCodeInput", 167 },
			{ "DbeNoCodeInput", 168 },
			{ "Zoom", 168 },
			{ "NoName", 169 },
			{ "DbeDetermineString", 169 },
			{ "DbeEnterDialogConversionMode", 170 },
			{ "Pa1", 170 },
			{ "OemClear", 171 },
			{ "DeadCharProcessed", 172 },
			{ "Mouse Left", 0x200 },
			{ "Mouse Right", 0x201 },
			{ "Mouse Middle", 0x202 },
			{ "Mouse 4", 0x203 },
			{ "Mouse 5", 0x204 },
			{ "FnLeftArrow", 10001 },
			{ "FnRightArrow", 10002 },
			{ "FnUpArrow", 10003 },
			{ "FnDownArrow", 10004 }
		};
	};
};
```

## File: Core/Shared/McpServer.cpp
```cpp
#include "pch.h"
#include "Shared/McpServer.h"
#include "Shared/Emulator.h"
#include "Shared/BaseControlManager.h"
#include "Shared/BaseControlDevice.h"
#include "Shared/ControlDeviceState.h"
#include "Shared/Interfaces/IConsole.h"
#include "Shared/MessageManager.h"
#include "Shared/MemoryType.h"
#include "Shared/SettingTypes.h"
#include "Shared/CpuType.h"
#include "Shared/DebuggerRequest.h"
#include "Debugger/Debugger.h"
#include "Debugger/MemoryDumper.h"
#include "Debugger/DebugTypes.h"
#include "Utilities/Socket.h"
#include "Utilities/VirtualFile.h"
#include <sstream>
#include <algorithm>
std::string McpServer::ExtractString(const std::string& json, const std::string& key)
{
	std::string search = "\"" + key + "\"";
	size_t pos = json.find(search);
	if(pos == std::string::npos) return "";
	pos = json.find(':', pos + search.size());
	if(pos == std::string::npos) return "";
	pos++;
	while(pos < json.size() && (json[pos] == ' ' || json[pos] == '\t')) pos++;
	if(pos >= json.size() || json[pos] != '"') return "";
	pos++;
	std::string result;
	while(pos < json.size() && json[pos] != '"') {
		if(json[pos] == '\\' && pos + 1 < json.size()) {
			pos++;
			if(json[pos] == '"') result += '"';
			else if(json[pos] == '\\') result += '\\';
			else if(json[pos] == 'n') result += '\n';
			else result += json[pos];
		} else {
			result += json[pos];
		}
		pos++;
	}
	return result;
}
int McpServer::ExtractInt(const std::string& json, const std::string& key, int defaultVal)
{
	std::string search = "\"" + key + "\"";
	size_t pos = json.find(search);
	if(pos == std::string::npos) return defaultVal;
	pos = json.find(':', pos + search.size());
	if(pos == std::string::npos) return defaultVal;
	pos++;
	while(pos < json.size() && (json[pos] == ' ' || json[pos] == '\t')) pos++;
	bool negative = false;
	if(pos < json.size() && json[pos] == '-') { negative = true; pos++; }
	int val = 0;
	bool found = false;
	while(pos < json.size() && json[pos] >= '0' && json[pos] <= '9') {
		val = val * 10 + (json[pos] - '0');
		found = true;
		pos++;
	}
	if(!found) return defaultVal;
	return negative ? -val : val;
}
std::string McpServer::OkResponse(int id, const std::string& resultJson)
{
	return "{\"ok\":true,\"result\":" + resultJson + ",\"id\":" + std::to_string(id) + "}";
}
std::string McpServer::ErrorResponse(int id, const std::string& error)
{
	// Escape quotes in error message
	std::string escaped;
	for(char c : error) {
		if(c == '"') escaped += "\\\"";
		else if(c == '\\') escaped += "\\\\";
		else escaped += c;
	}
	return "{\"ok\":false,\"error\":\"" + escaped + "\",\"id\":" + std::to_string(id) + "}";
}
// ============================================================================
// Constructor / Destructor
// ============================================================================
McpServer::McpServer(Emulator* emu, uint16_t port)
	: _emu(emu), _port(port), _stop(false)
{
}
McpServer::~McpServer()
{
	Stop();
}
// ============================================================================
// Start / Stop
// ============================================================================
void McpServer::Start()
{
	if(_listenThread) return;
	_stop = false;
	_listenThread.reset(new std::thread(&McpServer::ListenLoop, this));
	printf("[MCP] Server listening on port %d\n", _port); fflush(stdout);
}
void McpServer::Stop()
{
	_stop = true;
	if(_listener) _listener->Close();
	if(_listenThread && _listenThread->joinable()) {
		_listenThread->join();
		_listenThread.reset();
	}
	_listener.reset();
}
// ============================================================================
// TCP Listen Loop — runs on its own thread
// ============================================================================
void McpServer::ListenLoop()
{
	_listener.reset(new Socket());
	_listener->Bind(_port);
	_listener->Listen(1); // Single client
	while(!_stop) {
		std::unique_ptr<Socket> client = _listener->Accept();
		if(!client->ConnectionError() && !_stop) {
			HandleClient(std::move(client));
		}
	}
}
void McpServer::HandleClient(std::unique_ptr<Socket> client)
{
	printf("[MCP] Client connected\n"); fflush(stdout);
	std::string buffer;
	char chunk[4096];
	while(!_stop && !client->ConnectionError()) {
		int received = client->Recv(chunk, sizeof(chunk) - 1, 0);
		printf("[MCP] Recv returned: %d\n", received); fflush(stdout);
		if(received <= 0) break;
		chunk[received] = '\0';
		buffer += chunk;
		size_t nlPos;
		while((nlPos = buffer.find('\n')) != std::string::npos) {
			std::string line = buffer.substr(0, nlPos);
			buffer = buffer.substr(nlPos + 1);
			if(!line.empty() && line.back() == '\r') line.pop_back();
			if(line.empty()) continue;
			printf("[MCP] Parsing: %s\n", line.c_str()); fflush(stdout);
			auto cmd = ParseCommand(line);
			if(!cmd) {
				std::string err = ErrorResponse(0, "invalid command") + "\n";
				client->Send((char*)err.c_str(), (int)err.size(), 0);
				continue;
			}
			{
				std::lock_guard<std::mutex> lock(_queueMutex);
				_commandQueue.push(cmd);
			}
			std::string response = cmd->WaitForResponse();
			response += "\n";
			client->Send((char*)response.c_str(), (int)response.size(), 0);
		}
	}
}
std::shared_ptr<McpTypedCommand> McpServer::ParseCommand(const std::string& json)
{
	std::string method = ExtractString(json, "method");
	if(method.empty()) return nullptr;
	auto cmd = std::make_shared<McpTypedCommand>();
	cmd->id = ExtractInt(json, "id", 0);
	if(method == "load_rom") {
		cmd->type = McpCommandType::LoadRom;
		cmd->path = ExtractString(json, "path");
	} else if(method == "step_frame") {
		cmd->type = McpCommandType::StepFrame;
		cmd->count = ExtractInt(json, "count", 1);
	} else if(method == "read_memory") {
		cmd->type = McpCommandType::ReadMemory;
		cmd->address = ExtractInt(json, "address", -1);
		cmd->count = ExtractInt(json, "size", 1);
	} else if(method == "write_memory") {
		cmd->type = McpCommandType::WriteMemory;
		cmd->address = ExtractInt(json, "address", -1);
		cmd->value = ExtractInt(json, "value", -1);
	} else if(method == "set_input") {
		cmd->type = McpCommandType::SetInput;
		cmd->port = ExtractInt(json, "port", 0);
		cmd->buttons = ExtractInt(json, "buttons", 0);
	} else if(method == "get_state") {
		cmd->type = McpCommandType::GetState;
	} else {
		return nullptr;
	}
	return cmd;
}
void McpServer::DrainCommandQueue()
{
	static int drainCount = 0;
	if(++drainCount % 600 == 1) { printf("[MCP] Drain count=%d\n", drainCount); fflush(stdout); }
	while(true) {
		std::shared_ptr<McpTypedCommand> cmd;
		{
			std::lock_guard<std::mutex> lock(_queueMutex);
			if(_commandQueue.empty()) break;
			cmd = _commandQueue.front();
			_commandQueue.pop();
		}
		std::string response = ExecuteCommand(*cmd);
		cmd->SetResponse(response);
	}
}
std::string McpServer::ExecuteCommand(McpTypedCommand& cmd)
{
	switch(cmd.type) {
		case McpCommandType::LoadRom: return ExecLoadRom(cmd);
		case McpCommandType::StepFrame: return ExecStepFrame(cmd);
		case McpCommandType::ReadMemory: return ExecReadMemory(cmd);
		case McpCommandType::WriteMemory: return ExecWriteMemory(cmd);
		case McpCommandType::SetInput: return ExecSetInput(cmd);
		case McpCommandType::GetState: return ExecGetState(cmd);
		default: return ErrorResponse(cmd.id, "unknown command type");
	}
}
static MemoryType GetCpuMemoryType(ConsoleType ct)
{
	switch(ct) {
		case ConsoleType::Nes: return MemoryType::NesMemory;
		case ConsoleType::Snes: return MemoryType::SnesMemory;
		case ConsoleType::Gameboy: return MemoryType::GameboyMemory;
		case ConsoleType::PcEngine: return MemoryType::PceMemory;
		case ConsoleType::Sms: return MemoryType::SmsMemory;
		case ConsoleType::Gba: return MemoryType::GbaMemory;
		default: return MemoryType::NesMemory;
	}
}
static CpuType GetMainCpuType(ConsoleType ct)
{
	switch(ct) {
		case ConsoleType::Nes: return CpuType::Nes;
		case ConsoleType::Snes: return CpuType::Snes;
		case ConsoleType::Gameboy: return CpuType::Gameboy;
		case ConsoleType::PcEngine: return CpuType::Pce;
		case ConsoleType::Gba: return CpuType::Gba;
		default: return CpuType::Nes;
	}
}
std::string McpServer::ExecLoadRom(McpTypedCommand& cmd)
{
	if(cmd.path.empty()) {
		return ErrorResponse(cmd.id, "missing path");
	}
	if(_emu->IsRunning()) {
		_emu->Stop(false, false, true);
	}
	bool loaded = _emu->LoadRom((VirtualFile)cmd.path, VirtualFile());
	if(!loaded) {
		_coreState.romLoaded = false;
		_coreState.consoleType = -1;
		_coreState.externalControl = false;
		return ErrorResponse(cmd.id, "failed to load ROM");
	}
	ConsoleType ct = _emu->GetConsoleType();
	_coreState.consoleType = (int)ct;
	_coreState.romLoaded = true;
	_coreState.externalControl = true;
	std::ostringstream result;
	result << "{\"console_type\":" << (int)ct
	       << ",\"path\":\"";
	for(char c : cmd.path) {
		if(c == '\\') result << "\\\\";
		else if(c == '"') result << "\\\"";
		else result << c;
	}
	result << "\",\"mode\":\"external_controlled\"}";
	MessageManager::Log("[MCP] ROM loaded: " + cmd.path + " (console=" + std::to_string((int)ct) + ")");
	return OkResponse(cmd.id, result.str());
}
std::string McpServer::ExecStepFrame(McpTypedCommand& cmd)
{
	if(!_coreState.romLoaded) return ErrorResponse(cmd.id, "no ROM loaded");
	int count = cmd.count;
	if(count < 1) count = 1;
	if(count > 3600) count = 3600;
	IConsole* console = _emu->GetConsoleUnsafe();
	if(!console) return ErrorResponse(cmd.id, "no active console");
	for(int i = 0; i < count; i++) {
		console->RunFrame();
	}
	uint32_t frameCount = _emu->GetFrameCount();
	std::ostringstream result;
	result << "{\"framesExecuted\":" << count << ",\"frameCount\":" << frameCount << "}";
	return OkResponse(cmd.id, result.str());
}
std::string McpServer::ExecReadMemory(McpTypedCommand& cmd)
{
	if(!_coreState.romLoaded) return ErrorResponse(cmd.id, "no ROM loaded");
	if(cmd.address < 0) return ErrorResponse(cmd.id, "invalid address");
	MemoryType memType = GetCpuMemoryType((ConsoleType)_coreState.consoleType);
	DebuggerRequest dbgRequest = _emu->GetDebugger(true);
	Debugger* dbg = dbgRequest.GetDebugger();
	if(!dbg) return ErrorResponse(cmd.id, "debugger not available");
	int size = cmd.count;
	if(size < 1) size = 1;
	if(size > 256) size = 256;
	if(size == 1) {
		uint8_t val = dbg->GetMemoryDumper()->GetMemoryValue(memType, (uint32_t)cmd.address);
		return OkResponse(cmd.id, "{\"value\":" + std::to_string(val) + "}");
	}
	std::vector<uint8_t> buf(size);
	dbg->GetMemoryDumper()->GetMemoryValues(memType, (uint32_t)cmd.address, (uint32_t)(cmd.address + size - 1), buf.data());
	std::ostringstream result;
	result << "{\"address\":" << cmd.address << ",\"size\":" << size << ",\"data\":[";
	for(int i = 0; i < size; i++) {
		if(i > 0) result << ",";
		result << (int)buf[i];
	}
	result << "]}";
	return OkResponse(cmd.id, result.str());
}
std::string McpServer::ExecWriteMemory(McpTypedCommand& cmd)
{
	if(!_coreState.romLoaded) return ErrorResponse(cmd.id, "no ROM loaded");
	if(cmd.address < 0) return ErrorResponse(cmd.id, "invalid address");
	if(cmd.value < 0 || cmd.value > 255) return ErrorResponse(cmd.id, "value must be 0-255");
	MemoryType memType = GetCpuMemoryType((ConsoleType)_coreState.consoleType);
	DebuggerRequest dbgRequest = _emu->GetDebugger(true);
	Debugger* dbg = dbgRequest.GetDebugger();
	if(!dbg) return ErrorResponse(cmd.id, "debugger not available");
	dbg->GetMemoryDumper()->SetMemoryValue(memType, (uint32_t)cmd.address, (uint8_t)cmd.value);
	return OkResponse(cmd.id, "{\"address\":" + std::to_string(cmd.address) +
	                          ",\"value\":" + std::to_string(cmd.value) + "}");
}
std::string McpServer::ExecSetInput(McpTypedCommand& cmd)
{
	if(!_coreState.romLoaded) return ErrorResponse(cmd.id, "no ROM loaded");
	IConsole* console = _emu->GetConsoleUnsafe();
	if(!console) return ErrorResponse(cmd.id, "no active console");
	BaseControlManager* ctrlMgr = console->GetControlManager();
	if(!ctrlMgr) return ErrorResponse(cmd.id, "no control manager");
	shared_ptr<BaseControlDevice> controller = ctrlMgr->GetControlDevice(cmd.port, 0);
	if(!controller) return ErrorResponse(cmd.id, "no controller on port " + std::to_string(cmd.port));
	ControlDeviceState state;
	state.State.push_back((uint8_t)(cmd.buttons & 0xFF));
	controller->SetRawState(state);
	return OkResponse(cmd.id, "{\"port\":" + std::to_string(cmd.port) +
	                          ",\"buttons\":" + std::to_string(cmd.buttons) + "}");
}
std::string McpServer::ExecGetState(McpTypedCommand& cmd)
{
	std::ostringstream result;
	result << "{\"rom_loaded\":" << (_coreState.romLoaded ? "true" : "false")
	       << ",\"console_type\":" << _coreState.consoleType
	       << ",\"mode\":\"" << (_coreState.externalControl ? "external_controlled" : "free_running") << "\"";
	if(_coreState.romLoaded) {
		result << ",\"frame_count\":" << _emu->GetFrameCount();
		DebuggerRequest dbgRequest = _emu->GetDebugger(true);
		Debugger* dbg = dbgRequest.GetDebugger();
		if(dbg) {
			CpuType cpuType = GetMainCpuType((ConsoleType)_coreState.consoleType);
			uint32_t pc = dbg->GetProgramCounter(cpuType, false);
			result << ",\"pc\":" << pc;
		}
	}
	result << "}";
	return OkResponse(cmd.id, result.str());
}
```

## File: Core/Shared/McpServer.h
```
#pragma once
#include "pch.h"
#include <thread>
#include <mutex>
#include <condition_variable>
#include <queue>
#include <atomic>
#include <string>
#include <vector>
class Emulator;
class Socket;
enum class McpCommandType {
	LoadRom,
	StepFrame,
	ReadMemory,
	WriteMemory,
	SetInput,
	GetState
};
struct McpTypedCommand {
	McpCommandType type;
	int id = 0;
	std::string path;
	int address = 0;
	int value = 0;
	int count = 1;
	int port = 0;
	int buttons = 0;
	std::string response;
	bool responseReady = false;
	std::mutex mutex;
	std::condition_variable cv;
	void SetResponse(const std::string& resp) {
		std::lock_guard<std::mutex> lock(mutex);
		response = resp;
		responseReady = true;
		cv.notify_one();
	}
	std::string WaitForResponse() {
		std::unique_lock<std::mutex> lock(mutex);
		bool ok = cv.wait_for(lock, std::chrono::seconds(30), [this] { return responseReady; });
		if(!ok) return "{\"ok\":false,\"error\":\"timeout\",\"id\":0}";
		return response;
	}
};
struct McpCoreState {
	int consoleType = -1;
	bool romLoaded = false;
	bool externalControl = false;
};
class McpServer {
private:
	Emulator* _emu;
	std::unique_ptr<std::thread> _listenThread;
	std::unique_ptr<Socket> _listener;
	std::atomic<bool> _stop;
	uint16_t _port;
	std::mutex _queueMutex;
	std::queue<std::shared_ptr<McpTypedCommand>> _commandQueue;
	McpCoreState _coreState;
	void ListenLoop();
	void HandleClient(std::unique_ptr<Socket> client);
	std::shared_ptr<McpTypedCommand> ParseCommand(const std::string& json);
	static std::string ExtractString(const std::string& json, const std::string& key);
	static int ExtractInt(const std::string& json, const std::string& key, int defaultVal = 0);
	std::string ExecuteCommand(McpTypedCommand& cmd);
	std::string ExecLoadRom(McpTypedCommand& cmd);
	std::string ExecStepFrame(McpTypedCommand& cmd);
	std::string ExecReadMemory(McpTypedCommand& cmd);
	std::string ExecWriteMemory(McpTypedCommand& cmd);
	std::string ExecSetInput(McpTypedCommand& cmd);
	std::string ExecGetState(McpTypedCommand& cmd);
	static std::string OkResponse(int id, const std::string& resultJson);
	static std::string ErrorResponse(int id, const std::string& error);
public:
	McpServer(Emulator* emu, uint16_t port = 12345);
	~McpServer();
	void Start();
	void Stop();
	void DrainCommandQueue();
	bool IsExternalControlled() const { return _coreState.externalControl; }
	McpCoreState& GetCoreState() { return _coreState; }
};
```

## File: Core/Shared/MemoryOperationType.h
```
#pragma once
enum class MemoryOperationType
{
	Read = 0,
	Write = 1,
	ExecOpCode = 2,
	ExecOperand = 3,
	DmaRead = 4,
	DmaWrite = 5,
	DummyRead = 6,
	DummyWrite = 7,
	PpuRenderingRead = 8,
	Idle = 9
};
enum class MemoryAccessFlags
{
	None = 0,
	DspAccess = 1,
};
```

## File: Core/Shared/MemoryType.h
```
#pragma once
enum class MemoryType
{
	SnesMemory,
	SpcMemory,
	Sa1Memory,
	NecDspMemory,
	GsuMemory,
	Cx4Memory,
	St018Memory,
	GameboyMemory,
	NesMemory,
	NesPpuMemory,
	PceMemory,
	SmsMemory,
	GbaMemory,
	WsMemory,
	SnesPrgRom,
	SnesWorkRam,
	SnesSaveRam,
	SnesVideoRam,
	SnesSpriteRam,
	SnesCgRam,
	SnesRegister,
	SpcRam,
	SpcRom,
	SpcDspRegisters,
	DspProgramRom,
	DspDataRom,
	DspDataRam,
	Sa1InternalRam,
	GsuWorkRam,
	Cx4DataRam,
	BsxPsRam,
	BsxMemoryPack,
	St018PrgRom,
	St018DataRom,
	St018WorkRam,
	SufamiTurboFirmware,
	SufamiTurboSecondCart,
	SufamiTurboSecondCartRam,
	GbPrgRom,
	GbWorkRam,
	GbCartRam,
	GbHighRam,
	GbBootRom,
	GbVideoRam,
	GbSpriteRam,
	NesPrgRom,
	NesInternalRam,
	NesWorkRam,
	NesSaveRam,
	NesNametableRam,
	NesMapperRam,
	NesSpriteRam,
	NesSecondarySpriteRam,
	NesPaletteRam,
	NesChrRam,
	NesChrRom,
	PcePrgRom,
	PceWorkRam,
	PceSaveRam,
	PceCdromRam,
	PceCardRam,
	PceAdpcmRam,
	PceArcadeCardRam,
	PceVideoRam,
	PceVideoRamVdc2,
	PceSpriteRam,
	PceSpriteRamVdc2,
	PcePaletteRam,
	SmsPrgRom,
	SmsWorkRam,
	SmsCartRam,
	SmsBootRom,
	SmsVideoRam,
	SmsPaletteRam,
	SmsPort,
	GbaPrgRom,
	GbaBootRom,
	GbaSaveRam,
	GbaIntWorkRam,
	GbaExtWorkRam,
	GbaVideoRam,
	GbaSpriteRam,
	GbaPaletteRam,
	WsPrgRom,
	WsWorkRam,
	WsCartRam,
	WsCartEeprom,
	WsBootRom,
	WsInternalEeprom,
	WsPort,
	None
};
```

## File: Core/Shared/Movies/MesenMovie.cpp
```cpp
#include "pch.h"
#include "Shared/Movies/MesenMovie.h"
#include "Shared/Movies/MovieTypes.h"
#include "Shared/Movies/MovieManager.h"
#include "Shared/MessageManager.h"
#include "Shared/BaseControlManager.h"
#include "Shared/BaseControlDevice.h"
#include "Shared/Emulator.h"
#include "Shared/EmuSettings.h"
#include "Shared/SaveStateManager.h"
#include "Shared/NotificationManager.h"
#include "Shared/BatteryManager.h"
#include "Shared/CheatManager.h"
#include "Utilities/ZipReader.h"
#include "Utilities/StringUtilities.h"
#include "Utilities/HexUtilities.h"
#include "Utilities/VirtualFile.h"
#include "Utilities/magic_enum.hpp"
#include "Utilities/Serializer.h"
MesenMovie::MesenMovie(Emulator* emu, bool forTest)
{
	_emu = emu;
	_forTest = forTest;
}
MesenMovie::~MesenMovie()
{
	_emu->UnregisterInputProvider(this);
}
void MesenMovie::Stop()
{
	if(_playing) {
		bool isEndOfMovie = _lastPollCounter >= _inputData.size();
		if(!_forTest) {
			MessageManager::DisplayMessage("Movies", isEndOfMovie ? "MovieEnded" : "MovieStopped");
		}
		EmuSettings* settings = _emu->GetSettings();
		if(isEndOfMovie && settings->GetPreferences().PauseOnMovieEnd) {
			_emu->PauseOnNextFrame();
		}
		_emu->GetCheatManager()->SetCheats(_originalCheats);
		Serializer backup(0, false);
		backup.LoadFrom(_emuSettingsBackup);
		backup.Stream(*settings, "", -1);
		_playing = false;
	}
	_emu->UnregisterInputProvider(this);
	_controlManager = nullptr;
}
bool MesenMovie::SetInput(BaseControlDevice *device)
{
	uint32_t inputRowIndex = _controlManager->GetPollCounter();
	if(_lastPollCounter != inputRowIndex) {
		_lastPollCounter = inputRowIndex;
		assert(_deviceIndex == 0);
		_deviceIndex = 0;
	}
	if(_inputData.size() > inputRowIndex && _inputData[inputRowIndex].size() > _deviceIndex) {
		device->SetTextState(_inputData[inputRowIndex][_deviceIndex]);
		_deviceIndex++;
		if(_deviceIndex >= _inputData[inputRowIndex].size()) {
			//Move to the next frame's data
			_deviceIndex = 0;
		}
	} else {
		//End of input data reached (movie end)
		_emu->GetMovieManager()->Stop();
	}
	return true;
}
bool MesenMovie::IsPlaying()
{
	return _playing;
}
vector<uint8_t> MesenMovie::LoadBattery(string extension)
{
	vector<uint8_t> batteryData;
	_reader->ExtractFile("Battery" + extension, batteryData);
	return batteryData;
}
void MesenMovie::ProcessNotification(ConsoleNotificationType type, void* parameter)
{
	if(type == ConsoleNotificationType::GameLoaded) {
		_emu->RegisterInputProvider(this);
		shared_ptr<IConsole> console = _emu->GetConsole();
		if(console) {
			console->GetControlManager()->SetPollCounter(_lastPollCounter);
		}
	}
}
bool MesenMovie::Play(VirtualFile &file)
{
	_movieFile = file;
	std::stringstream ss;
	file.ReadFile(ss);
	_reader.reset(new ZipReader());
	_reader->LoadArchive(ss);
	stringstream settingsData, inputData;
	if(!_reader->GetStream("GameSettings.txt", settingsData)) {
		MessageManager::Log("[Movie] File not found: GameSettings.txt");
		return false;
	}
	if(!_reader->GetStream("Input.txt", inputData)) {
		MessageManager::Log("[Movie] File not found: Input.txt");
		return false;
	}
	while(inputData) {
		string line;
		std::getline(inputData, line);
		if(line.substr(0, 1) == "|") {
			_inputData.push_back(StringUtilities::Split(line.substr(1), '|'));
		}
	}
	_deviceIndex = 0;
	ParseSettings(settingsData);
	string version = LoadString(_settings, MovieKeys::MesenVersion);
	if(version.size() < 2 || version.substr(0, 2) == "0." || version.substr(0, 2) == "1.") {
		MessageManager::DisplayMessage("Movies", "MovieIncompatibleVersion");
		return false;
	}
	if(LoadInt(_settings, MovieKeys::MovieFormatVersion, 0) < 2) {
		MessageManager::DisplayMessage("Movies", "MovieIncompatibleVersion");
		return false;
	}
	auto emuLock = _emu->AcquireLock(false);
	if(!ApplySettings(settingsData)) {
		return false;
	}
	_emu->GetBatteryManager()->SetBatteryProvider(shared_from_this());
	_emu->GetNotificationManager()->RegisterNotificationListener(shared_from_this());
	_emu->PowerCycle();
	ApplySettings(settingsData);
	_originalCheats = _emu->GetCheatManager()->GetCheats();
	_controlManager = _emu->GetConsole()->GetControlManager();
	LoadCheats();
	stringstream saveStateData;
	if(_reader->GetStream("SaveState.mss", saveStateData)) {
		if(!_emu->GetSaveStateManager()->LoadState(saveStateData)) {
			return false;
		}
	}
	_controlManager->UpdateControlDevices();
	_controlManager->SetPollCounter(0);
	_playing = true;
	return true;
}
template<typename T>
T FromString(string name, const vector<string> &enumNames, T defaultValue)
{
	for(size_t i = 0; i < enumNames.size(); i++) {
		if(name == enumNames[i]) {
			return (T)i;
		}
	}
	return defaultValue;
}
void MesenMovie::ParseSettings(stringstream &data)
{
	while(!data.eof()) {
		string line;
		std::getline(data, line);
		if(!line.empty()) {
			size_t index = line.find_first_of(' ');
			if(index != string::npos) {
				string name = line.substr(0, index);
				string value = line.substr(index + 1);
				if(name == "Cheat") {
					_cheats.push_back(value);
				} else {
					_settings[name] = value;
				}
			}
		}
	}
}
bool MesenMovie::ApplySettings(istream& settingsData)
{
	EmuSettings* settings = _emu->GetSettings();
	settingsData.clear();
	settingsData.seekg(0, std::ios::beg);
	Serializer s(0, false, SerializeFormat::Text);
	s.LoadFrom(settingsData);
	ConsoleType consoleType = {};
	s.Stream(consoleType, "emu.consoleType", -1);
	if(consoleType != _emu->GetConsoleType()) {
		MessageManager::DisplayMessage("Movies", "MovieIncorrectConsole", string(magic_enum::enum_name<ConsoleType>(consoleType)));
		return false;
	}
	Serializer backup(0, true);
	backup.Stream(*settings, "", -1);
	backup.SaveTo(_emuSettingsBackup);
	//Load settings
	s.Stream(*settings, "", -1);
	return true;
}
uint32_t MesenMovie::LoadInt(std::unordered_map<string, string> &settings, string name, uint32_t defaultValue)
{
	auto result = settings.find(name);
	if(result != settings.end()) {
		try {
			return (uint32_t)std::stoul(result->second);
		} catch(std::exception&) {
			MessageManager::Log("[Movies] Invalid value for tag: " + name);
			return defaultValue;
		}
	} else {
		return defaultValue;
	}
}
bool MesenMovie::LoadBool(std::unordered_map<string, string> &settings, string name)
{
	auto result = settings.find(name);
	if(result != settings.end()) {
		if(result->second == "true") {
			return true;
		} else if(result->second == "false") {
			return false;
		} else {
			MessageManager::Log("[Movies] Invalid value for tag: " + name);
			return false;
		}
	} else {
		return false;
	}
}
string MesenMovie::LoadString(std::unordered_map<string, string> &settings, string name)
{
	auto result = settings.find(name);
	if(result != settings.end()) {
		return result->second;
	} else {
		return "";
	}
}
void MesenMovie::LoadCheats()
{
	vector<CheatCode> cheats;
	for(string cheatData : _cheats) {
		CheatCode code;
		if(LoadCheat(cheatData, code)) {
			cheats.push_back(code);
		}
	}
	_emu->GetCheatManager()->SetCheats(cheats);
}
bool MesenMovie::LoadCheat(string cheatData, CheatCode &code)
{
	vector<string> data = StringUtilities::Split(cheatData, ' ');
	if(data.size() == 2) {
		auto cheatType = magic_enum::enum_cast<CheatType>(data[0]);
		if(cheatType.has_value() && data[1].size() <= 15) {
			code.Type = cheatType.value();
			memcpy(code.Code, data[1].c_str(), data[1].size() + 1);
			return true;
		}
	}
	MessageManager::Log("[Movie] Invalid cheat definition: " + cheatData);
	return false;
}
```

## File: Core/Shared/Movies/MesenMovie.h
```
#pragma once
#include "pch.h"
#include "Utilities/VirtualFile.h"
#include "Shared/BatteryManager.h"
#include "Shared/Interfaces/INotificationListener.h"
#include "Shared/Movies/MovieManager.h"
class ZipReader;
class Emulator;
class BaseControlManager;
struct CheatCode;
class MesenMovie final : public IMovie, public INotificationListener, public IBatteryProvider, public std::enable_shared_from_this<MesenMovie>
{
private:
	Emulator* _emu = nullptr;
	BaseControlManager* _controlManager = nullptr;
	VirtualFile _movieFile;
	unique_ptr<ZipReader> _reader;
	bool _playing = false;
	size_t _deviceIndex = 0;
	uint32_t _lastPollCounter = 0;
	vector<vector<string>> _inputData;
	vector<string> _cheats;
	vector<CheatCode> _originalCheats;
	stringstream _emuSettingsBackup;
	unordered_map<string, string> _settings;
	string _filename;
	bool _forTest = false;
private:
	void ParseSettings(stringstream &data);
	bool ApplySettings(istream& settingsData);
	uint32_t LoadInt(std::unordered_map<string, string> &settings, string name, uint32_t defaultValue = 0);
	bool LoadBool(std::unordered_map<string, string> &settings, string name);
	string LoadString(std::unordered_map<string, string> &settings, string name);
	void LoadCheats();
	bool LoadCheat(string cheatData, CheatCode &code);
public:
	MesenMovie(Emulator* emu, bool silent);
	virtual ~MesenMovie();
	bool Play(VirtualFile &file) override;
	void Stop() override;
	bool SetInput(BaseControlDevice* device) override;
	bool IsPlaying() override;
	vector<uint8_t> LoadBattery(string extension) override;
	void ProcessNotification(ConsoleNotificationType type, void * parameter) override;
};
```

## File: Core/Shared/Movies/MovieManager.cpp
```cpp
#include "pch.h"
#include <algorithm>
#include "Utilities/FolderUtilities.h"
#include "Utilities/VirtualFile.h"
#include "Utilities/ZipReader.h"
#include "Shared/Emulator.h"
#include "Shared/Movies/MovieManager.h"
#include "Shared/Movies/MesenMovie.h"
#include "Shared/Movies/MovieRecorder.h"
MovieManager::MovieManager(Emulator* emu)
{
	_emu = emu;
}
void MovieManager::Record(RecordMovieOptions options)
{
	Stop();
	shared_ptr<MovieRecorder> recorder(new MovieRecorder(_emu));
	if(recorder->Record(options)) {
		_recorder.reset(recorder);
	}
}
void MovieManager::Play(VirtualFile file, bool forTest)
{
	vector<uint8_t> fileData;
	if(file.IsValid() && file.ReadFile(fileData)) {
		shared_ptr<IMovie> player;
		if(memcmp(fileData.data(), "PK", 2) == 0) {
			ZipReader reader;
			reader.LoadArchive(fileData);
			vector<string> files = reader.GetFileList();
			if(std::find(files.begin(), files.end(), "GameSettings.txt") != files.end()) {
				player.reset(new MesenMovie(_emu, forTest));
			}
		}
		Stop();
		if(player && player->Play(file)) {
			_player.reset(player);
			if(!forTest) {
				MessageManager::DisplayMessage("Movies", "MoviePlaying", file.GetFileName());
			}
		}
	}
}
void MovieManager::Stop()
{
	shared_ptr<IMovie> player = _player.lock();
	if(player) {
		player->Stop();
	}
	_player.reset();
	_recorder.reset();
}
bool MovieManager::Playing()
{
	return _player != nullptr;
}
bool MovieManager::Recording()
{
	return _recorder != nullptr;
}
```

## File: Core/Shared/Movies/MovieManager.h
```
#pragma once
#include "pch.h"
#include "Shared/MessageManager.h"
#include "Shared/Interfaces/IInputProvider.h"
#include "Shared/Movies/MovieTypes.h"
#include "Shared/Movies/MovieRecorder.h"
#include "Utilities/safe_ptr.h"
class VirtualFile;
class Emulator;
class IMovie : public IInputProvider
{
public:
	virtual ~IMovie() = default;
	virtual bool Play(VirtualFile& file) = 0;
	virtual void Stop() = 0;
	virtual bool IsPlaying() = 0;
};
class MovieManager
{
private:
	Emulator* _emu = nullptr;
	safe_ptr<IMovie> _player;
	safe_ptr<MovieRecorder> _recorder;
public:
	MovieManager(Emulator* emu);
	void Record(RecordMovieOptions options);
	void Play(VirtualFile file, bool silent = false);
	void Stop();
	bool Playing();
	bool Recording();
};
```

## File: Core/Shared/Movies/MovieRecorder.cpp
```cpp
#include "pch.h"
#include <deque>
#include "Utilities/HexUtilities.h"
#include "Utilities/FolderUtilities.h"
#include "Utilities/ZipWriter.h"
#include "Utilities/VirtualFile.h"
#include "Shared/MessageManager.h"
#include "Shared/BaseControlManager.h"
#include "Shared/BaseControlDevice.h"
#include "Shared/Emulator.h"
#include "Shared/EmuSettings.h"
#include "Shared/SaveStateManager.h"
#include "Shared/RewindManager.h"
#include "Shared/NotificationManager.h"
#include "Shared/RewindData.h"
#include "Shared/Movies/MovieTypes.h"
#include "Shared/Movies/MovieRecorder.h"
#include "Shared/BatteryManager.h"
#include "Shared/CheatManager.h"
#include "Utilities/Serializer.h"
#include "Utilities/magic_enum.hpp"
MovieRecorder::MovieRecorder(Emulator* emu)
{
	_emu = emu;
}
MovieRecorder::~MovieRecorder()
{
	Stop();
}
bool MovieRecorder::Record(RecordMovieOptions options)
{
	_filename = options.Filename;
	_author = options.Author;
	_description = options.Description;
	_writer.reset(new ZipWriter());
	_inputData = stringstream();
	_saveStateData = stringstream();
	_hasSaveState = false;
	if(!_writer->Initialize(_filename)) {
		MessageManager::DisplayMessage("Movies", "CouldNotWriteToFile", FolderUtilities::GetFilename(_filename, true));
		_writer.reset();
		return false;
	} else {
		_emu->Lock();
		_emu->GetNotificationManager()->RegisterNotificationListener(shared_from_this());
		bool needSaveState = _emu->GetSettings()->HasRandomPowerOnState(_emu->GetConsoleType());
		if(options.RecordFrom == RecordMovieFrom::StartWithoutSaveData) {
			_emu->GetBatteryManager()->SetBatteryProvider(shared_from_this());
			_emu->PowerCycle();
		} else if(options.RecordFrom == RecordMovieFrom::StartWithSaveData) {
			_emu->GetBatteryManager()->SetBatteryRecorder(shared_from_this());
			_emu->PowerCycle();
		} else if(options.RecordFrom == RecordMovieFrom::CurrentState) {
			_emu->RegisterInputRecorder(this);
			needSaveState = true;
		}
		if(needSaveState) {
			_emu->GetSaveStateManager()->SaveState(_saveStateData);
			_hasSaveState = true;
		}
		_emu->GetBatteryManager()->SetBatteryRecorder(nullptr);
		_emu->Unlock();
		MessageManager::DisplayMessage("Movies", "MovieRecordingTo", FolderUtilities::GetFilename(_filename, true));
		return true;
	}
}
void MovieRecorder::GetGameSettings(stringstream &out)
{
	EmuSettings* settings = _emu->GetSettings();
	WriteString(out, MovieKeys::MesenVersion, settings->GetVersionString());
	WriteInt(out, MovieKeys::MovieFormatVersion, MovieRecorder::MovieFormatVersion);
	VirtualFile romFile = _emu->GetRomInfo().RomFile;
	WriteString(out, MovieKeys::GameFile, romFile.GetFileName());
	WriteString(out, MovieKeys::Sha1, _emu->GetHash(HashType::Sha1));
	VirtualFile patchFile = _emu->GetRomInfo().PatchFile;
	if(patchFile.IsValid()) {
		WriteString(out, MovieKeys::PatchFile, patchFile.GetFileName());
		WriteString(out, MovieKeys::PatchFileSha1, patchFile.GetSha1Hash());
		romFile.ApplyPatch(patchFile);
		WriteString(out, MovieKeys::PatchedRomSha1, romFile.GetSha1Hash());
	}
	Serializer s(0, true, SerializeFormat::Text);
	ConsoleType consoleType = _emu->GetConsoleType();
	s.Stream(consoleType, "emu.consoleType", -1);
	s.Stream(*settings, "", -1);
	std::stringstream settingsOut;
	s.SaveTo(settingsOut, 0);
	out << settingsOut.str();
	for(CheatCode &code : _emu->GetCheatManager()->GetCheats()) {
		out << "Cheat " << magic_enum::enum_name(code.Type) << " "  << string(code.Code) << "\n";
	}
}
void MovieRecorder::WriteString(stringstream &out, string name, string value)
{
	out << name << " " << value << "\n";
}
void MovieRecorder::WriteInt(stringstream &out, string name, uint32_t value)
{
	out << name << " " << std::to_string(value) << "\n";
}
void MovieRecorder::WriteBool(stringstream &out, string name, bool enabled)
{
	out << name << " " << (enabled ? "true" : "false") << "\n";
}
bool MovieRecorder::Stop()
{
	if(_writer) {
		_emu->UnregisterInputRecorder(this);
		_writer->AddFile(_inputData, "Input.txt");
		stringstream out;
		GetGameSettings(out);
		_writer->AddFile(out, "GameSettings.txt");
		if(!_author.empty() || !_description.empty()) {
			stringstream movieInfo;
			WriteString(movieInfo, "Author", _author);
			movieInfo << "Description\n" << _description;
			_writer->AddFile(movieInfo, "MovieInfo.txt");
		}
		VirtualFile patchFile = _emu->GetRomInfo().PatchFile;
		vector<uint8_t> patchData;
		if(patchFile.IsValid() && patchFile.ReadFile(patchData)) {
			_writer->AddFile(patchData, "PatchData.dat");
		}
		if(_hasSaveState) {
			_writer->AddFile(_saveStateData, "SaveState.mss");
		}
		for(auto kvp : _batteryData) {
			_writer->AddFile(kvp.second, "Battery" + kvp.first);
		}
		bool result = _writer->Save();
		if(result) {
			MessageManager::DisplayMessage("Movies", "MovieSaved", FolderUtilities::GetFilename(_filename, true));
		}
		return result;
	}
	return false;
}
void MovieRecorder::RecordInput(vector<shared_ptr<BaseControlDevice>> devices)
{
	for(shared_ptr<BaseControlDevice> &device : devices) {
		_inputData << ("|" + device->GetTextState());
	}
	_inputData << "\n";
}
void MovieRecorder::OnLoadBattery(string extension, vector<uint8_t> batteryData)
{
	_batteryData[extension] = batteryData;
}
vector<uint8_t> MovieRecorder::LoadBattery(string extension)
{
	return vector<uint8_t>();
}
void MovieRecorder::ProcessNotification(ConsoleNotificationType type, void *parameter)
{
	if(type == ConsoleNotificationType::GameLoaded) {
		_emu->RegisterInputRecorder(this);
	}
}
bool MovieRecorder::CreateMovie(string movieFile, deque<RewindData> &data, uint32_t startPosition, uint32_t endPosition, bool hasBattery)
{
	shared_ptr<IConsole> console = _emu->GetConsole();
	if(!console) {
		return false;
	}
	_filename = movieFile;
	_writer.reset(new ZipWriter());
	if(startPosition < data.size() && endPosition <= data.size() && _writer->Initialize(_filename)) {
		vector<shared_ptr<BaseControlDevice>> devices = console->GetControlManager()->GetControlDevices();
		if(startPosition > 0 || hasBattery || _emu->GetSettings()->HasRandomPowerOnState(_emu->GetConsoleType())) {
			_hasSaveState = true;
			_saveStateData = stringstream();
			_emu->GetSaveStateManager()->GetSaveStateHeader(_saveStateData);
			data[startPosition].GetStateData(_saveStateData, data, startPosition);
		}
		_inputData = stringstream();
		for(uint32_t i = startPosition; i < endPosition; i++) {
			RewindData rewindData = data[i];
			for(uint32_t j = 0; j < RewindManager::BufferSize; j++) {
				for(shared_ptr<BaseControlDevice> &device : devices) {
					uint8_t port = device->GetPort();
					if(j < rewindData.InputLogs[port].size()) {
						device->SetRawState(rewindData.InputLogs[port][j]);
						_inputData << ("|" + device->GetTextState());
					}
				}
				_inputData << "\n";
			}
		}
		return Stop();
	}
	return false;
}
```

## File: Core/Shared/Movies/MovieRecorder.h
```
#pragma once
#include "pch.h"
#include <deque>
#include <unordered_map>
#include "Shared/Interfaces/IInputRecorder.h"
#include "Shared/Interfaces/INotificationListener.h"
#include "Shared/BatteryManager.h"
#include "Shared/RewindData.h"
#include "Shared/Movies/MovieTypes.h"
class ZipWriter;
class Emulator;
class MovieRecorder final : public INotificationListener, public IInputRecorder, public IBatteryRecorder, public IBatteryProvider, public std::enable_shared_from_this<MovieRecorder>
{
private:
	static const uint32_t MovieFormatVersion = 2;
	Emulator* _emu;
	string _filename;
	string _author;
	string _description;
	unique_ptr<ZipWriter> _writer;
	std::unordered_map<string, vector<uint8_t>> _batteryData;
	stringstream _inputData;
	bool _hasSaveState = false;
	stringstream _saveStateData;
	void GetGameSettings(stringstream &out);
	void WriteString(stringstream &out, string name, string value);
	void WriteInt(stringstream &out, string name, uint32_t value);
	void WriteBool(stringstream &out, string name, bool enabled);
public:
	MovieRecorder(Emulator* emu);
	virtual ~MovieRecorder();
	bool Record(RecordMovieOptions options);
	bool Stop();
	void RecordInput(vector<shared_ptr<BaseControlDevice>> devices) override;
	void OnLoadBattery(string extension, vector<uint8_t> batteryData) override;
	vector<uint8_t> LoadBattery(string extension) override;
	void ProcessNotification(ConsoleNotificationType type, void *parameter) override;
	bool CreateMovie(string movieFile, deque<RewindData>& data, uint32_t startPosition, uint32_t endPosition, bool hasBattery);
};
```

## File: Core/Shared/Movies/MovieTypes.h
```
#pragma once
#include "pch.h"
enum class RecordMovieFrom
{
	StartWithoutSaveData = 0,
	StartWithSaveData,
	CurrentState
};
struct RecordMovieOptions
{
	char Filename[2000] = {};
	char Author[250] = {};
	char Description[10000] = {};
	RecordMovieFrom RecordFrom = RecordMovieFrom::StartWithoutSaveData;
};
namespace MovieKeys
{
	constexpr const char* MesenVersion = "MesenVersion";
	constexpr const char* MovieFormatVersion = "MovieFormatVersion";
	constexpr const char* GameFile = "GameFile";
	constexpr const char* Sha1 = "SHA1";
	constexpr const char* PatchFile = "PatchFile";
	constexpr const char* PatchFileSha1 = "PatchFileSHA1";
	constexpr const char* PatchedRomSha1 = "PatchedRomSHA1";
};
```

## File: Core/Shared/NotificationManager.cpp
```cpp
#include "pch.h"
#include <algorithm>
#include "Shared/NotificationManager.h"
void NotificationManager::RegisterNotificationListener(shared_ptr<INotificationListener> notificationListener)
{
	auto lock = _lock.AcquireSafe();
	for(weak_ptr<INotificationListener> listener : _listeners) {
		if(listener.lock() == notificationListener) {
			return;
		}
	}
	_listeners.push_back(notificationListener);
}
void NotificationManager::CleanupNotificationListeners()
{
	auto lock = _lock.AcquireSafe();
	_listeners.erase(
		std::remove_if(
			_listeners.begin(),
			_listeners.end(),
			[](weak_ptr<INotificationListener> ptr) { return ptr.expired(); }
		),
		_listeners.end()
	);
}
void NotificationManager::SendNotification(ConsoleNotificationType type, void* parameter)
{
	vector<weak_ptr<INotificationListener>> listeners;
	{
		auto lock = _lock.AcquireSafe();
		CleanupNotificationListeners();
		listeners = _listeners;
	}
	for(weak_ptr<INotificationListener> notificationListener : listeners) {
		shared_ptr<INotificationListener> listener = notificationListener.lock();
		if(listener) {
			listener->ProcessNotification(type, parameter);
		}
	}
}
```

## File: Core/Shared/NotificationManager.h
```
#pragma once
#include "pch.h"
#include "Shared/Interfaces/INotificationListener.h"
#include "Utilities/SimpleLock.h"
class NotificationManager
{
private:
	SimpleLock _lock;
	vector<weak_ptr<INotificationListener>> _listeners;
	void CleanupNotificationListeners();
public:
	void RegisterNotificationListener(shared_ptr<INotificationListener> notificationListener);
	void SendNotification(ConsoleNotificationType type, void* parameter = nullptr);
};
```

## File: Core/Shared/RecordedRomTest.h
```
#pragma once
#include "pch.h"
#include <deque>
#include "Core/Shared/Interfaces/INotificationListener.h"
#include "Utilities/AutoResetEvent.h"
class VirtualFile;
class Emulator;
enum class RomTestState
{
	Failed,
	Passed,
	PassedWithWarnings
};
struct RomTestResult
{
	RomTestState State;
	int32_t ErrorCode;
};
class RecordedRomTest : public INotificationListener, public std::enable_shared_from_this<RecordedRomTest>
{
private:
	Emulator* _emu;
	bool _inBackground = false;
	bool _recording = false;
	bool _runningTest = false;
	int _badFrameCount = 0;
	bool _isLastFrameGood = false;
	uint8_t _previousHash[16] = {};
	std::deque<uint8_t*> _screenshotHashes;
	std::deque<uint8_t> _repetitionCount;
	uint8_t _currentCount = 0;
	string _filename;
	ofstream _file;
	AutoResetEvent _signal;
private:
	void Reset();
	void ValidateFrame();
	void SaveFrame();
	void Save();
public:
	RecordedRomTest(Emulator* console, bool inBackground);
	virtual ~RecordedRomTest();
	void ProcessNotification(ConsoleNotificationType type, void* parameter) override;
	void Record(string filename, bool reset);
	RomTestResult Run(string filename);
	void Stop();
};
```

## File: Core/Shared/RenderedFrame.h
```
#pragma once
#include "pch.h"
#include "Shared/SettingTypes.h"
#include "Shared/ControlDeviceState.h"
struct RenderedFrame
{
	void* FrameBuffer = nullptr;
	void* Data = nullptr;
	uint32_t Width = 256;
	uint32_t Height = 240;
	double Scale = 1.0;
	uint32_t FrameNumber = 0;
	uint32_t VideoPhase = 0;
	vector<ControllerData> InputData;
	RenderedFrame()
	{}
	RenderedFrame(void* buffer, uint32_t width, uint32_t height, double scale = 1.0, uint32_t frameNumber = 0) :
		FrameBuffer(buffer),
		Data(nullptr),
		Width(width),
		Height(height),
		Scale(scale),
		FrameNumber(frameNumber),
		InputData({})
	{}
	RenderedFrame(void* buffer, uint32_t width, uint32_t height, double scale, uint32_t frameNumber, vector<ControllerData> inputData, uint32_t videoPhase = 0) :
		FrameBuffer(buffer),
		Data(nullptr),
		Width(width),
		Height(height),
		Scale(scale),
		FrameNumber(frameNumber),
		VideoPhase(videoPhase),
		InputData(inputData)
	{}
};
```

## File: Core/Shared/RewindData.cpp
```cpp
#include "pch.h"
#include "Shared/RewindData.h"
#include "Shared/Emulator.h"
#include "Shared/SaveStateManager.h"
#include "Utilities/CompressionHelper.h"
void RewindData::GetStateData(stringstream &stateData, deque<RewindData>& prevStates, int32_t position)
{
	vector<uint8_t> data;
	CompressionHelper::Decompress(_saveStateData, data);
	if(!IsFullState) {
		position = (position > 0 ? position : (int32_t)prevStates.size()) - 1;
		ProcessXorState(data, prevStates, position);
	}
	stateData.write((char*)data.data(), data.size());
}
template<typename T>
void RewindData::ProcessXorState(T& data, deque<RewindData>& prevStates, int32_t position)
{
	while(position >= 0 && position < prevStates.size()) {
		RewindData& prevState = prevStates[position];
		if(prevState.IsFullState) {
			if(!prevState._uncompressedData.empty()) {
				for(size_t i = 0, len = std::min(prevState._uncompressedData.size(), data.size()); i < len; i++) {
					data[i] ^= prevState._uncompressedData[i];
				}
			} else {
				vector<uint8_t> prevStateData;
				CompressionHelper::Decompress(prevState._saveStateData, prevStateData);
				for(size_t i = 0, len = std::min(prevStateData.size(), data.size()); i < len; i++) {
					data[i] ^= prevStateData[i];
				}
			}
			break;
		}
		position--;
	}
}
void RewindData::LoadState(Emulator* emu, deque<RewindData>& prevStates, int32_t position, bool sendNotification)
{
	if(_saveStateData.size() == 0) {
		return;
	}
	vector<uint8_t> data;
	CompressionHelper::Decompress(_saveStateData, data);
	if(!IsFullState) {
		position = (position > 0 ? position : (int32_t)prevStates.size()) - 1;
		ProcessXorState(data, prevStates, position);
	}
	stringstream stream;
	stream.write((char*)data.data(), data.size());
	stream.seekg(0, ios::beg);
	emu->Deserialize(stream, SaveStateManager::FileFormatVersion, true, std::nullopt, sendNotification);
}
void RewindData::SaveState(Emulator* emu, deque<RewindData>& prevStates, int32_t position)
{
	std::stringstream state;
	emu->Serialize(state, true, 0);
	string data = state.str();
	position = position > 0 ? position : (int32_t)prevStates.size();
	if(position > 0 && (position % 30) != 0) {
		position--;
		ProcessXorState(data, prevStates, position);
	} else {
		IsFullState = true;
		while(position > 0) {
			position--;
			RewindData& prevState = prevStates[position];
			if(prevState.IsFullState) {
				prevState._uncompressedData = {};
				break;
			}
		}
		_uncompressedData = vector<uint8_t>(data.begin(), data.end());
	}
	CompressionHelper::Compress(data, 1, _saveStateData);
	FrameCount = 0;
}
```

## File: Core/Shared/RewindData.h
```
#pragma once
#include "pch.h"
#include <deque>
#include "Shared/BaseControlDevice.h"
class Emulator;
class RewindData
{
private:
	vector<uint8_t> _saveStateData;
	vector<uint8_t> _uncompressedData;
	template<typename T>
	void ProcessXorState(T& data, deque<RewindData>& prevStates, int32_t position);
public:
	std::deque<ControlDeviceState> InputLogs[BaseControlDevice::PortCount];
	int32_t FrameCount = 0;
	bool EndOfSegment = false;
	bool IsFullState = false;
	void GetStateData(stringstream& stateData, deque<RewindData>& prevStates, int32_t position);
	uint32_t GetStateSize() { return (uint32_t)_saveStateData.size(); }
	void LoadState(Emulator* emu, deque<RewindData>& prevStates, int32_t position = -1, bool sendNotification = true);
	void SaveState(Emulator* emu, deque<RewindData>& prevStates, int32_t position = -1);
};
```

## File: Core/Shared/RewindManager.cpp
```cpp
#include "pch.h"
#include "Shared/RewindManager.h"
#include "Shared/MessageManager.h"
#include "Shared/Emulator.h"
#include "Shared/EmuSettings.h"
#include "Shared/Video/VideoRenderer.h"
#include "Shared/Audio/SoundMixer.h"
#include "Shared/BaseControlDevice.h"
#include "Shared/RenderedFrame.h"
#include "Shared/BaseControlManager.h"
RewindManager::RewindManager(Emulator* emu)
{
	_emu = emu;
	_settings = emu->GetSettings();
}
RewindManager::~RewindManager()
{
	_settings->ClearFlag(EmulationFlags::MaximumSpeed);
	_settings->ClearFlag(EmulationFlags::Rewind);
	_emu->UnregisterInputProvider(this);
	_emu->UnregisterInputRecorder(this);
}
void RewindManager::InitHistory()
{
	Reset();
	_emu->RegisterInputProvider(this);
	_emu->RegisterInputRecorder(this);
	AddHistoryBlock();
}
void RewindManager::Reset()
{
	_emu->UnregisterInputProvider(this);
	_emu->UnregisterInputRecorder(this);
	_settings->ClearFlag(EmulationFlags::MaximumSpeed);
	_settings->ClearFlag(EmulationFlags::Rewind);
	ClearBuffer();
}
void RewindManager::ClearBuffer()
{
	_hasHistory = false;
	_history.clear();
	_historyBackup.clear();
	_framesToFastForward = 0;
	_videoHistory.clear();
	_videoHistoryBuilder.clear();
	_audioHistory.clear();
	_audioHistoryBuilder.clear();
	_rewindState = RewindState::Stopped;
	_currentHistory = {};
}
void RewindManager::ProcessNotification(ConsoleNotificationType type, void * parameter)
{
	if(_emu->IsRunAheadFrame()) {
		return;
	}
	if(type == ConsoleNotificationType::PpuFrameDone) {
		_hasHistory = _history.size() >= 2;
		if(_settings->GetPreferences().RewindBufferSize > 0) {
			switch(_rewindState) {
				case RewindState::Starting:
				case RewindState::Started:
				case RewindState::Debugging:
					_currentHistory.FrameCount--;
					break;
				case RewindState::Stopping:
					_framesToFastForward--;
					_currentHistory.FrameCount++;
					if(_framesToFastForward == 0) {
						for(int i = 0; i < BaseControlDevice::PortCount; i++) {
							size_t numberToRemove = _currentHistory.InputLogs[i].size();
							_currentHistory.InputLogs[i] = _historyBackup.front().InputLogs[i];
							for(size_t j = 0; j < numberToRemove; j++) {
								_currentHistory.InputLogs[i].pop_back();
							}
						}
						_historyBackup.clear();
						_rewindState = RewindState::Stopped;
						_settings->ClearFlag(EmulationFlags::Rewind);
						_settings->ClearFlag(EmulationFlags::MaximumSpeed);
					}
					break;
				case RewindState::Stopped:
					_currentHistory.FrameCount++;
					break;
			}
		} else {
			ClearBuffer();
		}
	} else if(type == ConsoleNotificationType::StateLoaded) {
		if(_rewindState == RewindState::Stopped) {
			_currentHistory.EndOfSegment = true;
			AddHistoryBlock();
		}
	}
}
RewindStats RewindManager::GetStats()
{
	uint32_t memoryUsage = 0;
	for(int i = (int)_history.size() - 1; i >= 0; i--) {
		memoryUsage += _history[i].GetStateSize();
	}
	RewindStats stats = {};
	stats.MemoryUsage = memoryUsage;
	stats.HistorySize = (uint32_t)_history.size();
	stats.HistoryDuration = stats.HistorySize * RewindManager::BufferSize;
	return stats;
}
void RewindManager::AddHistoryBlock()
{
	uint32_t maxHistorySize = _settings->GetPreferences().RewindBufferSize;
	if(maxHistorySize > 0) {
		uint32_t memoryUsage = 0;
		for(int i = (int)_history.size() - 1; i >= 0; i--) {
			memoryUsage += _history[i].GetStateSize();
			if((memoryUsage >> 20) >= maxHistorySize) {
				for(int j = 0; j < i; j++) {
					_history.pop_front();
				}
				while(_history.size() > 0 && !_history.front().IsFullState) {
					_history.pop_front();
				}
				break;
			}
		}
		if(_currentHistory.FrameCount > 0) {
			_history.push_back(_currentHistory);
		}
		_currentHistory = RewindData();
		_currentHistory.SaveState(_emu, _history);
	}
}
void RewindManager::PopHistory()
{
	if(_history.empty() && _currentHistory.FrameCount <= 0 && !IsStepBack()) {
		StopRewinding();
	} else {
		if(_currentHistory.FrameCount <= 0 && !IsStepBack()) {
			_currentHistory = _history.back();
			_history.pop_back();
		}
		if(IsStepBack() && _currentHistory.FrameCount <= 1 && !_history.empty() && !_history.back().EndOfSegment) {
			_historyBackup.push_front(_currentHistory);
			_currentHistory = _history.back();
			_history.pop_back();
		}
		_historyBackup.push_front(_currentHistory);
		_currentHistory.LoadState(_emu, _history, -1, false);
		if(!_audioHistoryBuilder.empty()) {
			_audioHistory.insert(_audioHistory.begin(), _audioHistoryBuilder.begin(), _audioHistoryBuilder.end());
			_audioHistoryBuilder.clear();
		}
	}
}
void RewindManager::Start(bool forDebugger)
{
	if(_rewindState == RewindState::Stopped && _settings->GetPreferences().RewindBufferSize > 0) {
		if(forDebugger) {
			InternalStart(forDebugger);
		} else {
			auto lock = _emu->AcquireLock();
			InternalStart(forDebugger);
		}
	}
}
void RewindManager::InternalStart(bool forDebugger)
{
	if(_history.empty() && _currentHistory.FrameCount <= 0 && !forDebugger) {
		return;
	}
	_rewindState = forDebugger ? RewindState::Debugging : RewindState::Starting;
	_videoHistoryBuilder.clear();
	_videoHistory.clear();
	_audioHistoryBuilder.clear();
	_audioHistory.clear();
	_historyBackup.clear();
	PopHistory();
	_emu->GetSoundMixer()->StopAudio(true);
	_settings->SetFlag(EmulationFlags::MaximumSpeed);
	_settings->SetFlag(EmulationFlags::Rewind);
}
void RewindManager::ForceStop(bool deleteFutureData)
{
	if(_rewindState != RewindState::Stopped) {
		if(deleteFutureData) {
			RewindData orgHistory = _currentHistory;
			int framesToRemove = _currentHistory.FrameCount;
			if(!_historyBackup.empty()) {
				_currentHistory = _historyBackup.front();
				_currentHistory.FrameCount -= framesToRemove;
				for(int i = 0; i < BaseControlDevice::PortCount; i++) {
					for(int j = 0; j < orgHistory.InputLogs[i].size(); j++) {
						if(!_currentHistory.InputLogs[i].empty()) {
							_currentHistory.InputLogs[i].pop_back();
						}
					}
				}
			}
			_historyBackup.clear();
			if(!_videoHistory.empty()) {
				VideoFrame& frameData = _videoHistory.back();
				RenderedFrame oldFrame(frameData.Data.data(), frameData.Width, frameData.Height, frameData.Scale, frameData.FrameNumber, frameData.InputData);
				_emu->GetVideoRenderer()->UpdateFrame(oldFrame);
			}
		} else {
			while(_historyBackup.size() > 1) {
				_history.push_back(_historyBackup.front());
				_historyBackup.pop_front();
			}
			_currentHistory = _historyBackup.front();
			_historyBackup.clear();
		}
		_rewindState = RewindState::Stopped;
		_settings->ClearFlag(EmulationFlags::MaximumSpeed);
		_settings->ClearFlag(EmulationFlags::Rewind);
	}
}
void RewindManager::Stop()
{
	if(_rewindState >= RewindState::Starting) {
		auto lock = _emu->AcquireLock();
		if(_rewindState == RewindState::Started) {
			if(_historyBackup.size() > 1) {
				_framesToFastForward = (uint32_t)_videoHistory.size() + _historyBackup.front().FrameCount;
				do {
					_history.push_back(_historyBackup.front());
					_framesToFastForward -= _historyBackup.front().FrameCount;
					_historyBackup.pop_front();
					_currentHistory = _historyBackup.front();
				}
				while(_framesToFastForward > RewindManager::BufferSize && _historyBackup.size() > 1);
			}
		} else {
			while(_historyBackup.size() > 1) {
				_history.push_back(_historyBackup.front());
				_historyBackup.pop_front();
			}
			_currentHistory = _historyBackup.front();
			_framesToFastForward = _historyBackup.front().FrameCount;
		}
		_currentHistory.LoadState(_emu, _history);
		if(_framesToFastForward > 0) {
			_rewindState = RewindState::Stopping;
			_currentHistory.FrameCount = 0;
			_settings->SetFlag(EmulationFlags::MaximumSpeed);
		} else {
			_rewindState = RewindState::Stopped;
			_historyBackup.clear();
			_settings->ClearFlag(EmulationFlags::MaximumSpeed);
			_settings->ClearFlag(EmulationFlags::Rewind);
		}
		_videoHistoryBuilder.clear();
		_videoHistory.clear();
		_audioHistoryBuilder.clear();
		_audioHistory.clear();
	}
}
void RewindManager::ProcessEndOfFrame()
{
	if(_rewindState >= RewindState::Starting) {
		if(_currentHistory.FrameCount <= 0 && _rewindState != RewindState::Debugging) {
			PopHistory();
		} else if(_currentHistory.FrameCount == 0 && _rewindState == RewindState::Debugging) {
			if(_historyBackup.size() > 1) {
				_history.push_back(_historyBackup.front());
				_historyBackup.pop_front();
				_currentHistory = _historyBackup.front();
			}
		}
	} else if(_currentHistory.FrameCount >= RewindManager::BufferSize) {
		AddHistoryBlock();
	}
}
void RewindManager::ProcessFrame(RenderedFrame& frame, bool forRewind)
{
	if(_rewindState == RewindState::Starting || _rewindState == RewindState::Started) {
		if(!forRewind) {
			return;
		}
		VideoFrame newFrame;
		newFrame.Data = vector<uint32_t>((uint32_t*)frame.FrameBuffer, (uint32_t*)frame.FrameBuffer + frame.Width * frame.Height);
		newFrame.Width = frame.Width;
		newFrame.Height = frame.Height;
		newFrame.Scale = frame.Scale;
		newFrame.FrameNumber = frame.FrameNumber;
		newFrame.InputData = frame.InputData;
		_videoHistoryBuilder.push_back(newFrame);
		if(_videoHistoryBuilder.size() == (size_t)_historyBackup.front().FrameCount) {
			for(int i = (int)_videoHistoryBuilder.size() - 1; i >= 0; i--) {
				_videoHistory.push_front(_videoHistoryBuilder[i]);
			}
			_videoHistoryBuilder.clear();
		}
		if(_rewindState == RewindState::Started || _videoHistory.size() >= RewindManager::BufferSize) {
			_rewindState = RewindState::Started;
			_settings->ClearFlag(EmulationFlags::MaximumSpeed);
			if(!_videoHistory.empty()) {
				VideoFrame &frameData = _videoHistory.back();
				RenderedFrame oldFrame(frameData.Data.data(), frameData.Width, frameData.Height, frameData.Scale, frameData.FrameNumber, frameData.InputData);
				_emu->GetVideoRenderer()->UpdateFrame(oldFrame);
				_videoHistory.pop_back();
			}
		}
	} else if(_rewindState == RewindState::Stopping) {
	} else if(_rewindState == RewindState::Debugging) {
		VideoFrame newFrame;
		newFrame.Data = vector<uint32_t>((uint32_t*)frame.FrameBuffer, (uint32_t*)frame.FrameBuffer + frame.Width * frame.Height);
		newFrame.Width = frame.Width;
		newFrame.Height = frame.Height;
		newFrame.Scale = frame.Scale;
		newFrame.FrameNumber = frame.FrameNumber;
		newFrame.InputData = frame.InputData;
		_videoHistory.clear();
		_videoHistory.push_back(newFrame);
	} else {
		_emu->GetVideoRenderer()->UpdateFrame(frame);
	}
}
bool RewindManager::ProcessAudio(int16_t * soundBuffer, uint32_t sampleCount)
{
	if(_rewindState == RewindState::Starting || _rewindState == RewindState::Started) {
		_audioHistoryBuilder.insert(_audioHistoryBuilder.end(), soundBuffer, soundBuffer + sampleCount * 2);
		if(_rewindState == RewindState::Started && _audioHistory.size() > sampleCount * 2) {
			for(uint32_t i = 0; i < sampleCount * 2; i++) {
				soundBuffer[i] = _audioHistory.back();
				_audioHistory.pop_back();
			}
			return true;
		} else {
			return false;
		}
	} else if(_rewindState == RewindState::Stopping || _rewindState == RewindState::Debugging) {
		return false;
	} else {
		return true;
	}
}
void RewindManager::RecordInput(vector<shared_ptr<BaseControlDevice>> devices)
{
	if(_settings->GetPreferences().RewindBufferSize > 0 && _rewindState == RewindState::Stopped) {
		for(shared_ptr<BaseControlDevice> &device : devices) {
			_currentHistory.InputLogs[device->GetPort()].push_back(device->GetRawState());
		}
	}
}
bool RewindManager::SetInput(BaseControlDevice *device)
{
	uint8_t port = device->GetPort();
	if(IsRewinding()) {
		if(!_currentHistory.InputLogs[port].empty()) {
			ControlDeviceState state = _currentHistory.InputLogs[port].front();
			_currentHistory.InputLogs[port].pop_front();
			device->SetRawState(state);
			return true;
		} else {
			return false;
		}
	} else {
		return false;
	}
}
void RewindManager::StartRewinding(bool forDebugger)
{
	Start(forDebugger);
}
void RewindManager::StopRewinding(bool forDebugger, bool deleteFutureData)
{
	if(forDebugger) {
		ForceStop(deleteFutureData);
	} else {
		Stop();
	}
}
bool RewindManager::IsRewinding()
{
	return _rewindState != RewindState::Stopped;
}
bool RewindManager::IsStepBack()
{
	return _rewindState == RewindState::Debugging;
}
void RewindManager::RewindSeconds(uint32_t seconds)
{
	if(_rewindState == RewindState::Stopped) {
		uint32_t removeCount = (seconds * 60 / RewindManager::BufferSize) + 1;
		auto lock = _emu->AcquireLock();
		for(uint32_t i = 0; i < removeCount; i++) {
			if(!_history.empty()) {
				_currentHistory = _history.back();
				_history.pop_back();
			} else {
				break;
			}
		}
		_currentHistory.LoadState(_emu, _history);
	}
}
bool RewindManager::HasHistory()
{
	return _hasHistory;
}
deque<RewindData> RewindManager::GetHistory()
{
	deque<RewindData> history = _history;
	history.push_back(_currentHistory);
	return history;
}
void RewindManager::SendFrame(RenderedFrame& frame, bool forRewind)
{
	ProcessFrame(frame, forRewind);
}
bool RewindManager::SendAudio(int16_t* soundBuffer, uint32_t sampleCount)
{
	return ProcessAudio(soundBuffer, sampleCount);
}
```

## File: Core/Shared/RewindManager.h
```
#pragma once
#include "pch.h"
#include <deque>
#include "Shared/Interfaces/INotificationListener.h"
#include "Shared/RewindData.h"
#include "Shared/Interfaces/IInputProvider.h"
#include "Shared/Interfaces/IInputRecorder.h"
class Emulator;
class EmuSettings;
struct RenderedFrame;
enum class RewindState
{
	Stopped = 0,
	Stopping = 1,
	Starting = 2,
	Started = 3,
	Debugging = 4
};
struct VideoFrame
{
	vector<uint32_t> Data;
	uint32_t Width = 0;
	uint32_t Height = 0;
	double Scale = 0;
	uint32_t FrameNumber = 0;
	vector<ControllerData> InputData;
};
struct RewindStats
{
	uint32_t MemoryUsage;
	uint32_t HistorySize;
	uint32_t HistoryDuration;
};
class RewindManager : public INotificationListener, public IInputProvider, public IInputRecorder
{
public:
	static constexpr int32_t BufferSize = 30;
private:
	Emulator* _emu = nullptr;
	EmuSettings* _settings = nullptr;
	bool _hasHistory = false;
	deque<RewindData> _history;
	deque<RewindData> _historyBackup;
	RewindData _currentHistory = {};
	RewindState _rewindState = RewindState::Stopped;
	int32_t _framesToFastForward = 0;
	deque<VideoFrame> _videoHistory;
	vector<VideoFrame> _videoHistoryBuilder;
	deque<int16_t> _audioHistory;
	vector<int16_t> _audioHistoryBuilder;
	void AddHistoryBlock();
	void PopHistory();
	void Start(bool forDebugger);
	void InternalStart(bool forDebugger);
	void Stop();
	void ForceStop(bool deleteFutureData);
	void ProcessFrame(RenderedFrame& frame, bool forRewind);
	bool ProcessAudio(int16_t* soundBuffer, uint32_t sampleCount);
	void ClearBuffer();
public:
	RewindManager(Emulator* emu);
	virtual ~RewindManager();
	void InitHistory();
	void Reset();
	void ProcessNotification(ConsoleNotificationType type, void* parameter) override;
	void ProcessEndOfFrame();
	void RecordInput(vector<shared_ptr<BaseControlDevice>> devices) override;
	bool SetInput(BaseControlDevice *device) override;
	void StartRewinding(bool forDebugger = false);
	void StopRewinding(bool forDebugger = false, bool deleteFutureData = false);
	bool IsRewinding();
	bool IsStepBack();
	void RewindSeconds(uint32_t seconds);
	bool HasHistory();
	deque<RewindData> GetHistory();
	RewindStats GetStats();
	void SendFrame(RenderedFrame& frame, bool forRewind);
	bool SendAudio(int16_t *soundBuffer, uint32_t sampleCount);
};
```

## File: Core/Shared/RomFinder.h
```
#pragma once
#include "pch.h"
#include "Shared/Emulator.h"
#include "Shared/MessageManager.h"
#include "Utilities/VirtualFile.h"
#include "Utilities/FolderUtilities.h"
#include "Utilities/HexUtilities.h"
class RomFinder
{
private:
	static string FindMatchingRom(Emulator* emu, string romName, uint32_t crc32)
	{
		if(emu->IsRunning() && emu->GetCrc32() == crc32) {
			return emu->GetRomInfo().RomFile;
		}
		string lcRomname = romName;
		std::transform(lcRomname.begin(), lcRomname.end(), lcRomname.begin(), ::tolower);
		vector<string> romFiles;
		vector<string> folders = FolderUtilities::GetKnownGameFolders();
		if(emu->IsRunning()) {
			folders.insert(folders.begin(), emu->GetRomInfo().RomFile.GetFolderPath());
		}
		unordered_set<string> checkedFolders;
		for(string folder : folders) {
			if(!checkedFolders.emplace(folder).second) {
				continue;
			}
			for(string romFilename : FolderUtilities::GetFilesInFolder(folder, VirtualFile::RomExtensions, true)) {
				string lcRomFile = romFilename;
				std::transform(lcRomFile.begin(), lcRomFile.end(), lcRomFile.begin(), ::tolower);
				if(FolderUtilities::GetFilename(lcRomname, false) == FolderUtilities::GetFilename(lcRomFile, false) && VirtualFile(romFilename).GetCrc32() == crc32) {
					return romFilename;
				}
			}
		}
		MessageManager::Log("Could not find matching file: " + romName + "  CRC32: " + HexUtilities::ToHex(crc32, true));
		return "";
	}
public:
	static bool LoadMatchingRom(Emulator* emu, string romName, uint32_t crc32)
	{
		if(emu->IsRunning() && emu->GetCrc32() == crc32) {
			//Current game matches
			return true;
		}
		string match = FindMatchingRom(emu, romName, crc32);
		if(!match.empty()) {
			return emu->LoadRom(match, VirtualFile(""));
		}
		return false;
	}
};
```

## File: Core/Shared/RomInfo.h
```
#pragma once
#include "pch.h"
#include "Utilities/VirtualFile.h"
enum class RomFormat
{
	Unknown,
	Sfc,
	Spc,
	Gb,
	Gbs,
	iNes,
	Unif,
	Fds,
	VsSystem,
	VsDualSystem,
	Nsf,
	StudyBox,
	Pce,
	PceCdRom,
	PceHes,
	Sms,
	GameGear,
	Sg,
	ColecoVision,
	Gba,
	Ws,
};
struct DipSwitchInfo
{
	uint32_t DatabaseId = 0;
	uint32_t DipSwitchCount = 0;
};
struct RomInfo
{
	VirtualFile RomFile;
	VirtualFile PatchFile;
	RomFormat Format = RomFormat::Unknown;
	DipSwitchInfo DipSwitches = {};
};
```

## File: Core/Shared/SaveStateCompatInfo.h
```
#pragma once
#include "pch.h"
struct SaveStateCompatInfo
{
	bool IsCompatible;
	string PrefixToAdd;
	string PrefixToRemove;
	vector<string> FieldsToRemove;
};
```

## File: Core/Shared/SaveStateManager.h
```
#pragma once
#include "pch.h"
class Emulator;
struct RenderedFrame;
class SaveStateManager
{
private:
	static constexpr uint32_t MaxIndex = 10;
	atomic<uint32_t> _lastIndex;
	Emulator* _emu;
	string GetStateFilepath(int stateIndex);
	void SaveVideoData(ostream& stream);
	bool GetVideoData(vector<uint8_t>& out, RenderedFrame& frame, istream& stream);
	void WriteValue(ostream& stream, uint32_t value);
	uint32_t ReadValue(istream& stream);
public:
	static constexpr uint32_t FileFormatVersion = 4;
	static constexpr uint32_t MinimumSupportedVersion = 3;
	static constexpr uint32_t AutoSaveStateIndex = 11;
	SaveStateManager(Emulator* emu);
	void SaveState();
	bool LoadState();
	void GetSaveStateHeader(ostream & stream);
	void SaveState(ostream &stream);
	bool SaveState(string filepath, bool showSuccessMessage = true);
	void SaveState(int stateIndex, bool displayMessage = true);
	bool LoadState(istream &stream);
	bool LoadState(string filepath, bool showSuccessMessage = true);
	bool LoadState(int stateIndex);
	void SaveRecentGame(string romName, string romPath, string patchPath);
	void LoadRecentGame(string filename, bool resetGame);
	int32_t GetSaveStatePreview(string saveStatePath, uint8_t* pngData);
	void SelectSaveSlot(int slotIndex);
	void MoveToNextSlot();
	void MoveToPreviousSlot();
};
```

## File: Core/Shared/ShortcutKeyHandler.cpp
```cpp
#include "pch.h"
#include "Shared/ShortcutKeyHandler.h"
#include "Shared/SystemActionManager.h"
#include "Shared/EmuSettings.h"
#include "Shared/KeyManager.h"
#include "Shared/Video/VideoDecoder.h"
#include "Shared/Emulator.h"
#include "Shared/RewindManager.h"
#include "Shared/NotificationManager.h"
#include "Shared/SaveStateManager.h"
#include "Shared/Movies/MovieManager.h"
#include "Shared/BaseControlManager.h"
#include "Shared/Interfaces/IBarcodeReader.h"
#include "Shared/Interfaces/ITapeRecorder.h"
#include "Netplay/GameClient.h"
ShortcutKeyHandler::ShortcutKeyHandler(Emulator* emu)
{
	_emu = emu;
	_keySetIndex = 0;
	_isKeyUp = false;
	_isKeyboardConnected = false;
	_repeatStarted = false;
	_needRepeat = false;
	_stopThread = false;
	_thread = std::thread([=]() {
		while(!_stopThread) {
			ProcessKeys();
			std::this_thread::sleep_for(std::chrono::duration<int, std::milli>(50));
		}
	});
}
ShortcutKeyHandler::~ShortcutKeyHandler()
{
	_stopThread = true;
	_thread.join();
}
bool ShortcutKeyHandler::IsKeyPressed(EmulatorShortcut shortcut)
{
	bool blockKeyboardKeys = shortcut != EmulatorShortcut::Pause && _isKeyboardConnected && !_isPaused;
	KeyCombination keyComb = _emu->GetSettings()->GetShortcutKey(shortcut, _keySetIndex);
	vector<KeyCombination> supersets = _emu->GetSettings()->GetShortcutSupersets(shortcut, _keySetIndex);
	for(KeyCombination &superset : supersets) {
		if(IsKeyPressed(superset, blockKeyboardKeys)) {
			return false;
		}
	}
	return IsKeyPressed(keyComb, blockKeyboardKeys);
}
bool ShortcutKeyHandler::IsKeyPressed(KeyCombination comb, bool blockKeyboardKeys)
{
	int keyCount = (comb.Key1 ? 1 : 0) + (comb.Key2 ? 1 : 0) + (comb.Key3 ? 1 : 0);
	if(keyCount == 0 || _pressedKeys.empty()) {
		return false;
	}
	bool mergeCtrlAltShift = keyCount > 1;
	return IsKeyPressed(comb.Key1, mergeCtrlAltShift, blockKeyboardKeys) &&
		(comb.Key2 == 0 || IsKeyPressed(comb.Key2, mergeCtrlAltShift, blockKeyboardKeys)) &&
		(comb.Key3 == 0 || IsKeyPressed(comb.Key3, mergeCtrlAltShift, blockKeyboardKeys));
}
bool ShortcutKeyHandler::IsKeyPressed(uint16_t keyCode, bool mergeCtrlAltShift, bool blockKeyboardKeys)
{
	if(blockKeyboardKeys && keyCode < IKeyManager::BaseMouseButtonIndex) {
		return false;
	}
	if(keyCode >= 116 && keyCode <= 121 && mergeCtrlAltShift) {
		return KeyManager::IsKeyPressed(keyCode | 1) || KeyManager::IsKeyPressed(keyCode & ~0x01);
	}
	return KeyManager::IsKeyPressed(keyCode);
}
bool ShortcutKeyHandler::DetectKeyPress(EmulatorShortcut shortcut)
{
	if(IsKeyPressed(shortcut)) {
		bool newlyPressed = _prevKeysDown[_keySetIndex].find((uint32_t)shortcut) == _prevKeysDown[_keySetIndex].end();
		_keysDown[_keySetIndex].emplace((uint32_t)shortcut);
		if(newlyPressed && !_isKeyUp) {
			return true;
		}
	}
	return false;
}
bool ShortcutKeyHandler::DetectKeyRelease(EmulatorShortcut shortcut)
{
	if(!IsKeyPressed(shortcut)) {
		if(_prevKeysDown[_keySetIndex].find((uint32_t)shortcut) != _prevKeysDown[_keySetIndex].end()) {
			return true;
		}
	}
	return false;
}
void ShortcutKeyHandler::ProcessRunSingleFrame()
{
	_runSingleFrameRepeatTimer.Reset();
	_needRepeat = true;
	_emu->PauseOnNextFrame();
}
bool ShortcutKeyHandler::IsShortcutAllowed(EmulatorShortcut shortcut, uint32_t shortcutParam)
{
	bool isRunning = _emu->IsRunning();
	bool isNetplayClient = _emu->GetGameClient()->Connected();
	bool isMoviePlaying = _emu->GetMovieManager()->Playing();
	bool isMovieRecording = _emu->GetMovieManager()->Recording();
	bool isMovieActive = isMoviePlaying || isMovieRecording;
	switch(shortcut) {
		case EmulatorShortcut::ToggleRewind:
		case EmulatorShortcut::Rewind:
		case EmulatorShortcut::RewindTenSecs:
		case EmulatorShortcut::RewindOneMin:
			return isRunning && !isNetplayClient && !isMovieRecording;
		case EmulatorShortcut::IncreaseSpeed:
		case EmulatorShortcut::DecreaseSpeed:
		case EmulatorShortcut::MaxSpeed:
			return !isNetplayClient;
		case EmulatorShortcut::Pause:
			return isRunning && !isNetplayClient;
		case EmulatorShortcut::Reset:
		case EmulatorShortcut::ExecReset:
		case EmulatorShortcut::PowerCycle:
		case EmulatorShortcut::ExecPowerCycle:
		case EmulatorShortcut::ReloadRom:
		case EmulatorShortcut::ExecReloadRom:
			return isRunning && !isNetplayClient && !isMoviePlaying;
		case EmulatorShortcut::PowerOff:
		case EmulatorShortcut::ExecPowerOff:
			return isRunning && !isNetplayClient;
		case EmulatorShortcut::TakeScreenshot:
			return isRunning;
		case EmulatorShortcut::ToggleCheats:
			return !isNetplayClient && !isMovieActive;
		case EmulatorShortcut::SelectSaveSlot1: case EmulatorShortcut::SelectSaveSlot2: case EmulatorShortcut::SelectSaveSlot3: case EmulatorShortcut::SelectSaveSlot4: case EmulatorShortcut::SelectSaveSlot5:
		case EmulatorShortcut::SelectSaveSlot6: case EmulatorShortcut::SelectSaveSlot7: case EmulatorShortcut::SelectSaveSlot8: case EmulatorShortcut::SelectSaveSlot9: case EmulatorShortcut::SelectSaveSlot10:
		case EmulatorShortcut::SaveStateSlot1: case EmulatorShortcut::SaveStateSlot2: case EmulatorShortcut::SaveStateSlot3: case EmulatorShortcut::SaveStateSlot4: case EmulatorShortcut::SaveStateSlot5:
		case EmulatorShortcut::SaveStateSlot6: case EmulatorShortcut::SaveStateSlot7: case EmulatorShortcut::SaveStateSlot8: case EmulatorShortcut::SaveStateSlot9: case EmulatorShortcut::SaveStateSlot10:
		case EmulatorShortcut::MoveToNextStateSlot:
		case EmulatorShortcut::MoveToPreviousStateSlot:
		case EmulatorShortcut::SaveStateDialog:
		case EmulatorShortcut::SaveStateToFile:
		case EmulatorShortcut::SaveState:
			return isRunning;
		case EmulatorShortcut::LoadStateSlot1: case EmulatorShortcut::LoadStateSlot2: case EmulatorShortcut::LoadStateSlot3: case EmulatorShortcut::LoadStateSlot4: case EmulatorShortcut::LoadStateSlot5:
		case EmulatorShortcut::LoadStateSlot6: case EmulatorShortcut::LoadStateSlot7: case EmulatorShortcut::LoadStateSlot8: case EmulatorShortcut::LoadStateSlot9: case EmulatorShortcut::LoadStateSlot10:
		case EmulatorShortcut::LoadStateSlotAuto:
		case EmulatorShortcut::LoadStateDialog:
		case EmulatorShortcut::LoadStateFromFile:
		case EmulatorShortcut::LoadState:
		case EmulatorShortcut::LoadLastSession:
			return isRunning && !isNetplayClient && !isMovieActive;
		case EmulatorShortcut::InputBarcode:
			if(isRunning && !isNetplayClient && !isMoviePlaying) {
				shared_ptr<IConsole> console = _emu->GetConsole();
				if(console) {
					return console->GetControlManager()->GetControlDevice<IBarcodeReader>() != nullptr;
				}
			}
			return false;
		case EmulatorShortcut::RecordTape:
		case EmulatorShortcut::StopRecordTape:
		case EmulatorShortcut::LoadTape: {
			if(isRunning && !isNetplayClient && !isMoviePlaying) {
				shared_ptr<IConsole> console = _emu->GetConsole();
				if(console) {
					shared_ptr<ITapeRecorder> recorder = console->GetControlManager()->GetControlDevice<ITapeRecorder>();
					if(recorder) {
						bool recording = recorder->IsRecording();
						if(recording) {
							return shortcut == EmulatorShortcut::StopRecordTape;
						} else {
							return shortcut != EmulatorShortcut::StopRecordTape;
						}
					}
				}
			}
			return false;
		}
	}
	ShortcutState state = _emu->IsShortcutAllowed(shortcut, shortcutParam);
	if(state == ShortcutState::Default) {
		return shortcut < EmulatorShortcut::InputBarcode;
	} else {
		return state == ShortcutState::Enabled ? true : false;
	}
}
void ShortcutKeyHandler::ProcessShortcutPressed(EmulatorShortcut shortcut, uint32_t shortcutParam)
{
	if(!IsShortcutAllowed(shortcut, shortcutParam)) {
		return;
	}
	EmuSettings* settings = _emu->GetSettings();
	switch(shortcut) {
		case EmulatorShortcut::Pause:
			if(_emu->IsPaused()) {
				_emu->Resume();
			} else {
				_emu->Pause();
			}
			break;
		case EmulatorShortcut::ExecReset: _emu->GetSystemActionManager()->Reset(); break;
		case EmulatorShortcut::ExecPowerCycle: _emu->GetSystemActionManager()->PowerCycle(); break;
		case EmulatorShortcut::ExecReloadRom: _emu->ReloadRom(false); break;
		case EmulatorShortcut::ExecPowerOff: _emu->Stop(true); break;
		case EmulatorShortcut::FastForward: settings->SetFlag(EmulationFlags::Turbo); break;
		case EmulatorShortcut::ToggleFastForward:
			if(settings->CheckFlag(EmulationFlags::Turbo)) {
				settings->ClearFlag(EmulationFlags::Turbo);
			} else {
				settings->SetFlag(EmulationFlags::Turbo);
			}
			break;
		case EmulatorShortcut::SelectSaveSlot1: case EmulatorShortcut::SelectSaveSlot2: case EmulatorShortcut::SelectSaveSlot3: case EmulatorShortcut::SelectSaveSlot4: case EmulatorShortcut::SelectSaveSlot5:
		case EmulatorShortcut::SelectSaveSlot6: case EmulatorShortcut::SelectSaveSlot7: case EmulatorShortcut::SelectSaveSlot8: case EmulatorShortcut::SelectSaveSlot9: case EmulatorShortcut::SelectSaveSlot10:
			_emu->GetSaveStateManager()->SelectSaveSlot((int)shortcut - (int)EmulatorShortcut::SelectSaveSlot1 + 1);
			break;
		case EmulatorShortcut::SaveStateSlot1: case EmulatorShortcut::SaveStateSlot2: case EmulatorShortcut::SaveStateSlot3: case EmulatorShortcut::SaveStateSlot4: case EmulatorShortcut::SaveStateSlot5:
		case EmulatorShortcut::SaveStateSlot6: case EmulatorShortcut::SaveStateSlot7: case EmulatorShortcut::SaveStateSlot8: case EmulatorShortcut::SaveStateSlot9: case EmulatorShortcut::SaveStateSlot10:
			_emu->GetSaveStateManager()->SaveState((int)shortcut - (int)EmulatorShortcut::SaveStateSlot1 + 1);
			break;
		case EmulatorShortcut::LoadStateSlot1: case EmulatorShortcut::LoadStateSlot2: case EmulatorShortcut::LoadStateSlot3: case EmulatorShortcut::LoadStateSlot4: case EmulatorShortcut::LoadStateSlot5:
		case EmulatorShortcut::LoadStateSlot6: case EmulatorShortcut::LoadStateSlot7: case EmulatorShortcut::LoadStateSlot8: case EmulatorShortcut::LoadStateSlot9: case EmulatorShortcut::LoadStateSlot10:
		case EmulatorShortcut::LoadStateSlotAuto:
			_emu->GetSaveStateManager()->LoadState((int)shortcut - (int)EmulatorShortcut::LoadStateSlot1 + 1);
			break;
		case EmulatorShortcut::MoveToNextStateSlot: _emu->GetSaveStateManager()->MoveToNextSlot(); break;
		case EmulatorShortcut::MoveToPreviousStateSlot: _emu->GetSaveStateManager()->MoveToPreviousSlot(); break;
		case EmulatorShortcut::SaveState: _emu->GetSaveStateManager()->SaveState(); break;
		case EmulatorShortcut::LoadState: _emu->GetSaveStateManager()->LoadState(); break;
		case EmulatorShortcut::RunSingleFrame: ProcessRunSingleFrame(); break;
		case EmulatorShortcut::ToggleRewind:
			if(_emu->GetRewindManager()->IsRewinding()) {
				_emu->GetRewindManager()->StopRewinding();
			} else {
				_emu->GetRewindManager()->StartRewinding();
			}
			break;
		case EmulatorShortcut::Rewind: _emu->GetRewindManager()->StartRewinding(); break;
		case EmulatorShortcut::RewindTenSecs: _emu->GetRewindManager()->RewindSeconds(10); break;
		case EmulatorShortcut::RewindOneMin: _emu->GetRewindManager()->RewindSeconds(60); break;
		default:
			break;
	}
}
void ShortcutKeyHandler::ProcessShortcutReleased(EmulatorShortcut shortcut, uint32_t shortcutParam)
{
	if(!IsShortcutAllowed(shortcut, shortcutParam)) {
		return;
	}
	EmuSettings* settings = _emu->GetSettings();
	switch(shortcut) {
		case EmulatorShortcut::FastForward: settings->ClearFlag(EmulationFlags::Turbo); break;
		case EmulatorShortcut::Rewind: _emu->GetRewindManager()->StopRewinding(); break;
		case EmulatorShortcut::RunSingleFrame:
			_repeatStarted = false;
			_needRepeat = false;
			break;
	}
}
void ShortcutKeyHandler::CheckMappedKeys()
{
	for(uint64_t i = 0; i < (uint64_t)EmulatorShortcut::ShortcutCount; i++) {
		EmulatorShortcut shortcut = (EmulatorShortcut)i;
		if(DetectKeyPress(shortcut)) {
			if(!IsShortcutAllowed(shortcut, 0)) {
				continue;
			}
			ExecuteShortcutParams params = {};
			params.Shortcut = shortcut;
			_emu->GetNotificationManager()->SendNotification(ConsoleNotificationType::ExecuteShortcut, &params);
		} else if(DetectKeyRelease(shortcut)) {
			ExecuteShortcutParams params = {};
			params.Shortcut = shortcut;
			_emu->GetNotificationManager()->SendNotification(ConsoleNotificationType::ReleaseShortcut, &params);
		}
	}
}
void ShortcutKeyHandler::ProcessKeys()
{
	if(!_emu->GetSettings()->IsInputEnabled()) {
		return;
	}
	auto lock = _lock.AcquireSafe();
	KeyManager::RefreshKeyState();
	_isKeyboardConnected = _emu->IsKeyboardConnected();
	_isPaused = _emu->IsPaused();
	_pressedKeys = KeyManager::GetPressedKeys();
	_isKeyUp = _pressedKeys.size() < _lastPressedKeys.size();
	bool noChange = false;
	if(_pressedKeys.size() == _lastPressedKeys.size()) {
		noChange = true;
		for(size_t i = 0; i < _pressedKeys.size(); i++) {
			if(_pressedKeys[i] != _lastPressedKeys[i]) {
				noChange = false;
				break;
			}
		}
	}
	if(!noChange) {
		for(int i = 0; i < 2; i++) {
			_keysDown[i].clear();
			_keySetIndex = i;
			CheckMappedKeys();
			_prevKeysDown[i] = _keysDown[i];
		}
		_lastPressedKeys = _pressedKeys;
	}
	if(_needRepeat) {
		double elapsedMs = _runSingleFrameRepeatTimer.GetElapsedMS();
		if((_repeatStarted && elapsedMs >= 50) || (!_repeatStarted && elapsedMs >= 500)) {
			_repeatStarted = true;
			ProcessRunSingleFrame();
		}
	}
}
void ShortcutKeyHandler::ProcessNotification(ConsoleNotificationType type, void* parameter)
{
	switch(type) {
		case ConsoleNotificationType::ExecuteShortcut: {
			ExecuteShortcutParams p = *(ExecuteShortcutParams*)parameter;
			ProcessShortcutPressed(p.Shortcut, p.Param);
			break;
		}
		case ConsoleNotificationType::ReleaseShortcut: {
			ExecuteShortcutParams p = *(ExecuteShortcutParams*)parameter;
			ProcessShortcutReleased(p.Shortcut, p.Param);
			break;
		}
	}
}
```

## File: Core/Shared/ShortcutKeyHandler.h
```
#pragma once
#include "pch.h"
#include "Shared/Interfaces/INotificationListener.h"
#include "Shared/SettingTypes.h"
#include "Utilities/SimpleLock.h"
#include "Utilities/Timer.h"
class Emulator;
class ShortcutKeyHandler final : public INotificationListener, public std::enable_shared_from_this<ShortcutKeyHandler>
{
private:
	Emulator* _emu = nullptr;
	thread _thread;
	atomic<bool> _stopThread;
	SimpleLock _lock;
	int _keySetIndex = 0;
	vector<uint16_t> _pressedKeys;
	vector<uint16_t> _lastPressedKeys;
	bool _isKeyUp = false;
	bool _isKeyboardConnected = false;
	bool _isPaused = false;
	Timer _runSingleFrameRepeatTimer;
	atomic<bool> _repeatStarted;
	atomic<bool> _needRepeat;
	unordered_set<uint32_t> _keysDown[2];
	unordered_set<uint32_t> _prevKeysDown[2];
	void CheckMappedKeys();
	bool IsKeyPressed(EmulatorShortcut key);
	bool IsKeyPressed(KeyCombination comb, bool blockKeyboardKeys);
	bool IsKeyPressed(uint16_t keyCode, bool mergeCtrlAltShift, bool blockKeyboardKeys);
	bool DetectKeyPress(EmulatorShortcut key);
	bool DetectKeyRelease(EmulatorShortcut key);
	void ProcessRunSingleFrame();
	void ProcessShortcutPressed(EmulatorShortcut shortcut, uint32_t shortcutParam);
	void ProcessShortcutReleased(EmulatorShortcut shortcut, uint32_t shortcutParam);
public:
	ShortcutKeyHandler(Emulator* emu);
	virtual ~ShortcutKeyHandler();
	bool IsShortcutAllowed(EmulatorShortcut shortcut, uint32_t shortcutParam);
	void ProcessKeys();
	void ProcessNotification(ConsoleNotificationType type, void* parameter) override;
};
```

## File: Core/Shared/SystemActionManager.h
```
#pragma once
#include "pch.h"
#include "Shared/BaseControlDevice.h"
#include "Shared/Emulator.h"
class SystemActionManager : public BaseControlDevice
{
private:
	bool _needReset = false;
	bool _needPowerCycle = false;
protected:
	string GetKeyNames() override
	{
		return "RP";
	}
public:
	enum Buttons { ResetButton = 0, PowerButton = 1 };
	SystemActionManager(Emulator* emu) : BaseControlDevice(emu, ControllerType::None, BaseControlDevice::ConsoleInputPort)
	{
		_connected = false;
	}
	uint8_t ReadRam(uint16_t addr) override
	{
		return 0;
	}
	void WriteRam(uint16_t addr, uint8_t value) override
	{
	}
	void ResetState()
	{
		_needPowerCycle = false;
		_needReset = false;
		ClearBit(SystemActionManager::Buttons::ResetButton);
		ClearBit(SystemActionManager::Buttons::PowerButton);
	}
	void OnAfterSetState() override
	{
		if(_needReset) {
			SetBit(SystemActionManager::Buttons::ResetButton);
		}
		if(_needPowerCycle) {
			SetBit(SystemActionManager::Buttons::PowerButton);
		}
	}
	bool Reset()
	{
		if(!_needReset) {
			_needReset = true;
			_emu->SuspendDebugger(false);
			return true;
		}
		return false;
	}
	bool PowerCycle()
	{
		if(!_needPowerCycle) {
			_needPowerCycle = true;
			_emu->SuspendDebugger(false);
			return true;
		}
		return false;
	}
	bool IsResetPending()
	{
		return _needReset || _needPowerCycle;
	}
	bool IsResetPressed()
	{
		return IsPressed(SystemActionManager::Buttons::ResetButton);
	}
	bool IsPowerCyclePressed()
	{
		return IsPressed(SystemActionManager::Buttons::PowerButton);
	}
};
```

## File: Core/Shared/TimingInfo.h
```
#pragma once
#include "pch.h"
struct TimingInfo
{
	double Fps;
	uint64_t MasterClock;
	uint32_t MasterClockRate;
	uint32_t FrameCount;
	uint32_t ScanlineCount;
	int32_t FirstScanline;
	uint32_t CycleCount;
};
```

## File: Core/Shared/Utilities/emu2413.cpp
```cpp
#if defined(_MSC_VER)
	#pragma warning(push, 0)
#elif defined(__clang__)
	#pragma clang diagnostic push
	#pragma clang diagnostic ignored "-Wall"
	#pragma clang diagnostic ignored "-Wextra"
#endif
#include "emu2413.h"
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#ifndef INLINE
#if defined(_MSC_VER)
#define INLINE __inline
#elif defined(__GNUC__)
#define INLINE __inline__
#else
#define INLINE inline
#endif
#endif
#define _PI_ 3.14159265358979323846264338327950288
#define OPLL_TONE_NUM 3
static uint8_t default_inst[OPLL_TONE_NUM][(16 + 3) * 8] = {{
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x71,0x61,0x1e,0x17,0xd0,0x78,0x00,0x17,
0x13,0x41,0x1a,0x0d,0xd8,0xf7,0x23,0x13,
0x13,0x01,0x99,0x00,0xf2,0xc4,0x21,0x23,
0x11,0x61,0x0e,0x07,0x8d,0x64,0x70,0x27,
0x32,0x21,0x1e,0x06,0xe1,0x76,0x01,0x28,
0x31,0x22,0x16,0x05,0xe0,0x71,0x00,0x18,
0x21,0x61,0x1d,0x07,0x82,0x81,0x11,0x07,
0x33,0x21,0x2d,0x13,0xb0,0x70,0x00,0x07,
0x61,0x61,0x1b,0x06,0x64,0x65,0x10,0x17,
0x41,0x61,0x0b,0x18,0x85,0xf0,0x81,0x07,
0x33,0x01,0x83,0x11,0xea,0xef,0x10,0x04,
0x17,0xc1,0x24,0x07,0xf8,0xf8,0x22,0x12,
0x61,0x50,0x0c,0x05,0xd2,0xf5,0x40,0x42,
0x01,0x01,0x55,0x03,0xe9,0x90,0x03,0x02,
0x41,0x41,0x89,0x03,0xf1,0xe4,0xc0,0x13,
0x01,0x01,0x18,0x0f,0xdf,0xf8,0x6a,0x6d,
0x01,0x01,0x00,0x00,0xc8,0xd8,0xa7,0x68,
0x05,0x01,0x00,0x00,0xf8,0xaa,0x59,0x55,
},{
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x03,0x21,0x05,0x06,0xe8,0x81,0x42,0x27,
0x13,0x41,0x14,0x0d,0xd8,0xf6,0x23,0x12,
0x11,0x11,0x08,0x08,0xfa,0xb2,0x20,0x12,
0x31,0x61,0x0c,0x07,0xa8,0x64,0x61,0x27,
0x32,0x21,0x1e,0x06,0xe1,0x76,0x01,0x28,
0x02,0x01,0x06,0x00,0xa3,0xe2,0xf4,0xf4,
0x21,0x61,0x1d,0x07,0x82,0x81,0x11,0x07,
0x23,0x21,0x22,0x17,0xa2,0x72,0x01,0x17,
0x35,0x11,0x25,0x00,0x40,0x73,0x72,0x01,
0xb5,0x01,0x0f,0x0F,0xa8,0xa5,0x51,0x02,
0x17,0xc1,0x24,0x07,0xf8,0xf8,0x22,0x12,
0x71,0x23,0x11,0x06,0x65,0x74,0x18,0x16,
0x01,0x02,0xd3,0x05,0xc9,0x95,0x03,0x02,
0x61,0x63,0x0c,0x00,0x94,0xC0,0x33,0xf6,
0x21,0x72,0x0d,0x00,0xc1,0xd5,0x56,0x06,
0x01,0x01,0x18,0x0f,0xdf,0xf8,0x6a,0x6d,
0x01,0x01,0x00,0x00,0xc8,0xd8,0xa7,0x68,
0x05,0x01,0x00,0x00,0xf8,0xaa,0x59,0x55,
},{
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x62,0x21,0x1a,0x07,0xf0,0x6f,0x00,0x16,
0x40,0x10,0x45,0x00,0xf6,0x83,0x73,0x63,
0x13,0x01,0x99,0x00,0xf2,0xc3,0x21,0x23,
0x01,0x61,0x0b,0x0f,0xf9,0x64,0x70,0x17,
0x32,0x21,0x1e,0x06,0xe1,0x76,0x01,0x28,
0x60,0x01,0x82,0x0e,0xf9,0x61,0x20,0x27,
0x21,0x61,0x1c,0x07,0x84,0x81,0x11,0x07,
0x37,0x32,0xc9,0x01,0x66,0x64,0x40,0x28,
0x01,0x21,0x07,0x03,0xa5,0x71,0x51,0x07,
0x06,0x01,0x5e,0x07,0xf3,0xf3,0xf6,0x13,
0x00,0x00,0x18,0x06,0xf5,0xf3,0x20,0x23,
0x17,0xc1,0x24,0x07,0xf8,0xf8,0x22,0x12,
0x35,0x64,0x00,0x00,0xff,0xf3,0x77,0xf5,
0x11,0x31,0x00,0x07,0xdd,0xf3,0xff,0xfb,
0x3a,0x21,0x00,0x07,0x80,0x84,0x0f,0xf5,
0x01,0x01,0x18,0x0f,0xdf,0xf8,0x6a,0x6d,
0x01,0x01,0x00,0x00,0xc8,0xd8,0xa7,0x68,
0x05,0x01,0x00,0x00,0xf8,0xaa,0x59,0x55,
}};
#define DP_BITS 19
#define DP_WIDTH (1 << DP_BITS)
#define DP_BASE_BITS (DP_BITS - PG_BITS)
#define EG_STEP 0.375
#define EG_BITS 7
#define EG_MUTE ((1 << EG_BITS) - 1)
#define EG_MAX (EG_MUTE - 4)
#define TL_STEP 0.75
#define TL_BITS 6
#define SL_STEP 3.0
#define SL_BITS 4
#define DAMPER_RATE 12
#define TL2EG(d) ((d) << 1)
#define PG_BITS 10
#define PG_WIDTH (1 << PG_BITS)
static uint16_t exp_table[256] = {
0,    3,    6,    8,    11,   14,   17,   20,   22,   25,   28,   31,   34,   37,   40,   42,
45,   48,   51,   54,   57,   60,   63,   66,   69,   72,   75,   78,   81,   84,   87,   90,
93,   96,   99,   102,  105,  108,  111,  114,  117,  120,  123,  126,  130,  133,  136,  139,
142,  145,  148,  152,  155,  158,  161,  164,  168,  171,  174,  177,  181,  184,  187,  190,
194,  197,  200,  204,  207,  210,  214,  217,  220,  224,  227,  231,  234,  237,  241,  244,
248,  251,  255,  258,  262,  265,  268,  272,  276,  279,  283,  286,  290,  293,  297,  300,
304,  308,  311,  315,  318,  322,  326,  329,  333,  337,  340,  344,  348,  352,  355,  359,
363,  367,  370,  374,  378,  382,  385,  389,  393,  397,  401,  405,  409,  412,  416,  420,
424,  428,  432,  436,  440,  444,  448,  452,  456,  460,  464,  468,  472,  476,  480,  484,
488,  492,  496,  501,  505,  509,  513,  517,  521,  526,  530,  534,  538,  542,  547,  551,
555,  560,  564,  568,  572,  577,  581,  585,  590,  594,  599,  603,  607,  612,  616,  621,
625,  630,  634,  639,  643,  648,  652,  657,  661,  666,  670,  675,  680,  684,  689,  693,
698,  703,  708,  712,  717,  722,  726,  731,  736,  741,  745,  750,  755,  760,  765,  770,
774,  779,  784,  789,  794,  799,  804,  809,  814,  819,  824,  829,  834,  839,  844,  849,
854,  859,  864,  869,  874,  880,  885,  890,  895,  900,  906,  911,  916,  921,  927,  932,
937,  942,  948,  953,  959,  964,  969,  975,  980,  986,  991,  996, 1002, 1007, 1013, 1018
};
static uint16_t fullsin_table[PG_WIDTH] = {
2137, 1731, 1543, 1419, 1326, 1252, 1190, 1137, 1091, 1050, 1013, 979,  949,  920,  894,  869,
846,  825,  804,  785,  767,  749,  732,  717,  701,  687,  672,  659,  646,  633,  621,  609,
598,  587,  576,  566,  556,  546,  536,  527,  518,  509,  501,  492,  484,  476,  468,  461,
453,  446,  439,  432,  425,  418,  411,  405,  399,  392,  386,  380,  375,  369,  363,  358,
352,  347,  341,  336,  331,  326,  321,  316,  311,  307,  302,  297,  293,  289,  284,  280,
276,  271,  267,  263,  259,  255,  251,  248,  244,  240,  236,  233,  229,  226,  222,  219,
215,  212,  209,  205,  202,  199,  196,  193,  190,  187,  184,  181,  178,  175,  172,  169,
167,  164,  161,  159,  156,  153,  151,  148,  146,  143,  141,  138,  136,  134,  131,  129,
127,  125,  122,  120,  118,  116,  114,  112,  110,  108,  106,  104,  102,  100,  98,   96,
94,   92,   91,   89,   87,   85,   83,   82,   80,   78,   77,   75,   74,   72,   70,   69,
67,   66,   64,   63,   62,   60,   59,   57,   56,   55,   53,   52,   51,   49,   48,   47,
46,   45,   43,   42,   41,   40,   39,   38,   37,   36,   35,   34,   33,   32,   31,   30,
29,   28,   27,   26,   25,   24,   23,   23,   22,   21,   20,   20,   19,   18,   17,   17,
16,   15,   15,   14,   13,   13,   12,   12,   11,   10,   10,   9,    9,    8,    8,    7,
7,    7,    6,    6,    5,    5,    5,    4,    4,    4,    3,    3,    3,    2,    2,    2,
2,    1,    1,    1,    1,    1,    1,    1,    0,    0,    0,    0,    0,    0,    0,    0,
};
static uint16_t halfsin_table[PG_WIDTH];
static uint16_t *wave_table_map[2] = {fullsin_table, halfsin_table};
static int8_t pm_table[8][8] = {
    {0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 1, 0, 0, 0, -1, 0},
    {0, 1, 2, 1, 0, -1, -2, -1},
    {0, 1, 3, 1, 0, -1, -3, -1},
    {0, 2, 4, 2, 0, -2, -4, -2},
    {0, 2, 5, 2, 0, -2, -5, -2},
    {0, 3, 6, 3, 0, -3, -6, -3},
    {0, 3, 7, 3, 0, -3, -7, -3},
};
static uint8_t am_table[210] = {0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  1,  1,  1,
                                2,  2,  2,  2,  2,  2,  2,  2,  3,  3,  3,  3,  3,  3,  3,  3,
                                4,  4,  4,  4,  4,  4,  4,  4,  5,  5,  5,  5,  5,  5,  5,  5,
                                6,  6,  6,  6,  6,  6,  6,  6,  7,  7,  7,  7,  7,  7,  7,  7,
                                8,  8,  8,  8,  8,  8,  8,  8,  9,  9,  9,  9,  9,  9,  9,  9,
                                10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11,
                                12, 12, 12, 12, 12, 12, 12, 12,
                                13, 13, 13,
                                12, 12, 12, 12, 12, 12, 12, 12,
                                11, 11, 11, 11, 11, 11, 11, 11, 10, 10, 10, 10, 10, 10, 10, 10,
                                9,  9,  9,  9,  9,  9,  9,  9,  8,  8,  8,  8,  8,  8,  8,  8,
                                7,  7,  7,  7,  7,  7,  7,  7,  6,  6,  6,  6,  6,  6,  6,  6,
                                5,  5,  5,  5,  5,  5,  5,  5,  4,  4,  4,  4,  4,  4,  4,  4,
                                3,  3,  3,  3,  3,  3,  3,  3,  2,  2,  2,  2,  2,  2,  2,  2,
                                1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  0,  0,  0};
static uint8_t eg_step_tables[4][8] = {
    {0, 1, 0, 1, 0, 1, 0, 1},
    {0, 1, 0, 1, 1, 1, 0, 1},
    {0, 1, 1, 1, 0, 1, 1, 1},
    {0, 1, 1, 1, 1, 1, 1, 1},
};
enum __OPLL_EG_STATE { ATTACK, DECAY, SUSTAIN, RELEASE, DAMP, UNKNOWN };
static uint32_t ml_table[16] = {1,     1 * 2, 2 * 2,  3 * 2,  4 * 2,  5 * 2,  6 * 2,  7 * 2,
                                8 * 2, 9 * 2, 10 * 2, 10 * 2, 12 * 2, 12 * 2, 15 * 2, 15 * 2};
#define dB2(x) ((x)*2)
static double kl_table[16] = {dB2(0.000),  dB2(9.000),  dB2(12.000), dB2(13.875), dB2(15.000), dB2(16.125),
                              dB2(16.875), dB2(17.625), dB2(18.000), dB2(18.750), dB2(19.125), dB2(19.500),
                              dB2(19.875), dB2(20.250), dB2(20.625), dB2(21.000)};
static uint32_t tll_table[8 * 16][1 << TL_BITS][4];
static int32_t rks_table[8 * 2][2];
static OPLL_PATCH null_patch = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
static OPLL_PATCH default_patch[OPLL_TONE_NUM][(16 + 3) * 2];
#ifndef min
static INLINE int min(int i, int j) { return (i < j) ? i : j; }
#endif
#ifndef max
static INLINE int max(int i, int j) { return (i > j) ? i : j; }
#endif
#define LW 16
#define SINC_RESO 256
#define SINC_AMP_BITS 12
static double blackman(double x) { return 0.42 - 0.5 * cos(2 * _PI_ * x) + 0.08 * cos(4 * _PI_ * x); }
static double sinc(double x) { return (x == 0.0 ? 1.0 : sin(_PI_ * x) / (_PI_ * x)); }
static double windowed_sinc(double x) { return blackman(0.5 + 0.5 * x / (LW / 2)) * sinc(x); }
OPLL_RateConv *OPLL_RateConv_new(double f_inp, double f_out, int ch) {
  OPLL_RateConv *conv = (OPLL_RateConv*)malloc(sizeof(OPLL_RateConv));
  int i;
  conv->ch = ch;
  conv->f_ratio = f_inp / f_out;
  conv->buf = (int16_t**)malloc(sizeof(void *) * ch);
  for (i = 0; i < ch; i++) {
    conv->buf[i] = (int16_t*)malloc(sizeof(conv->buf[0][0]) * LW);
  }
  conv->sinc_table = (int16_t*)malloc(sizeof(conv->sinc_table[0]) * SINC_RESO * LW / 2);
  for (i = 0; i < SINC_RESO * LW / 2; i++) {
    const double x = (double)i / SINC_RESO;
    if (f_out < f_inp) {
      conv->sinc_table[i] = (int16_t)((1 << SINC_AMP_BITS) * windowed_sinc(x / conv->f_ratio) / conv->f_ratio);
    } else {
      conv->sinc_table[i] = (int16_t)((1 << SINC_AMP_BITS) * windowed_sinc(x));
    }
  }
  return conv;
}
static INLINE int16_t lookup_sinc_table(int16_t *table, double x) {
  int16_t index = (int16_t)(x * SINC_RESO);
  if (index < 0)
    index = -index;
  return table[min(SINC_RESO * LW / 2 - 1, index)];
}
void OPLL_RateConv_reset(OPLL_RateConv *conv) {
  int i;
  conv->timer = 0;
  for (i = 0; i < conv->ch; i++) {
    memset(conv->buf[i], 0, sizeof(conv->buf[i][0]) * LW);
  }
}
void OPLL_RateConv_putData(OPLL_RateConv *conv, int ch, int16_t data) {
  int16_t *buf = conv->buf[ch];
  int i;
  for (i = 0; i < LW - 1; i++) {
    buf[i] = buf[i + 1];
  }
  buf[LW - 1] = data;
}
int16_t OPLL_RateConv_getData(OPLL_RateConv *conv, int ch) {
  int16_t *buf = conv->buf[ch];
  int32_t sum = 0;
  int k;
  double dn;
  conv->timer += conv->f_ratio;
  dn = conv->timer - floor(conv->timer);
  conv->timer = dn;
  for (k = 0; k < LW; k++) {
    double x = ((double)k - (LW / 2 - 1)) - dn;
    sum += buf[k] * lookup_sinc_table(conv->sinc_table, x);
  }
  return sum >> SINC_AMP_BITS;
}
void OPLL_RateConv_delete(OPLL_RateConv *conv) {
  int i;
  for (i = 0; i < conv->ch; i++) {
    free(conv->buf[i]);
  }
  free(conv->buf);
  free(conv->sinc_table);
  free(conv);
}
static void makeSinTable(void) {
  int x;
  for (x = 0; x < PG_WIDTH / 4; x++) {
    fullsin_table[PG_WIDTH / 4 + x] = fullsin_table[PG_WIDTH / 4 - x - 1];
  }
  for (x = 0; x < PG_WIDTH / 2; x++) {
    fullsin_table[PG_WIDTH / 2 + x] = 0x8000 | fullsin_table[x];
  }
  for (x = 0; x < PG_WIDTH / 2; x++)
    halfsin_table[x] = fullsin_table[x];
  for (x = PG_WIDTH / 2; x < PG_WIDTH; x++)
    halfsin_table[x] = 0xfff;
}
static void makeTllTable(void) {
  int32_t tmp;
  int32_t fnum, block, TL, KL;
  for (fnum = 0; fnum < 16; fnum++) {
    for (block = 0; block < 8; block++) {
      for (TL = 0; TL < 64; TL++) {
        for (KL = 0; KL < 4; KL++) {
          if (KL == 0) {
            tll_table[(block << 4) | fnum][TL][KL] = TL2EG(TL);
          } else {
            tmp = (int32_t)(kl_table[fnum] - dB2(3.000) * (7 - block));
            if (tmp <= 0)
              tll_table[(block << 4) | fnum][TL][KL] = TL2EG(TL);
            else
              tll_table[(block << 4) | fnum][TL][KL] = (uint32_t)((tmp >> (3 - KL)) / EG_STEP) + TL2EG(TL);
          }
        }
      }
    }
  }
}
static void makeRksTable(void) {
  int fnum8, block;
  for (fnum8 = 0; fnum8 < 2; fnum8++)
    for (block = 0; block < 8; block++) {
      rks_table[(block << 1) | fnum8][1] = (block << 1) + fnum8;
      rks_table[(block << 1) | fnum8][0] = block >> 1;
    }
}
static void makeDefaultPatch(void) {
  int i, j;
  for (i = 0; i < OPLL_TONE_NUM; i++)
    for (j = 0; j < 19; j++)
      OPLL_getDefaultPatch(i, j, &default_patch[i][j * 2]);
}
static uint8_t table_initialized = 0;
static void initializeTables(void) {
  makeTllTable();
  makeRksTable();
  makeSinTable();
  makeDefaultPatch();
  table_initialized = 1;
}
#define SLOT_BD1 12
#define SLOT_BD2 13
#define SLOT_HH 14
#define SLOT_SD 15
#define SLOT_TOM 16
#define SLOT_CYM 17
#define MOD(o, x) (&(o)->slot[(x) << 1])
#define CAR(o, x) (&(o)->slot[((x) << 1) | 1])
#define BIT(s, b) (((s) >> (b)) & 1)
#if OPLL_DEBUG
static void _debug_print_patch(OPLL_SLOT *slot) {
  OPLL_PATCH *p = slot->patch;
  printf("[slot#%d am:%d pm:%d eg:%d kr:%d ml:%d kl:%d tl:%d ws:%d fb:%d A:%d D:%d S:%d R:%d]\n", slot->number,
         p->AM, p->PM, p->EG, p->KR, p->ML,
         p->KL, p->TL, p->WS, p->FB,
         p->AR, p->DR, p->SL, p->RR);
}
static char *_debug_eg_state_name(OPLL_SLOT *slot) {
  switch (slot->eg_state) {
  case ATTACK:
    return "attack";
  case DECAY:
    return "decay";
  case SUSTAIN:
    return "sustain";
  case RELEASE:
    return "release";
  case DAMP:
    return "damp";
  default:
    return "unknown";
  }
}
static INLINE void _debug_print_slot_info(OPLL_SLOT *slot) {
  char *name = _debug_eg_state_name(slot);
  printf("[slot#%d state:%s fnum:%03x rate:%d-%d]\n", slot->number, name, slot->blk_fnum, slot->eg_rate_h,
         slot->eg_rate_l);
  _debug_print_patch(slot);
  fflush(stdout);
}
#endif
static INLINE int get_parameter_rate(OPLL_SLOT *slot) {
  if ((slot->type & 1) == 0 && slot->key_flag == 0) {
    return 0;
  }
  switch (slot->eg_state) {
  case ATTACK:
    return slot->patch->AR;
  case DECAY:
    return slot->patch->DR;
  case SUSTAIN:
    return slot->patch->EG ? 0 : slot->patch->RR;
  case RELEASE:
    if (slot->sus_flag) {
      return 5;
    } else if (slot->patch->EG) {
      return slot->patch->RR;
    } else {
      return 7;
    }
  case DAMP:
    return DAMPER_RATE;
  default:
    return 0;
  }
}
enum SLOT_UPDATE_FLAG {
  UPDATE_WS = 1,
  UPDATE_TLL = 2,
  UPDATE_RKS = 4,
  UPDATE_EG = 8,
  UPDATE_ALL = 255,
};
static INLINE void request_update(OPLL_SLOT *slot, int flag) { slot->update_requests |= flag; }
static void commit_slot_update(OPLL_SLOT *slot) {
#if OPLL_DEBUG
  if (slot->last_eg_state != slot->eg_state) {
    _debug_print_slot_info(slot);
    slot->last_eg_state = slot->eg_state;
  }
#endif
  if (slot->update_requests & UPDATE_WS) {
    slot->wave_table = wave_table_map[slot->patch->WS];
  }
  if (slot->update_requests & UPDATE_TLL) {
    if ((slot->type & 1) == 0) {
      slot->tll = tll_table[slot->blk_fnum >> 5][slot->patch->TL][slot->patch->KL];
    } else {
      slot->tll = tll_table[slot->blk_fnum >> 5][slot->volume][slot->patch->KL];
    }
  }
  if (slot->update_requests & UPDATE_RKS) {
    slot->rks = rks_table[slot->blk_fnum >> 8][slot->patch->KR];
  }
  if (slot->update_requests & (UPDATE_RKS | UPDATE_EG)) {
    int p_rate = get_parameter_rate(slot);
    if (p_rate == 0) {
      slot->eg_shift = 0;
      slot->eg_rate_h = 0;
      slot->eg_rate_l = 0;
      return;
    }
    slot->eg_rate_h = min(15, p_rate + (slot->rks >> 2));
    slot->eg_rate_l = slot->rks & 3;
    if (slot->eg_state == ATTACK) {
      slot->eg_shift = (0 < slot->eg_rate_h && slot->eg_rate_h < 12) ? (13 - slot->eg_rate_h) : 0;
    } else {
      slot->eg_shift = (slot->eg_rate_h < 13) ? (13 - slot->eg_rate_h) : 0;
    }
  }
  slot->update_requests = 0;
}
static void reset_slot(OPLL_SLOT *slot, int number) {
  slot->number = number;
  slot->type = number % 2;
  slot->pg_keep = 0;
  slot->wave_table = wave_table_map[0];
  slot->pg_phase = 0;
  slot->output[0] = 0;
  slot->output[1] = 0;
  slot->eg_state = RELEASE;
  slot->eg_shift = 0;
  slot->rks = 0;
  slot->tll = 0;
  slot->key_flag = 0;
  slot->sus_flag = 0;
  slot->blk_fnum = 0;
  slot->blk = 0;
  slot->fnum = 0;
  slot->volume = 0;
  slot->pg_out = 0;
  slot->eg_out = EG_MUTE;
  slot->patch = &null_patch;
}
static INLINE void slotOn(OPLL *opll, int i) {
  OPLL_SLOT *slot = &opll->slot[i];
  slot->key_flag = 1;
  slot->eg_state = DAMP;
  request_update(slot, UPDATE_EG);
}
static INLINE void slotOff(OPLL *opll, int i) {
  OPLL_SLOT *slot = &opll->slot[i];
  slot->key_flag = 0;
  if (slot->type & 1) {
    slot->eg_state = RELEASE;
    request_update(slot, UPDATE_EG);
  }
}
static INLINE void update_key_status(OPLL *opll) {
  const uint8_t r14 = opll->reg[0x0e];
  const uint8_t rhythm_mode = BIT(r14, 5);
  uint32_t new_slot_key_status = 0;
  uint32_t updated_status;
  int ch;
  for (ch = 0; ch < 9; ch++)
    if (opll->reg[0x20 + ch] & 0x10)
      new_slot_key_status |= 3 << (ch * 2);
  if (rhythm_mode) {
    if (r14 & 0x10)
      new_slot_key_status |= 3 << SLOT_BD1;
    if (r14 & 0x01)
      new_slot_key_status |= 1 << SLOT_HH;
    if (r14 & 0x08)
      new_slot_key_status |= 1 << SLOT_SD;
    if (r14 & 0x04)
      new_slot_key_status |= 1 << SLOT_TOM;
    if (r14 & 0x02)
      new_slot_key_status |= 1 << SLOT_CYM;
  }
  updated_status = opll->slot_key_status ^ new_slot_key_status;
  if (updated_status) {
    int i;
    for (i = 0; i < 18; i++)
      if (BIT(updated_status, i)) {
        if (BIT(new_slot_key_status, i)) {
          slotOn(opll, i);
        } else {
          slotOff(opll, i);
        }
      }
  }
  opll->slot_key_status = new_slot_key_status;
}
static INLINE void set_patch(OPLL *opll, int32_t ch, int32_t num) {
  opll->patch_number[ch] = num;
  MOD(opll, ch)->patch = &opll->patch[num * 2 + 0];
  CAR(opll, ch)->patch = &opll->patch[num * 2 + 1];
  request_update(MOD(opll, ch), UPDATE_ALL);
  request_update(CAR(opll, ch), UPDATE_ALL);
}
static INLINE void set_sus_flag(OPLL *opll, int ch, int flag) {
  CAR(opll, ch)->sus_flag = flag;
  request_update(CAR(opll, ch), UPDATE_EG);
  if (MOD(opll, ch)->type & 1) {
    MOD(opll, ch)->sus_flag = flag;
    request_update(MOD(opll, ch), UPDATE_EG);
  }
}
static INLINE void set_volume(OPLL *opll, int ch, int volume) {
  CAR(opll, ch)->volume = volume;
  request_update(CAR(opll, ch), UPDATE_TLL);
}
static INLINE void set_slot_volume(OPLL_SLOT *slot, int volume) {
  slot->volume = volume;
  request_update(slot, UPDATE_TLL);
}
static INLINE void set_fnumber(OPLL *opll, int ch, int fnum) {
  OPLL_SLOT *car = CAR(opll, ch);
  OPLL_SLOT *mod = MOD(opll, ch);
  car->fnum = fnum;
  car->blk_fnum = (car->blk_fnum & 0xe00) | (fnum & 0x1ff);
  mod->fnum = fnum;
  mod->blk_fnum = (mod->blk_fnum & 0xe00) | (fnum & 0x1ff);
  request_update(car, UPDATE_EG | UPDATE_RKS | UPDATE_TLL);
  request_update(mod, UPDATE_EG | UPDATE_RKS | UPDATE_TLL);
}
static INLINE void set_block(OPLL *opll, int ch, int blk) {
  OPLL_SLOT *car = CAR(opll, ch);
  OPLL_SLOT *mod = MOD(opll, ch);
  car->blk = blk;
  car->blk_fnum = ((blk & 7) << 9) | (car->blk_fnum & 0x1ff);
  mod->blk = blk;
  mod->blk_fnum = ((blk & 7) << 9) | (mod->blk_fnum & 0x1ff);
  request_update(car, UPDATE_EG | UPDATE_RKS | UPDATE_TLL);
  request_update(mod, UPDATE_EG | UPDATE_RKS | UPDATE_TLL);
}
static INLINE void update_rhythm_mode(OPLL *opll) {
  const uint8_t new_rhythm_mode = (opll->reg[0x0e] >> 5) & 1;
  if (opll->rhythm_mode != new_rhythm_mode) {
    if (new_rhythm_mode) {
      opll->slot[SLOT_HH].type = 3;
      opll->slot[SLOT_HH].pg_keep = 1;
      opll->slot[SLOT_SD].type = 3;
      opll->slot[SLOT_TOM].type = 3;
      opll->slot[SLOT_CYM].type = 3;
      opll->slot[SLOT_CYM].pg_keep = 1;
      set_patch(opll, 6, 16);
      set_patch(opll, 7, 17);
      set_patch(opll, 8, 18);
      set_slot_volume(&opll->slot[SLOT_HH], ((opll->reg[0x37] >> 4) & 15) << 2);
      set_slot_volume(&opll->slot[SLOT_TOM], ((opll->reg[0x38] >> 4) & 15) << 2);
    } else {
      opll->slot[SLOT_HH].type = 0;
      opll->slot[SLOT_HH].pg_keep = 0;
      opll->slot[SLOT_SD].type = 1;
      opll->slot[SLOT_TOM].type = 0;
      opll->slot[SLOT_CYM].type = 1;
      opll->slot[SLOT_CYM].pg_keep = 0;
      set_patch(opll, 6, opll->reg[0x36] >> 4);
      set_patch(opll, 7, opll->reg[0x37] >> 4);
      set_patch(opll, 8, opll->reg[0x38] >> 4);
    }
  }
  opll->rhythm_mode = new_rhythm_mode;
}
static void update_ampm(OPLL *opll) {
  if (opll->test_flag & 2) {
    opll->pm_phase = 0;
    opll->am_phase = 0;
  } else {
    opll->pm_phase += (opll->test_flag & 8) ? 1024 : 1;
    opll->am_phase += (opll->test_flag & 8) ? 64 : 1;
  }
  opll->lfo_am = am_table[(opll->am_phase >> 6) % sizeof(am_table)];
}
static void update_noise(OPLL *opll, int cycle) {
  int i;
  for (i = 0; i < cycle; i++) {
    if (opll->noise & 1) {
      opll->noise ^= 0x800200;
    }
    opll->noise >>= 1;
  }
}
static void update_short_noise(OPLL *opll) {
  const uint32_t pg_hh = opll->slot[SLOT_HH].pg_out;
  const uint32_t pg_cym = opll->slot[SLOT_CYM].pg_out;
  const uint8_t h_bit2 = BIT(pg_hh, PG_BITS - 8);
  const uint8_t h_bit7 = BIT(pg_hh, PG_BITS - 3);
  const uint8_t h_bit3 = BIT(pg_hh, PG_BITS - 7);
  const uint8_t c_bit3 = BIT(pg_cym, PG_BITS - 7);
  const uint8_t c_bit5 = BIT(pg_cym, PG_BITS - 5);
  opll->short_noise = (h_bit2 ^ h_bit7) | (h_bit3 ^ c_bit5) | (c_bit3 ^ c_bit5);
}
static INLINE void calc_phase(OPLL_SLOT *slot, int32_t pm_phase, uint8_t reset) {
  const int8_t pm = slot->patch->PM ? pm_table[(slot->fnum >> 6) & 7][(pm_phase >> 10) & 7] : 0;
  if (reset) {
    slot->pg_phase = 0;
  }
  slot->pg_phase += (((slot->fnum & 0x1ff) * 2 + pm) * ml_table[slot->patch->ML]) << slot->blk >> 2;
  slot->pg_phase &= (DP_WIDTH - 1);
  slot->pg_out = slot->pg_phase >> DP_BASE_BITS;
}
static INLINE uint8_t lookup_attack_step(OPLL_SLOT *slot, uint32_t counter) {
  int index;
  switch (slot->eg_rate_h) {
  case 12:
    index = (counter & 0xc) >> 1;
    return 4 - eg_step_tables[slot->eg_rate_l][index];
  case 13:
    index = (counter & 0xc) >> 1;
    return 3 - eg_step_tables[slot->eg_rate_l][index];
  case 14:
    index = (counter & 0xc) >> 1;
    return 2 - eg_step_tables[slot->eg_rate_l][index];
  case 0:
  case 15:
    return 0;
  default:
    index = counter >> slot->eg_shift;
    return eg_step_tables[slot->eg_rate_l][index & 7] ? 4 : 0;
  }
}
static INLINE uint8_t lookup_decay_step(OPLL_SLOT *slot, uint32_t counter) {
  int index;
  switch (slot->eg_rate_h) {
  case 0:
    return 0;
  case 13:
    index = ((counter & 0xc) >> 1) | (counter & 1);
    return eg_step_tables[slot->eg_rate_l][index];
  case 14:
    index = ((counter & 0xc) >> 1);
    return eg_step_tables[slot->eg_rate_l][index] + 1;
  case 15:
    return 2;
  default:
    index = counter >> slot->eg_shift;
    return eg_step_tables[slot->eg_rate_l][index & 7];
  }
}
static INLINE void start_envelope(OPLL_SLOT *slot) {
  if (min(15, slot->patch->AR + (slot->rks >> 2)) == 15) {
    slot->eg_state = DECAY;
    slot->eg_out = 0;
  } else {
    slot->eg_state = ATTACK;
  }
  request_update(slot, UPDATE_EG);
}
static INLINE void calc_envelope(OPLL_SLOT *slot, OPLL_SLOT *buddy, uint16_t eg_counter, uint8_t test) {
  uint32_t mask = (1 << slot->eg_shift) - 1;
  uint8_t s;
  if (slot->eg_state == ATTACK) {
    if (0 < slot->eg_out && 0 < slot->eg_rate_h && (eg_counter & mask & ~3) == 0) {
      s = lookup_attack_step(slot, eg_counter);
      if (0 < s) {
        slot->eg_out = max(0, ((int)slot->eg_out - (slot->eg_out >> s) - 1));
      }
    }
  } else {
    if (slot->eg_rate_h > 0 && (eg_counter & mask) == 0) {
      slot->eg_out = min(EG_MUTE, slot->eg_out + lookup_decay_step(slot, eg_counter));
    }
  }
  switch (slot->eg_state) {
  case DAMP:
    if (slot->eg_out >= EG_MAX && (eg_counter & mask) == 0) {
      start_envelope(slot);
      if (slot->type & 1) {
        if (!slot->pg_keep) {
          slot->pg_phase = 0;
        }
        if (buddy && !buddy->pg_keep) {
          buddy->pg_phase = 0;
        }
      }
    }
    break;
  case ATTACK:
    if (slot->eg_out == 0) {
      slot->eg_state = DECAY;
      request_update(slot, UPDATE_EG);
    }
    break;
  case DECAY:
    if ((slot->eg_out >> 3) == slot->patch->SL) {
      slot->eg_state = SUSTAIN;
      request_update(slot, UPDATE_EG);
    }
    break;
  case SUSTAIN:
  case RELEASE:
  default:
    break;
  }
  if (test) {
    slot->eg_out = 0;
  }
}
static void update_slots(OPLL *opll) {
  int i;
  opll->eg_counter++;
  for (i = 0; i < 18; i++) {
    OPLL_SLOT *slot = &opll->slot[i];
    OPLL_SLOT *buddy = NULL;
    if (slot->type == 0) {
      buddy = &opll->slot[i + 1];
    }
    if (slot->type == 1) {
      buddy = &opll->slot[i - 1];
    }
    if (slot->update_requests) {
      commit_slot_update(slot);
    }
    calc_envelope(slot, buddy, opll->eg_counter, opll->test_flag & 1);
    calc_phase(slot, opll->pm_phase, opll->test_flag & 4);
  }
}
static INLINE int16_t lookup_exp_table(uint16_t i) {
  int16_t t = (exp_table[(i & 0xff) ^ 0xff] + 1024);
  int16_t res = t >> ((i & 0x7f00) >> 8);
  return ((i & 0x8000) ? ~res : res) << 1;
}
static INLINE int16_t to_linear(uint16_t h, OPLL_SLOT *slot, int16_t am) {
  uint16_t att;
  if (slot->eg_out > EG_MAX)
    return 0;
  att = min(EG_MUTE, (slot->eg_out + slot->tll + am)) << 4;
  return lookup_exp_table(h + att);
}
static INLINE int16_t calc_slot_car(OPLL *opll, int ch, int16_t fm) {
  OPLL_SLOT *slot = CAR(opll, ch);
  uint8_t am = slot->patch->AM ? opll->lfo_am : 0;
  slot->output[1] = slot->output[0];
  slot->output[0] = to_linear(slot->wave_table[(slot->pg_out + 2 * (fm >> 1)) & (PG_WIDTH - 1)], slot, am);
  return slot->output[0];
}
static INLINE int16_t calc_slot_mod(OPLL *opll, int ch) {
  OPLL_SLOT *slot = MOD(opll, ch);
  int16_t fm = slot->patch->FB > 0 ? (slot->output[1] + slot->output[0]) >> (9 - slot->patch->FB) : 0;
  uint8_t am = slot->patch->AM ? opll->lfo_am : 0;
  slot->output[1] = slot->output[0];
  slot->output[0] = to_linear(slot->wave_table[(slot->pg_out + fm) & (PG_WIDTH - 1)], slot, am);
  return slot->output[0];
}
static INLINE int16_t calc_slot_tom(OPLL *opll) {
  OPLL_SLOT *slot = MOD(opll, 8);
  return to_linear(slot->wave_table[slot->pg_out], slot, 0);
}
#define _PD(phase) ((PG_BITS < 10) ? (phase >> (10 - PG_BITS)) : (phase << (PG_BITS - 10)))
static INLINE int16_t calc_slot_snare(OPLL *opll) {
  OPLL_SLOT *slot = CAR(opll, 7);
  uint32_t phase;
  if (BIT(slot->pg_out, PG_BITS - 2))
    phase = (opll->noise & 1) ? _PD(0x300) : _PD(0x200);
  else
    phase = (opll->noise & 1) ? _PD(0x0) : _PD(0x100);
  return to_linear(slot->wave_table[phase], slot, 0);
}
static INLINE int16_t calc_slot_cym(OPLL *opll) {
  OPLL_SLOT *slot = CAR(opll, 8);
  uint32_t phase = opll->short_noise ? _PD(0x300) : _PD(0x100);
  return to_linear(slot->wave_table[phase], slot, 0);
}
static INLINE int16_t calc_slot_hat(OPLL *opll) {
  OPLL_SLOT *slot = MOD(opll, 7);
  uint32_t phase;
  if (opll->short_noise)
    phase = (opll->noise & 1) ? _PD(0x2d0) : _PD(0x234);
  else
    phase = (opll->noise & 1) ? _PD(0x34) : _PD(0xd0);
  return to_linear(slot->wave_table[phase], slot, 0);
}
#define _MO(x) (-(x) >> 1)
#define _RO(x) (x)
static void update_output(OPLL *opll) {
  int16_t *out;
  int i;
  update_ampm(opll);
  if(opll->chip_type == 0) {
    update_short_noise(opll);
  }
  update_slots(opll);
  out = opll->ch_out;
  for (i = 0; i < 6; i++) {
    if (!(opll->mask & OPLL_MASK_CH(i))) {
      out[i] = _MO(calc_slot_car(opll, i, calc_slot_mod(opll, i)));
    }
  }
  if(opll->chip_type == 0) {
    if (!opll->rhythm_mode) {
      if (!(opll->mask & OPLL_MASK_CH(6))) {
        out[6] = _MO(calc_slot_car(opll, 6, calc_slot_mod(opll, 6)));
      }
    } else {
      if (!(opll->mask & OPLL_MASK_BD)) {
        out[9] = _RO(calc_slot_car(opll, 6, calc_slot_mod(opll, 6)));
      }
    }
    update_noise(opll, 14);
    if (!opll->rhythm_mode) {
      if (!(opll->mask & OPLL_MASK_CH(7))) {
        out[7] = _MO(calc_slot_car(opll, 7, calc_slot_mod(opll, 7)));
      }
    } else {
      if (!(opll->mask & OPLL_MASK_HH)) {
        out[10] = _RO(calc_slot_hat(opll));
      }
      if (!(opll->mask & OPLL_MASK_SD)) {
        out[11] = _RO(calc_slot_snare(opll));
      }
    }
    update_noise(opll, 2);
    if (!opll->rhythm_mode) {
      if (!(opll->mask & OPLL_MASK_CH(8))) {
        out[8] = _MO(calc_slot_car(opll, 8, calc_slot_mod(opll, 8)));
      }
    } else {
      if (!(opll->mask & OPLL_MASK_TOM)) {
        out[12] = _RO(calc_slot_tom(opll));
      }
      if (!(opll->mask & OPLL_MASK_CYM)) {
        out[13] = _RO(calc_slot_cym(opll));
      }
    }
    update_noise(opll, 2);
  }
}
INLINE static void mix_output(OPLL *opll) {
  int16_t out = 0;
  int i;
  if(opll->chip_type == 0) {
    for (i = 0; i < 14; i++) {
      out += opll->ch_out[i];
    }
  } else {
    for(i = 0; i < 6; i++) {
       out += opll->ch_out[i];
    }
  }
  if (opll->conv) {
    OPLL_RateConv_putData(opll->conv, 0, out);
  } else {
    opll->mix_out[0] = out;
  }
}
INLINE static void mix_output_stereo(OPLL *opll) {
  int16_t *out = opll->mix_out;
  int i;
  out[0] = out[1] = 0;
  for (i = 0; i < 14; i++) {
    if (opll->pan[i] & 2)
      out[0] += (int16_t)(opll->ch_out[i] * opll->pan_fine[i][0]);
    if (opll->pan[i] & 1)
      out[1] += (int16_t)(opll->ch_out[i] * opll->pan_fine[i][1]);
  }
  if (opll->conv) {
    OPLL_RateConv_putData(opll->conv, 0, out[0]);
    OPLL_RateConv_putData(opll->conv, 1, out[1]);
  }
}
OPLL *OPLL_new(uint32_t clk, uint32_t rate) {
  OPLL *opll;
  int i;
  if (!table_initialized) {
    initializeTables();
  }
  opll = (OPLL *)calloc(sizeof(OPLL), 1);
  if (opll == NULL)
    return NULL;
  for (i = 0; i < 19 * 2; i++)
    memcpy(&opll->patch[i], &null_patch, sizeof(OPLL_PATCH));
  opll->clk = clk;
  opll->rate = rate;
  opll->mask = 0;
  opll->conv = NULL;
  opll->mix_out[0] = 0;
  opll->mix_out[1] = 0;
  OPLL_reset(opll);
  OPLL_setChipType(opll, 0);
  OPLL_resetPatch(opll, 0);
  return opll;
}
void OPLL_delete(OPLL *opll) {
  if (opll->conv) {
    OPLL_RateConv_delete(opll->conv);
    opll->conv = NULL;
  }
  free(opll);
}
static void reset_rate_conversion_params(OPLL *opll) {
  const double f_out = opll->rate;
  const double f_inp = opll->clk / 72.0;
  opll->out_time = 0;
  opll->out_step = f_inp;
  opll->inp_step = f_out;
  if (opll->conv) {
    OPLL_RateConv_delete(opll->conv);
    opll->conv = NULL;
  }
  if (floor(f_inp) != f_out && floor(f_inp + 0.5) != f_out) {
    opll->conv = OPLL_RateConv_new(f_inp, f_out, 2);
  }
  if (opll->conv) {
    OPLL_RateConv_reset(opll->conv);
  }
}
void OPLL_reset(OPLL *opll) {
  int i;
  if (!opll)
    return;
  opll->adr = 0;
  opll->pm_phase = 0;
  opll->am_phase = 0;
  opll->noise = 0x1;
  opll->mask = 0;
  opll->rhythm_mode = 0;
  opll->slot_key_status = 0;
  opll->eg_counter = 0;
  reset_rate_conversion_params(opll);
  for (i = 0; i < 18; i++)
    reset_slot(&opll->slot[i], i);
  for (i = 0; i < 9; i++) {
    set_patch(opll, i, 0);
  }
  for (i = 0; i < 0x40; i++)
    OPLL_writeReg(opll, i, 0);
  for (i = 0; i < 15; i++) {
    opll->pan[i] = 3;
    opll->pan_fine[i][1] = opll->pan_fine[i][0] = 1.0f;
  }
  for (i = 0; i < 14; i++) {
    opll->ch_out[i] = 0;
  }
}
void OPLL_forceRefresh(OPLL *opll) {
  int i;
  if (opll == NULL)
    return;
  for (i = 0; i < 9; i++) {
    set_patch(opll, i, opll->patch_number[i]);
  }
  for (i = 0; i < 18; i++) {
    request_update(&opll->slot[i], UPDATE_ALL);
  }
}
void OPLL_setRate(OPLL *opll, uint32_t rate) {
  opll->rate = rate;
  reset_rate_conversion_params(opll);
}
void OPLL_setQuality(OPLL *opll, uint8_t q) {}
void OPLL_setChipType(OPLL *opll, uint8_t type) { opll->chip_type = type; }
void OPLL_writeReg(OPLL *opll, uint32_t reg, uint8_t data) {
  int ch, i;
  if (reg >= 0x40)
    return;
  if ((0x19 <= reg && reg <= 0x1f) || (0x29 <= reg && reg <= 0x2f) || (0x39 <= reg && reg <= 0x3f)) {
    reg -= 9;
  }
  opll->reg[reg] = (uint8_t)data;
  switch (reg) {
  case 0x00:
    opll->patch[0].AM = (data >> 7) & 1;
    opll->patch[0].PM = (data >> 6) & 1;
    opll->patch[0].EG = (data >> 5) & 1;
    opll->patch[0].KR = (data >> 4) & 1;
    opll->patch[0].ML = (data)&15;
    for (i = 0; i < 9; i++) {
      if (opll->patch_number[i] == 0) {
        request_update(MOD(opll, i), UPDATE_RKS | UPDATE_EG);
      }
    }
    break;
  case 0x01:
    opll->patch[1].AM = (data >> 7) & 1;
    opll->patch[1].PM = (data >> 6) & 1;
    opll->patch[1].EG = (data >> 5) & 1;
    opll->patch[1].KR = (data >> 4) & 1;
    opll->patch[1].ML = (data)&15;
    for (i = 0; i < 9; i++) {
      if (opll->patch_number[i] == 0) {
        request_update(CAR(opll, i), UPDATE_RKS | UPDATE_EG);
      }
    }
    break;
  case 0x02:
    opll->patch[0].KL = (data >> 6) & 3;
    opll->patch[0].TL = (data)&63;
    for (i = 0; i < 9; i++) {
      if (opll->patch_number[i] == 0) {
        request_update(MOD(opll, i), UPDATE_TLL);
      }
    }
    break;
  case 0x03:
    opll->patch[1].KL = (data >> 6) & 3;
    opll->patch[1].WS = (data >> 4) & 1;
    opll->patch[0].WS = (data >> 3) & 1;
    opll->patch[0].FB = (data)&7;
    for (i = 0; i < 9; i++) {
      if (opll->patch_number[i] == 0) {
        request_update(MOD(opll, i), UPDATE_WS);
        request_update(CAR(opll, i), UPDATE_WS | UPDATE_TLL);
      }
    }
    break;
  case 0x04:
    opll->patch[0].AR = (data >> 4) & 15;
    opll->patch[0].DR = (data)&15;
    for (i = 0; i < 9; i++) {
      if (opll->patch_number[i] == 0) {
        request_update(MOD(opll, i), UPDATE_EG);
      }
    }
    break;
  case 0x05:
    opll->patch[1].AR = (data >> 4) & 15;
    opll->patch[1].DR = (data)&15;
    for (i = 0; i < 9; i++) {
      if (opll->patch_number[i] == 0) {
        request_update(CAR(opll, i), UPDATE_EG);
      }
    }
    break;
  case 0x06:
    opll->patch[0].SL = (data >> 4) & 15;
    opll->patch[0].RR = (data)&15;
    for (i = 0; i < 9; i++) {
      if (opll->patch_number[i] == 0) {
        request_update(MOD(opll, i), UPDATE_EG);
      }
    }
    break;
  case 0x07:
    opll->patch[1].SL = (data >> 4) & 15;
    opll->patch[1].RR = (data)&15;
    for (i = 0; i < 9; i++) {
      if (opll->patch_number[i] == 0) {
        request_update(CAR(opll, i), UPDATE_EG);
      }
    }
    break;
  case 0x0e:
    if (opll->chip_type == 1)
      break;
    update_rhythm_mode(opll);
    update_key_status(opll);
    break;
  case 0x0f:
    opll->test_flag = data;
    break;
  case 0x10:
  case 0x11:
  case 0x12:
  case 0x13:
  case 0x14:
  case 0x15:
  case 0x16:
  case 0x17:
  case 0x18:
    if(opll->chip_type == 1 && reg >= 0x16) break;
    ch = reg - 0x10;
    set_fnumber(opll, ch, data + ((opll->reg[0x20 + ch] & 1) << 8));
    break;
  case 0x20:
  case 0x21:
  case 0x22:
  case 0x23:
  case 0x24:
  case 0x25:
  case 0x26:
  case 0x27:
  case 0x28:
    if(opll->chip_type == 1 && reg >= 0x26) break;
    ch = reg - 0x20;
    set_fnumber(opll, ch, ((data & 1) << 8) + opll->reg[0x10 + ch]);
    set_block(opll, ch, (data >> 1) & 7);
    set_sus_flag(opll, ch, (data >> 5) & 1);
    update_key_status(opll);
    break;
  case 0x30:
  case 0x31:
  case 0x32:
  case 0x33:
  case 0x34:
  case 0x35:
  case 0x36:
  case 0x37:
  case 0x38:
    if(opll->chip_type == 1 && reg >= 0x36) break;
    if ((opll->reg[0x0e] & 32) && (reg >= 0x36)) {
      switch (reg) {
      case 0x37:
        set_slot_volume(MOD(opll, 7), ((data >> 4) & 15) << 2);
        break;
      case 0x38:
        set_slot_volume(MOD(opll, 8), ((data >> 4) & 15) << 2);
        break;
      default:
        break;
      }
    } else {
      set_patch(opll, reg - 0x30, (data >> 4) & 15);
    }
    set_volume(opll, reg - 0x30, (data & 15) << 2);
    break;
  default:
    break;
  }
}
void OPLL_writeIO(OPLL *opll, uint32_t adr, uint8_t val) {
  if (adr & 1)
    OPLL_writeReg(opll, opll->adr, val);
  else
    opll->adr = val;
}
void OPLL_setPan(OPLL *opll, uint32_t ch, uint8_t pan) { opll->pan[ch & 15] = pan; }
void OPLL_setPanFine(OPLL *opll, uint32_t ch, float pan[2]) {
  opll->pan_fine[ch & 15][0] = pan[0];
  opll->pan_fine[ch & 15][1] = pan[1];
}
void OPLL_dumpToPatch(const uint8_t *dump, OPLL_PATCH *patch) {
  patch[0].AM = (dump[0] >> 7) & 1;
  patch[1].AM = (dump[1] >> 7) & 1;
  patch[0].PM = (dump[0] >> 6) & 1;
  patch[1].PM = (dump[1] >> 6) & 1;
  patch[0].EG = (dump[0] >> 5) & 1;
  patch[1].EG = (dump[1] >> 5) & 1;
  patch[0].KR = (dump[0] >> 4) & 1;
  patch[1].KR = (dump[1] >> 4) & 1;
  patch[0].ML = (dump[0]) & 15;
  patch[1].ML = (dump[1]) & 15;
  patch[0].KL = (dump[2] >> 6) & 3;
  patch[1].KL = (dump[3] >> 6) & 3;
  patch[0].TL = (dump[2]) & 63;
  patch[1].TL = 0;
  patch[0].FB = (dump[3]) & 7;
  patch[1].FB = 0;
  patch[0].WS = (dump[3] >> 3) & 1;
  patch[1].WS = (dump[3] >> 4) & 1;
  patch[0].AR = (dump[4] >> 4) & 15;
  patch[1].AR = (dump[5] >> 4) & 15;
  patch[0].DR = (dump[4]) & 15;
  patch[1].DR = (dump[5]) & 15;
  patch[0].SL = (dump[6] >> 4) & 15;
  patch[1].SL = (dump[7] >> 4) & 15;
  patch[0].RR = (dump[6]) & 15;
  patch[1].RR = (dump[7]) & 15;
}
void OPLL_getDefaultPatch(int32_t type, int32_t num, OPLL_PATCH *patch) {
  OPLL_dumpToPatch(default_inst[type] + num * 8, patch);
}
void OPLL_setPatch(OPLL *opll, const uint8_t *dump) {
  OPLL_PATCH patch[2];
  int i;
  for (i = 0; i < 19; i++) {
    OPLL_dumpToPatch(dump + i * 8, patch);
    memcpy(&opll->patch[i * 2 + 0], &patch[0], sizeof(OPLL_PATCH));
    memcpy(&opll->patch[i * 2 + 1], &patch[1], sizeof(OPLL_PATCH));
  }
}
void OPLL_patchToDump(const OPLL_PATCH *patch, uint8_t *dump) {
  dump[0] = (uint8_t)((patch[0].AM << 7) + (patch[0].PM << 6) + (patch[0].EG << 5) + (patch[0].KR << 4) + patch[0].ML);
  dump[1] = (uint8_t)((patch[1].AM << 7) + (patch[1].PM << 6) + (patch[1].EG << 5) + (patch[1].KR << 4) + patch[1].ML);
  dump[2] = (uint8_t)((patch[0].KL << 6) + patch[0].TL);
  dump[3] = (uint8_t)((patch[1].KL << 6) + (patch[1].WS << 4) + (patch[0].WS << 3) + patch[0].FB);
  dump[4] = (uint8_t)((patch[0].AR << 4) + patch[0].DR);
  dump[5] = (uint8_t)((patch[1].AR << 4) + patch[1].DR);
  dump[6] = (uint8_t)((patch[0].SL << 4) + patch[0].RR);
  dump[7] = (uint8_t)((patch[1].SL << 4) + patch[1].RR);
}
void OPLL_copyPatch(OPLL *opll, int32_t num, OPLL_PATCH *patch) {
  memcpy(&opll->patch[num], patch, sizeof(OPLL_PATCH));
}
void OPLL_resetPatch(OPLL *opll, uint8_t type) {
  int i;
  for (i = 0; i < 19 * 2; i++)
    OPLL_copyPatch(opll, i, &default_patch[type % OPLL_TONE_NUM][i]);
}
int16_t OPLL_calc(OPLL *opll) {
  while (opll->out_step > opll->out_time) {
    opll->out_time += opll->inp_step;
    update_output(opll);
    mix_output(opll);
  }
  opll->out_time -= opll->out_step;
  if (opll->conv) {
    opll->mix_out[0] = OPLL_RateConv_getData(opll->conv, 0);
  }
  return opll->mix_out[0];
}
void OPLL_calcStereo(OPLL *opll, int32_t out[2]) {
  while (opll->out_step > opll->out_time) {
    opll->out_time += opll->inp_step;
    update_output(opll);
    mix_output_stereo(opll);
  }
  opll->out_time -= opll->out_step;
  if (opll->conv) {
    out[0] = OPLL_RateConv_getData(opll->conv, 0);
    out[1] = OPLL_RateConv_getData(opll->conv, 1);
  } else {
    out[0] = opll->mix_out[0];
    out[1] = opll->mix_out[1];
  }
}
uint32_t OPLL_setMask(OPLL *opll, uint32_t mask) {
  uint32_t ret;
  if (opll) {
    ret = opll->mask;
    opll->mask = mask;
    return ret;
  } else
    return 0;
}
uint32_t OPLL_toggleMask(OPLL *opll, uint32_t mask) {
  uint32_t ret;
  if (opll) {
    ret = opll->mask;
    opll->mask ^= mask;
    return ret;
  } else
    return 0;
}
```

## File: Core/Shared/Utilities/emu2413.h
```
#ifndef _EMU2413_H_
#define _EMU2413_H_
#include <stdint.h>
#define OPLL_DEBUG 0
enum OPLL_TONE_ENUM { OPLL_2413_TONE = 0, OPLL_VRC7_TONE = 1, OPLL_281B_TONE = 2 };
typedef struct __OPLL_PATCH {
  uint32_t TL, FB, EG, ML, AR, DR, SL, RR, KR, KL, AM, PM, WS;
} OPLL_PATCH;
typedef struct __OPLL_SLOT {
  uint8_t number;
  uint8_t type;
  OPLL_PATCH *patch;
  int32_t output[2];
  uint16_t *wave_table;
  uint32_t pg_phase;
  uint32_t pg_out;
  uint8_t pg_keep;
  uint16_t blk_fnum;
  uint16_t fnum;
  uint8_t blk;
  uint8_t eg_state;
  int32_t volume;
  uint8_t key_flag;
  uint8_t sus_flag;
  uint16_t tll;
  uint8_t rks;
  uint8_t eg_rate_h;
  uint8_t eg_rate_l;
  uint32_t eg_shift;
  uint32_t eg_out;
  uint32_t update_requests;
#if OPLL_DEBUG
  uint8_t last_eg_state;
#endif
} OPLL_SLOT;
#define OPLL_MASK_CH(x) (1 << (x))
#define OPLL_MASK_HH (1 << (9))
#define OPLL_MASK_CYM (1 << (10))
#define OPLL_MASK_TOM (1 << (11))
#define OPLL_MASK_SD (1 << (12))
#define OPLL_MASK_BD (1 << (13))
#define OPLL_MASK_RHYTHM (OPLL_MASK_HH | OPLL_MASK_CYM | OPLL_MASK_TOM | OPLL_MASK_SD | OPLL_MASK_BD)
typedef struct __OPLL_RateConv {
  int ch;
  double timer;
  double f_ratio;
  int16_t *sinc_table;
  int16_t **buf;
} OPLL_RateConv;
OPLL_RateConv *OPLL_RateConv_new(double f_inp, double f_out, int ch);
void OPLL_RateConv_reset(OPLL_RateConv *conv);
void OPLL_RateConv_putData(OPLL_RateConv *conv, int ch, int16_t data);
int16_t OPLL_RateConv_getData(OPLL_RateConv *conv, int ch);
void OPLL_RateConv_delete(OPLL_RateConv *conv);
typedef struct __OPLL {
  uint32_t clk;
  uint32_t rate;
  uint8_t chip_type;
  uint32_t adr;
  double inp_step;
  double out_step;
  double out_time;
  uint8_t reg[0x40];
  uint8_t test_flag;
  uint32_t slot_key_status;
  uint8_t rhythm_mode;
  uint32_t eg_counter;
  uint32_t pm_phase;
  int32_t am_phase;
  uint8_t lfo_am;
  uint32_t noise;
  uint8_t short_noise;
  int32_t patch_number[9];
  OPLL_SLOT slot[18];
  OPLL_PATCH patch[19 * 2];
  uint8_t pan[16];
  float pan_fine[16][2];
  uint32_t mask;
  int16_t ch_out[14];
  int16_t mix_out[2];
  OPLL_RateConv *conv;
} OPLL;
OPLL *OPLL_new(uint32_t clk, uint32_t rate);
void OPLL_delete(OPLL *);
void OPLL_reset(OPLL *);
void OPLL_resetPatch(OPLL *, uint8_t);
void OPLL_setRate(OPLL *opll, uint32_t rate);
void OPLL_setQuality(OPLL *opll, uint8_t q);
void OPLL_setPan(OPLL *opll, uint32_t ch, uint8_t pan);
void OPLL_setPanFine(OPLL *opll, uint32_t ch, float pan[2]);
void OPLL_setChipType(OPLL *opll, uint8_t type);
void OPLL_writeIO(OPLL *opll, uint32_t reg, uint8_t val);
void OPLL_writeReg(OPLL *opll, uint32_t reg, uint8_t val);
int16_t OPLL_calc(OPLL *opll);
void OPLL_calcStereo(OPLL *opll, int32_t out[2]);
void OPLL_setPatch(OPLL *, const uint8_t *dump);
void OPLL_copyPatch(OPLL *, int32_t, OPLL_PATCH *);
void OPLL_forceRefresh(OPLL *);
void OPLL_dumpToPatch(const uint8_t *dump, OPLL_PATCH *patch);
void OPLL_patchToDump(const OPLL_PATCH *patch, uint8_t *dump);
void OPLL_getDefaultPatch(int32_t type, int32_t num, OPLL_PATCH *);
uint32_t OPLL_setMask(OPLL *, uint32_t mask);
uint32_t OPLL_toggleMask(OPLL *, uint32_t mask);
#define OPLL_set_rate OPLL_setRate
#define OPLL_set_quality OPLL_setQuality
#define OPLL_set_pan OPLL_setPan
#define OPLL_set_pan_fine OPLL_setPanFine
#define OPLL_calc_stereo OPLL_calcStereo
#define OPLL_reset_patch OPLL_resetPatch
#define OPLL_dump2patch OPLL_dumpToPatch
#define OPLL_patch2dump OPLL_patchToDump
#define OPLL_setChipMode OPLL_setChipType
#endif
```

## File: Core/Shared/Utilities/Emu2413Serializer.h
```
#include "pch.h"
#include "Shared/Utilities/emu2413.h"
#include "Utilities/Serializer.h"
class Emu2413Serializer
{
public:
	static void Serialize(OPLL* opll, Serializer& s)
	{
		SV(opll->clk);
		SV(opll->rate);
		SV(opll->chip_type);
		SV(opll->adr);
		SV(opll->inp_step);
		SV(opll->out_step);
		SV(opll->out_time);
		SVArray(opll->reg, 0x40);
		SV(opll->test_flag);
		SV(opll->slot_key_status);
		SV(opll->rhythm_mode);
		SV(opll->eg_counter);
		SV(opll->pm_phase);
		SV(opll->am_phase);
		SV(opll->lfo_am);
		SV(opll->noise);
		SV(opll->short_noise);
		SVArray(opll->patch_number, 9);
		for(int i = 0; i < 18; i++) {
			SVI(opll->slot[i].number);
			SVI(opll->slot[i].type);
			SVI(opll->slot[i].output[0]);
			SVI(opll->slot[i].output[1]);
			SVI(opll->slot[i].pg_phase);
			SVI(opll->slot[i].pg_out);
			SVI(opll->slot[i].pg_keep);
			SVI(opll->slot[i].blk_fnum);
			SVI(opll->slot[i].fnum);
			SVI(opll->slot[i].blk);
			SVI(opll->slot[i].eg_state);
			SVI(opll->slot[i].volume);
			SVI(opll->slot[i].key_flag);
			SVI(opll->slot[i].sus_flag);
			SVI(opll->slot[i].tll);
			SVI(opll->slot[i].rks);
			SVI(opll->slot[i].eg_rate_h);
			SVI(opll->slot[i].eg_rate_l);
			SVI(opll->slot[i].eg_shift);
			SVI(opll->slot[i].eg_out);
			SVI(opll->slot[i].update_requests);
		}
		SV(opll->mask);
		SVArray(opll->ch_out, 14);
		SVArray(opll->mix_out, 2);
		for(int i = 0; i < 2; i++) {
			SVI(opll->patch[i].TL);
			SVI(opll->patch[i].FB);
			SVI(opll->patch[i].EG);
			SVI(opll->patch[i].ML);
			SVI(opll->patch[i].AR);
			SVI(opll->patch[i].DR);
			SVI(opll->patch[i].SL);
			SVI(opll->patch[i].RR);
			SVI(opll->patch[i].KR);
			SVI(opll->patch[i].KL);
			SVI(opll->patch[i].AM);
			SVI(opll->patch[i].PM);
			SVI(opll->patch[i].WS);
		}
		if(!s.IsSaving()) {
			OPLL_forceRefresh(opll);
		}
	}
};
```

## File: InteropDLL/Common.h
```
#pragma once
#if _WIN32 || _WIN64
	#pragma comment(lib, "ws2_32.lib")
	#define DllExport __declspec(dllexport)
#else
	#define __stdcall
	#define DllExport __attribute__((visibility("default")))
#endif
```

## File: InteropDLL/ConfigApiWrapper.cpp
```cpp
#include "Common.h"
#include "Core/Shared/Emulator.h"
#include "Core/Shared/Interfaces/IAudioDevice.h"
#include "Core/Shared/BaseControlManager.h"
#include "Core/Shared/BaseControlDevice.h"
#include "Core/Shared/EmuSettings.h"
#include "Core/Shared/SettingTypes.h"
#include "Utilities/StringUtilities.h"
extern unique_ptr<Emulator> _emu;
extern unique_ptr<IAudioDevice> _soundManager;
extern "C" {
	DllExport void __stdcall SetVideoConfig(VideoConfig config)
	{
		_emu->GetSettings()->SetVideoConfig(config);
	}
	DllExport void __stdcall SetAudioConfig(AudioConfig config)
	{
		_emu->GetSettings()->SetAudioConfig(config);
	}
	DllExport void __stdcall SetInputConfig(InputConfig config)
	{
		_emu->GetSettings()->SetInputConfig(config);
	}
	DllExport void __stdcall SetEmulationConfig(EmulationConfig config)
	{
		_emu->GetSettings()->SetEmulationConfig(config);
	}
	DllExport void __stdcall SetGameboyConfig(GameboyConfig config)
	{
		_emu->GetSettings()->SetGameboyConfig(config);
	}
	DllExport void __stdcall SetGbaConfig(GbaConfig config)
	{
		_emu->GetSettings()->SetGbaConfig(config);
	}
	DllExport void __stdcall SetPcEngineConfig(PcEngineConfig config)
	{
		_emu->GetSettings()->SetPcEngineConfig(config);
	}
	DllExport void __stdcall SetNesConfig(NesConfig config)
	{
		_emu->GetSettings()->SetNesConfig(config);
	}
	DllExport void __stdcall SetSnesConfig(SnesConfig config)
	{
		_emu->GetSettings()->SetSnesConfig(config);
	}
	DllExport void __stdcall SetSmsConfig(SmsConfig config)
	{
		_emu->GetSettings()->SetSmsConfig(config);
	}
	DllExport void __stdcall SetCvConfig(CvConfig config)
	{
		_emu->GetSettings()->SetCvConfig(config);
	}
	DllExport void __stdcall SetWsConfig(WsConfig config)
	{
		_emu->GetSettings()->SetWsConfig(config);
	}
	DllExport void __stdcall SetGameConfig(GameConfig config)
	{
		_emu->GetSettings()->SetGameConfig(config);
	}
	DllExport void __stdcall SetPreferences(PreferencesConfig config)
	{
		_emu->GetSettings()->SetPreferences(config);
	}
	DllExport void __stdcall SetAudioPlayerConfig(AudioPlayerConfig config)
	{
		_emu->GetSettings()->SetAudioPlayerConfig(config);
	}
	DllExport void __stdcall SetDebugConfig(DebugConfig config)
	{
		_emu->GetSettings()->SetDebugConfig(config);
	}
	DllExport void __stdcall SetShortcutKeys(ShortcutKeyInfo shortcuts[], uint32_t count)
	{
		vector<ShortcutKeyInfo> shortcutList(shortcuts, shortcuts + count);
		_emu->GetSettings()->SetShortcutKeys(shortcutList);
	}
	DllExport NesConfig __stdcall GetNesConfig()
	{
		return _emu->GetSettings()->GetNesConfig();
	}
	DllExport void __stdcall GetAudioDevices(char* outDeviceList, uint32_t maxLength)
	{
		StringUtilities::CopyToBuffer(_soundManager ? _soundManager->GetAvailableDevices() : "", outDeviceList, maxLength);
	}
	DllExport void __stdcall SetEmulationFlag(EmulationFlags flag, bool enabled)
	{
		_emu->GetSettings()->SetFlagState(flag, enabled);
	}
	DllExport void __stdcall SetDebuggerFlag(DebuggerFlags flag, bool enabled)
	{
		_emu->GetSettings()->SetDebuggerFlag(flag, enabled);
	}
}
```

## File: InteropDLL/DebugApiWrapper.cpp
```cpp
#include "Common.h"
#include "Core/Shared/Emulator.h"
#include "Core/Shared/DebuggerRequest.h"
#include "Core/Debugger/Debugger.h"
#include "Core/Debugger/IDebugger.h"
#include "Core/Debugger/MemoryDumper.h"
#include "Core/Debugger/MemoryAccessCounter.h"
#include "Core/Debugger/CdlManager.h"
#include "Core/Debugger/Disassembler.h"
#include "Core/Debugger/DisassemblySearch.h"
#include "Core/Debugger/DebugTypes.h"
#include "Core/Debugger/Breakpoint.h"
#include "Core/Debugger/BreakpointManager.h"
#include "Core/Debugger/PpuTools.h"
#include "Core/Debugger/CodeDataLogger.h"
#include "Core/Debugger/CallstackManager.h"
#include "Core/Debugger/LabelManager.h"
#include "Core/Debugger/ScriptManager.h"
#include "Core/Debugger/Profiler.h"
#include "Core/Debugger/IAssembler.h"
#include "Core/Debugger/BaseEventManager.h"
#include "Core/Debugger/ITraceLogger.h"
#include "Core/Debugger/TraceLogFileSaver.h"
#include "Core/Debugger/FrozenAddressManager.h"
#include "Core/Gameboy/GbTypes.h"
#include "Utilities/StringUtilities.h"
extern unique_ptr<Emulator> _emu;
template<typename T>
T WrapDebuggerCall(std::function<T(Debugger* debugger)> func)
{
	DebuggerRequest dbgRequest = _emu->GetDebugger(true);
	if(dbgRequest.GetDebugger()) {
		return func(dbgRequest.GetDebugger());
	} else {
		return {};
	}
}
template<>
void WrapDebuggerCall(std::function<void(Debugger* debugger)> func)
{
	DebuggerRequest dbgRequest = _emu->GetDebugger(true);
	if(dbgRequest.GetDebugger()) {
		func(dbgRequest.GetDebugger());
	}
}
#define WithDebugger(t, x) WrapDebuggerCall<t>([&](Debugger* dbg) -> t { return dbg->x; });
#define WithTool(t, x, f) WrapDebuggerCall<t>([&](Debugger* dbg) -> t { if(dbg->x) { return dbg->x->f; } else { return {}; } });
#define WithToolVoid(x, f) WrapDebuggerCall<void>([&](Debugger* dbg) -> void { if(dbg->x) { return dbg->x->f; } });
extern "C"
{
	DllExport void __stdcall InitializeDebugger()
	{
		_emu->InitDebugger();
	}
	DllExport void __stdcall ReleaseDebugger()
	{
		_emu->StopDebugger();
	}
	DllExport bool __stdcall IsDebuggerRunning()
	{
		return _emu->GetDebugger().GetDebugger() != nullptr;
	}
	DllExport bool __stdcall IsExecutionStopped() { return WithDebugger(bool, IsExecutionStopped()); }
	DllExport void __stdcall ResumeExecution() { if(IsDebuggerRunning()) WithDebugger(void, Run()); }
	DllExport void __stdcall Step(CpuType cpuType, uint32_t count, StepType type) { WithDebugger(void, Step(cpuType, count, type)); }
	DllExport uint32_t __stdcall GetDisassemblyOutput(CpuType type, uint32_t lineIndex, CodeLineData output[], uint32_t rowCount) { return WithDebugger(uint32_t, GetDisassembler()->GetDisassemblyOutput(type, lineIndex, output, rowCount)); }
	DllExport uint32_t __stdcall GetDisassemblyRowAddress(CpuType type, uint32_t address, int32_t rowOffset) { return WithDebugger(uint32_t, GetDisassembler()->GetDisassemblyRowAddress(type, address, rowOffset)); }
	DllExport int32_t __stdcall SearchDisassembly(CpuType type, const char* searchString, int32_t startPosition, DisassemblySearchOptions options) { return WithDebugger(int32_t, GetDisassemblySearch()->SearchDisassembly(type, searchString, startPosition, options)); }
	DllExport uint32_t __stdcall FindOccurrences(CpuType type, const char* searchString, DisassemblySearchOptions options, CodeLineData results[], uint32_t maxResultCount) { return WithDebugger(uint32_t, GetDisassemblySearch()->FindOccurrences(type, searchString, options, results, maxResultCount)); }
	DllExport void __stdcall SetTraceOptions(CpuType type, TraceLoggerOptions options) { WithToolVoid(GetTraceLogger(type), SetOptions(options)); }
	DllExport uint32_t __stdcall GetExecutionTrace(TraceRow output[], uint32_t startOffset, uint32_t lineCount) { return WithDebugger(uint32_t, GetExecutionTrace(output, startOffset, lineCount)); }
	DllExport void __stdcall ClearExecutionTrace() { WithDebugger(void, ClearExecutionTrace()); }
	DllExport void __stdcall StartLogTraceToFile(const char* filename) { WithDebugger(void, GetTraceLogFileSaver()->StartLogging(filename)); }
	DllExport void __stdcall StopLogTraceToFile() { WithDebugger(void, GetTraceLogFileSaver()->StopLogging()); }
	DllExport void __stdcall SetBreakpoints(Breakpoint breakpoints[], uint32_t length) { WithDebugger(void, SetBreakpoints(breakpoints, length)); }
	DllExport void __stdcall SetInputOverrides(uint32_t index, DebugControllerState state) { WithDebugger(void, SetInputOverrides(index, state)); }
	DllExport void __stdcall GetAvailableInputOverrides(uint8_t* availableIndexes) { WithDebugger(void, GetAvailableInputOverrides(availableIndexes)); }
	DllExport void __stdcall GetTokenList(CpuType cpuType, char* tokenList) { WithDebugger(void, GetTokenList(cpuType, tokenList)); }
	DllExport int64_t __stdcall EvaluateExpression(const char* expression, CpuType cpuType, EvalResultType* resultType, bool useCache) { return WithDebugger(int64_t, EvaluateExpression(expression, cpuType, *resultType, useCache)); }
	DllExport void __stdcall GetCallstack(CpuType cpuType, StackFrameInfo* callstackArray, uint32_t& callstackSize)
	{
		callstackSize = 0;
		WithToolVoid(GetCallstackManager(cpuType), GetCallstack(callstackArray, callstackSize));
	}
	DllExport void __stdcall GetProfilerData(CpuType cpuType, ProfiledFunction* profilerData, uint32_t& functionCount)
	{
		functionCount = 0;
		WithToolVoid(GetCallstackManager(cpuType), GetProfiler()->GetProfilerData(profilerData, functionCount));
	}
	DllExport void __stdcall ResetProfiler(CpuType cpuType) { WithToolVoid(GetCallstackManager(cpuType), GetProfiler()->Reset()); }
	DllExport void __stdcall GetConsoleState(BaseState& state, ConsoleType consoleType) { WithDebugger(void, GetConsoleState(state, consoleType)); }
	DllExport void __stdcall GetCpuState(BaseState& state, CpuType cpuType) { WithDebugger(void, GetCpuState(state, cpuType)); }
	DllExport void __stdcall GetPpuState(BaseState& state, CpuType cpuType) { WithDebugger(void, GetPpuState(state, cpuType)); }
	DllExport void __stdcall SetCpuState(BaseState& state, CpuType cpuType) { WithDebugger(void, SetCpuState(state, cpuType)); }
	DllExport void __stdcall SetPpuState(BaseState& state, CpuType cpuType) { WithDebugger(void, SetPpuState(state, cpuType)); }
	DllExport uint32_t __stdcall GetProgramCounter(CpuType cpuType, bool getInstPc) { return WithDebugger(uint32_t, GetProgramCounter(cpuType, getInstPc)); }
	DllExport void __stdcall SetProgramCounter(CpuType cpuType, uint32_t addr) { WithDebugger(void, SetProgramCounter(cpuType, addr)); }
	DllExport DebuggerFeatures __stdcall GetDebuggerFeatures(CpuType cpuType) { return WithDebugger(DebuggerFeatures, GetDebuggerFeatures(cpuType)); }
	DllExport CpuInstructionProgress __stdcall GetInstructionProgress(CpuType cpuType) { return WithDebugger(CpuInstructionProgress, GetInstructionProgress(cpuType)); }
	DllExport void __stdcall GetDebuggerLog(char* outBuffer, uint32_t maxLength)
	{
		string logString = WithDebugger(string, GetLog());
		StringUtilities::CopyToBuffer(logString, outBuffer, maxLength);
	}
	DllExport void __stdcall UpdateFrozenAddresses(CpuType cpuType, uint32_t start, uint32_t end, bool freeze) { return WithToolVoid(GetFrozenAddressManager(cpuType), UpdateFrozenAddresses(start, end, freeze)); }
	DllExport void __stdcall GetFrozenState(CpuType cpuType, uint32_t start, uint32_t end, bool* outState) { return WithToolVoid(GetFrozenAddressManager(cpuType), GetFrozenState(start, end, outState)); }
	DllExport void __stdcall SetMemoryState(MemoryType type, uint8_t* buffer, int32_t length) { WithDebugger(void, GetMemoryDumper()->SetMemoryState(type, buffer, length)); }
	DllExport uint32_t __stdcall GetMemorySize(MemoryType type) { return WithDebugger(uint32_t, GetMemoryDumper()->GetMemorySize(type)); }
	DllExport void __stdcall GetMemoryState(MemoryType type, uint8_t* buffer) { WithDebugger(void, GetMemoryDumper()->GetMemoryState(type, buffer)); }
	DllExport uint8_t __stdcall GetMemoryValue(MemoryType type, uint32_t address) { return WithDebugger(uint8_t, GetMemoryDumper()->GetMemoryValue(type, address)); }
	DllExport void __stdcall GetMemoryValues(MemoryType type, uint32_t start, uint32_t end, uint8_t* output) { WithDebugger(void, GetMemoryDumper()->GetMemoryValues(type, start, end, output)); }
	DllExport void __stdcall SetMemoryValue(MemoryType type, uint32_t address, uint8_t value) { WithDebugger(void, GetMemoryDumper()->SetMemoryValue(type, address, value)); }
	DllExport void __stdcall SetMemoryValues(MemoryType type, uint32_t address, uint8_t* data, int32_t length) { WithDebugger(void, GetMemoryDumper()->SetMemoryValues(type, address, data, length)); }
	DllExport bool __stdcall HasUndoHistory() { return WithDebugger(bool, GetMemoryDumper()->HasUndoHistory()); }
	DllExport void __stdcall PerformUndo() { WithDebugger(void, GetMemoryDumper()->PerformUndo()); }
	DllExport AddressInfo __stdcall GetAbsoluteAddress(AddressInfo relAddress) { return WithDebugger(AddressInfo, GetAbsoluteAddress(relAddress)); }
	DllExport AddressInfo __stdcall GetRelativeAddress(AddressInfo absAddress, CpuType cpuType) { return WithDebugger(AddressInfo, GetRelativeAddress(absAddress, cpuType)); }
	DllExport void __stdcall SetLabel(uint32_t address, MemoryType memType, char* label, char* comment) { WithDebugger(void, GetLabelManager()->SetLabel(address, memType, label, comment)); }
	DllExport void __stdcall ClearLabels() { WithDebugger(void, GetLabelManager()->ClearLabels()); }
	DllExport void __stdcall ResetMemoryAccessCounts() { WithDebugger(void, GetMemoryAccessCounter()->ResetCounts()); }
	DllExport void __stdcall GetMemoryAccessCounts(uint32_t offset, uint32_t length, MemoryType memoryType, AddressCounters* counts) { WithDebugger(void, GetMemoryAccessCounter()->GetAccessCounts(offset, length, memoryType, counts)); }
	DllExport CdlStatistics __stdcall GetCdlStatistics(MemoryType memoryType) { return WithDebugger(CdlStatistics, GetCdlManager()->GetCdlStatistics(memoryType)); }
	DllExport uint32_t __stdcall GetCdlFunctions(MemoryType memoryType, uint32_t functions[], uint32_t maxSize) { return WithDebugger(uint32_t, GetCdlManager()->GetCdlFunctions(memoryType, functions, maxSize)); }
	DllExport void __stdcall ResetCdl(MemoryType memoryType) { WithDebugger(void, GetCdlManager()->ResetCdl(memoryType)); }
	DllExport void __stdcall SaveCdlFile(MemoryType memoryType, char* cdlFile) { WithDebugger(void, GetCdlManager()->SaveCdlFile(memoryType, cdlFile)); }
	DllExport void __stdcall LoadCdlFile(MemoryType memoryType, char* cdlFile) { WithDebugger(void, GetCdlManager()->LoadCdlFile(memoryType, cdlFile)); }
	DllExport void __stdcall GetCdlData(uint32_t offset, uint32_t length, MemoryType memoryType, uint8_t* cdlData) { WithDebugger(void, GetCdlManager()->GetCdlData(offset, length, memoryType, cdlData)); }
	DllExport void __stdcall SetCdlData(MemoryType memoryType, uint8_t* cdlData, uint32_t length) { WithDebugger(void, GetCdlManager()->SetCdlData(memoryType, cdlData, length)); }
	DllExport void __stdcall MarkBytesAs(MemoryType memoryType, uint32_t start, uint32_t end, uint8_t flags) { WithDebugger(void, GetCdlManager()->MarkBytesAs(memoryType, start, end, flags)); }
	DllExport void __stdcall GetTileView(CpuType cpuType, GetTileViewOptions options, uint8_t* source, uint32_t srcSize, uint32_t* colors, uint32_t* buffer) { WithToolVoid(GetPpuTools(cpuType), GetTileView(options, source, srcSize, colors, buffer)); }
	DllExport void __stdcall GetPpuToolsState(CpuType cpuType, BaseState& state) { return WithToolVoid(GetPpuTools(cpuType), GetPpuToolsState(state)); }
	DllExport DebugTilemapInfo __stdcall GetTilemap(CpuType cpuType, GetTilemapOptions options, BaseState& state, BaseState& ppuToolsState, uint8_t* vram, uint32_t* palette, uint32_t* outputBuffer) { return WithTool(DebugTilemapInfo, GetPpuTools(cpuType), GetTilemap(options, state, ppuToolsState, vram, palette, outputBuffer)); }
	DllExport FrameInfo __stdcall GetTilemapSize(CpuType cpuType, GetTilemapOptions options, BaseState& state) { return WithTool(FrameInfo, GetPpuTools(cpuType), GetTilemapSize(options, state)); }
	DllExport DebugTilemapTileInfo __stdcall GetTilemapTileInfo(uint32_t x, uint32_t y, CpuType cpuType, GetTilemapOptions options, uint8_t* vram, BaseState& state, BaseState& ppuToolsState) { return WithTool(DebugTilemapTileInfo, GetPpuTools(cpuType), GetTilemapTileInfo(x, y, vram, options, state, ppuToolsState)); }
	DllExport DebugSpritePreviewInfo __stdcall GetSpritePreviewInfo(CpuType cpuType, GetSpritePreviewOptions options, BaseState& state, BaseState& ppuToolsState) { return WithTool(DebugSpritePreviewInfo, GetPpuTools(cpuType), GetSpritePreviewInfo(options, state, ppuToolsState)); }
	DllExport void __stdcall GetSpriteList(CpuType cpuType, GetSpritePreviewOptions options, BaseState& state, BaseState& ppuToolsState, uint8_t* vram, uint8_t* oamRam, uint32_t* palette, DebugSpriteInfo sprites[], uint32_t* spritePreviews, uint32_t* screenPreview) { WithToolVoid(GetPpuTools(cpuType), GetSpriteList(options, state, ppuToolsState, vram, oamRam, palette, sprites, spritePreviews, screenPreview)); }
	DllExport DebugPaletteInfo __stdcall GetPaletteInfo(CpuType cpuType, GetPaletteInfoOptions options) { return WithTool(DebugPaletteInfo, GetPpuTools(cpuType), GetPaletteInfo(options)); }
	DllExport void __stdcall SetPaletteColor(CpuType cpuType, int32_t colorIndex, uint32_t color) { WithToolVoid(GetPpuTools(cpuType), SetPaletteColor(colorIndex, color)); }
	DllExport int32_t __stdcall GetTilePixel(AddressInfo tileAddress, TileFormat format, int32_t x, int32_t y) { return WithTool(int32_t, GetPpuTools(DebugUtilities::ToCpuType(tileAddress.Type)), GetTilePixel(tileAddress, format, x, y)); }
	DllExport void __stdcall SetTilePixel(AddressInfo tileAddress, TileFormat format, int32_t x, int32_t y, int32_t color) { WithToolVoid(GetPpuTools(DebugUtilities::ToCpuType(tileAddress.Type)), SetTilePixel(tileAddress, format, x, y, color)); }
	DllExport void __stdcall SetViewerUpdateTiming(uint32_t viewerId, uint16_t scanline, uint16_t cycle, CpuType cpuType) { WithToolVoid(GetPpuTools(cpuType), SetViewerUpdateTiming(viewerId, scanline, cycle)); }
	DllExport void __stdcall RemoveViewerId(uint32_t viewerId, CpuType cpuType) { WithToolVoid(GetPpuTools(cpuType), RemoveViewer(viewerId)); }
	DllExport void __stdcall SetEventViewerConfig(CpuType cpuType, BaseEventViewerConfig& config) { WithToolVoid(GetEventManager(cpuType), SetConfiguration(config)); }
	DllExport void __stdcall GetDebugEvents(CpuType cpuType, DebugEventInfo* infoArray, uint32_t& maxEventCount) { WithToolVoid(GetEventManager(cpuType), GetEvents(infoArray, maxEventCount)); }
	DllExport uint32_t __stdcall GetDebugEventCount(CpuType cpuType) { return WithTool(uint32_t, GetEventManager(cpuType), GetEventCount()); }
	DllExport FrameInfo __stdcall GetEventViewerDisplaySize(CpuType cpuType) { return WithTool(FrameInfo, GetEventManager(cpuType), GetDisplayBufferSize()); }
	DllExport void __stdcall GetEventViewerOutput(CpuType cpuType, uint32_t* buffer, uint32_t bufferSize) { WithToolVoid(GetEventManager(cpuType), GetDisplayBuffer(buffer, bufferSize)); }
	DllExport DebugEventInfo __stdcall GetEventViewerEvent(CpuType cpuType, uint16_t scanline, uint16_t cycle) { return WithTool(DebugEventInfo, GetEventManager(cpuType), GetEvent(scanline, cycle)); }
	DllExport uint32_t __stdcall TakeEventSnapshot(CpuType cpuType, bool forAutoRefresh) { return WithTool(uint32_t, GetEventManager(cpuType), TakeEventSnapshot(forAutoRefresh)); }
	DllExport int32_t __stdcall LoadScript(char* name, char* path, char* content, int32_t scriptId) { return WithTool(int32_t, GetScriptManager(), LoadScript(name, path, content, scriptId)); }
	DllExport void __stdcall RemoveScript(int32_t scriptId) { WithToolVoid(GetScriptManager(), RemoveScript(scriptId)); }
	DllExport void __stdcall GetScriptLog(int32_t scriptId, char* outScriptLog, uint32_t maxLength)
	{
		string log = WithTool(string, GetScriptManager(), GetScriptLog(scriptId));
		StringUtilities::CopyToBuffer(log, outScriptLog, maxLength);
	}
	DllExport uint32_t __stdcall AssembleCode(CpuType cpuType, char* code, uint32_t startAddress, int16_t* assembledOutput) { return WithTool(uint32_t, GetAssembler(cpuType), AssembleCode(code, startAddress, assembledOutput)); }
	DllExport void __stdcall GetRomHeader(uint8_t* headerData, uint32_t& size) { WithToolVoid(GetMainDebugger(), GetRomHeader(headerData, size)); }
	DllExport bool __stdcall SaveRomToDisk(char* filename, bool saveIpsFile, CdlStripOption cdlStripOption) { return WithDebugger(bool, SaveRomToDisk(filename, saveIpsFile, cdlStripOption)); }
};
```

## File: InteropDLL/EmuApiWrapper.cpp
```cpp
#include "Common.h"
#include "Core/Shared/Emulator.h"
#include "Core/Shared/EmuSettings.h"
#include "Core/Shared/Video/VideoDecoder.h"
#include "Core/Shared/Video/VideoRenderer.h"
#include "Core/Shared/SystemActionManager.h"
#include "Core/Shared/MessageManager.h"
#include "Core/Shared/SaveStateManager.h"
#include "Core/Shared/Interfaces/INotificationListener.h"
#include "Core/Shared/KeyManager.h"
#include "Core/Shared/ShortcutKeyHandler.h"
#include "Core/Shared/TimingInfo.h"
#include "Core/Shared/CheatManager.h"
#include "Core/Shared/DebuggerRequest.h"
#include "Core/Netplay/GameClient.h"
#include "Core/Netplay/GameServer.h"
#include "Utilities/ArchiveReader.h"
#include "Utilities/FolderUtilities.h"
#include "Utilities/StringUtilities.h"
#include "InteropNotificationListeners.h"
#ifdef _WIN32
	#include "Windows/Renderer.h"
	#include "Windows/SoundManager.h"
	#include "Windows/WindowsKeyManager.h"
	#include "Windows/WindowsMouseManager.h"
#elif __APPLE__
	#include "Sdl/SdlSoundManager.h"
	#include "MacOS/MacOSKeyManager.h"
	#include "MacOS/MacOSMouseManager.h"
#else
	#include "Sdl/SdlRenderer.h"
	#include "Sdl/SdlSoundManager.h"
	#include "Linux/LinuxKeyManager.h"
	#include "Linux/LinuxMouseManager.h"
#endif
#include "Shared/Video/SoftwareRenderer.h"
unique_ptr<IRenderingDevice> _renderer;
unique_ptr<IAudioDevice> _soundManager;
unique_ptr<IKeyManager> _keyManager;
unique_ptr<IMouseManager> _mouseManager;
unique_ptr<Emulator> _emu(new Emulator());
bool _softwareRenderer = false;
static void* _windowHandle = nullptr;
static void* _viewerHandle = nullptr;
static constexpr char* _buildDateTime = __DATE__ ", " __TIME__;
static InteropNotificationListeners _listeners;
struct InteropRomInfo
{
	char RomPath[2000];
	char PatchPath[2000];
	RomFormat Format;
	ConsoleType Console;
	DipSwitchInfo DipSwitches;
	CpuType CpuTypes[5];
	uint32_t CpuTypeCount;
};
extern "C" {
	DllExport bool __stdcall TestDll()
	{
		return true;
	}
	DllExport uint32_t __stdcall GetMesenVersion() { return _emu->GetSettings()->GetVersion(); }
	DllExport char* __stdcall GetMesenBuildDate() { return _buildDateTime; }
	DllExport void __stdcall InitDll()
	{
		_emu->Initialize();
		KeyManager::SetSettings(_emu->GetSettings());
	}
	DllExport void __stdcall InitializeEmu(const char* homeFolder, void *windowHandle, void *viewerHandle, bool softwareRenderer, bool noAudio, bool noVideo, bool noInput)
	{
		FolderUtilities::SetHomeFolder(homeFolder);
		if(windowHandle != nullptr && viewerHandle != nullptr) {
			_windowHandle = windowHandle;
			_viewerHandle = viewerHandle;
			_softwareRenderer = softwareRenderer;
			if(!noVideo) {
				if(softwareRenderer) {
					_renderer.reset(new SoftwareRenderer(_emu.get()));
				} else {
					#ifdef _WIN32
						_renderer.reset(new Renderer(_emu.get(), (HWND)_viewerHandle));
					#elif __APPLE__
						_renderer.reset(new SoftwareRenderer(_emu.get()));
					#else
						_renderer.reset(new SdlRenderer(_emu.get(), _viewerHandle));
					#endif
				}
			}
			if(!noAudio) {
				#ifdef _WIN32
					_soundManager.reset(new SoundManager(_emu.get(), (HWND)_windowHandle));
				#else
					_soundManager.reset(new SdlSoundManager(_emu.get()));
				#endif
			}
			if(!noInput) {
				#ifdef _WIN32
					_keyManager.reset(new WindowsKeyManager(_emu.get(), (HWND)_windowHandle));
					_mouseManager.reset(new WindowsMouseManager());
				#elif __APPLE__
					_keyManager.reset(new MacOSKeyManager(_emu.get()));
					_mouseManager.reset(new MacOSMouseManager());
				#else
					_keyManager.reset(new LinuxKeyManager(_emu.get()));
					_mouseManager.reset(new LinuxMouseManager(_windowHandle));
				#endif
				KeyManager::RegisterKeyManager(_keyManager.get());
			}
		}
	}
	DllExport void __stdcall SetExclusiveFullscreenMode(bool fullscreen, void *windowHandle)
	{
		if(_renderer) {
			_renderer->SetExclusiveFullscreenMode(fullscreen, windowHandle);
		}
	}
	DllExport bool __stdcall LoadRom(char* filename, char* patchFile)
	{
		_emu->GetGameClient()->Disconnect();
		return _emu->LoadRom((VirtualFile)filename, patchFile ? (VirtualFile)patchFile : VirtualFile());
	}
	DllExport void __stdcall AddKnownGameFolder(char* folder) { FolderUtilities::AddKnownGameFolder(folder); }
	DllExport void __stdcall GetRomInfo(InteropRomInfo &info)
	{
		RomInfo romInfo = _emu->GetRomInfo();
		string romPath = romInfo.RomFile;
		string patchPath = romInfo.PatchFile;
		memset(info.RomPath, 0, sizeof(info.RomPath));
		memset(info.PatchPath, 0, sizeof(info.PatchPath));
		memcpy(info.RomPath, romPath.c_str(), romPath.size());
		memcpy(info.PatchPath, patchPath.c_str(), patchPath.size());
		info.Format = romInfo.Format;
		info.Console = _emu->GetConsoleType();
		info.DipSwitches = romInfo.DipSwitches;
		vector<CpuType> cpuTypes = _emu->GetCpuTypes();
		info.CpuTypeCount = std::min<uint32_t>((uint32_t)cpuTypes.size(), 5);
		for(size_t i = 0; i < 5 && i < cpuTypes.size(); i++) {
			info.CpuTypes[i] = cpuTypes[i];
		}
	}
	DllExport TimingInfo __stdcall GetTimingInfo(CpuType cpuType)
	{
		return _emu->GetTimingInfo(cpuType);
	}
	DllExport void __stdcall TakeScreenshot() { _emu->GetVideoDecoder()->TakeScreenshot(); }
	DllExport void __stdcall ProcessAudioPlayerAction(AudioPlayerActionParams p) { _emu->ProcessAudioPlayerAction(p); }
	DllExport void __stdcall GetArchiveRomList(char* filename, char* outBuffer, uint32_t maxLength) {
		std::ostringstream out;
		unique_ptr<ArchiveReader> reader = ArchiveReader::GetReader(filename);
		if(reader) {
			for(string romName : reader->GetFileList(VirtualFile::RomExtensions)) {
				out << romName << "[!|!]";
			}
		}
		StringUtilities::CopyToBuffer(out.str(), outBuffer, maxLength);
	}
	DllExport bool __stdcall IsRunning()
	{
		return _emu->IsRunning();
	}
	DllExport int32_t __stdcall GetStopCode()
	{
		return _emu->GetStopCode();
	}
	DllExport void __stdcall Stop()
	{
		_emu->GetGameClient()->Disconnect();
		_emu->Stop(true);
	}
	DllExport void __stdcall Pause()
	{
		if(!_emu->GetGameClient()->Connected()) {
			_emu->Pause();
		}
	}
	DllExport void __stdcall Resume()
	{
		if(!_emu->GetGameClient()->Connected()) {
			_emu->Resume();
		}
	}
	DllExport bool __stdcall IsPaused()
	{
		return _emu->IsPaused();
	}
	DllExport void __stdcall Release()
	{
		if(_emu) {
			_emu->Stop(true);
			_emu->Release();
		}
		_renderer.reset();
		_soundManager.reset();
		_keyManager.reset();
		_emu.reset();
	}
	DllExport INotificationListener* __stdcall RegisterNotificationCallback(NotificationListenerCallback callback)
	{
		return _listeners.RegisterNotificationCallback(callback, _emu.get());
	}
	DllExport void __stdcall UnregisterNotificationCallback(INotificationListener *listener)
	{
		_listeners.UnregisterNotificationCallback(listener);
	}
	DllExport void __stdcall DisplayMessage(char* title, char* message, char* param1) { MessageManager::DisplayMessage(title, message, param1 ? param1 : ""); }
	DllExport void __stdcall GetLog(char* outBuffer, uint32_t maxLength)
	{
		StringUtilities::CopyToBuffer(MessageManager::GetLog(), outBuffer, maxLength);
	}
	DllExport void __stdcall SetRendererSize(uint32_t width, uint32_t height)
	{
		if(_emu->GetVideoRenderer()) {
			_emu->GetVideoRenderer()->SetRendererSize(width, height);
		}
	}
	DllExport double __stdcall GetAspectRatio()
	{
		return _emu->GetSettings()->GetAspectRatio(_emu->GetRegion(), _emu->GetVideoDecoder()->GetBaseFrameInfo(true));
	}
	DllExport FrameInfo __stdcall GetBaseScreenSize()
	{
		if(_emu->GetVideoDecoder()) {
			return _emu->GetVideoDecoder()->GetBaseFrameInfo(true);
		}
		return { 256, 240 };
	}
	DllExport uint32_t __stdcall GetGameMemorySize(MemoryType type) { return _emu->GetMemory(type).Size; }
	DllExport void __stdcall ClearCheats() { _emu->GetCheatManager()->ClearCheats(); }
	DllExport void __stdcall SetCheats(CheatCode codes[], uint32_t length) { _emu->GetCheatManager()->SetCheats(codes, length); }
	DllExport bool __stdcall GetConvertedCheat(CheatCode input, InternalCheatCode& output) { return _emu->GetCheatManager()->GetConvertedCheat(input, output); }
	DllExport void __stdcall GetRomHash(HashType hashType, char* outBuffer, uint32_t maxLength)
	{
		StringUtilities::CopyToBuffer(_emu->GetHash(hashType), outBuffer, maxLength);
	}
	DllExport void __stdcall InputBarcode(uint64_t barcode, uint32_t digitCount) { _emu->InputBarcode(barcode, digitCount); }
	DllExport void __stdcall ProcessTapeRecorderAction(TapeRecorderAction action, char* filename) { _emu->ProcessTapeRecorderAction(action, filename); }
	DllExport void __stdcall ExecuteShortcut(ExecuteShortcutParams params) { _emu->GetNotificationManager()->SendNotification(ConsoleNotificationType::ExecuteShortcut, &params); }
	DllExport bool __stdcall IsShortcutAllowed(EmulatorShortcut shortcut, uint32_t shortcutParam) { return _emu->GetShortcutKeyHandler()->IsShortcutAllowed(shortcut, shortcutParam); }
	DllExport void __stdcall WriteLogEntry(char* message) { MessageManager::Log(message); }
	DllExport void __stdcall SaveState(uint32_t stateIndex) { _emu->GetSaveStateManager()->SaveState(stateIndex); }
	DllExport void __stdcall LoadState(uint32_t stateIndex) { _emu->GetSaveStateManager()->LoadState(stateIndex); }
	DllExport void __stdcall SaveStateFile(char* filepath) { _emu->GetSaveStateManager()->SaveState(filepath); }
	DllExport void __stdcall LoadStateFile(char* filepath) { _emu->GetSaveStateManager()->LoadState(filepath); }
	DllExport void __stdcall LoadRecentGame(char* filepath, bool resetGame) { _emu->GetSaveStateManager()->LoadRecentGame(filepath, resetGame); }
	DllExport int32_t __stdcall GetSaveStatePreview(char* saveStatePath, uint8_t* pngData) { return _emu->GetSaveStateManager()->GetSaveStatePreview(saveStatePath, pngData); }
	class PgoKeyManager : public IKeyManager
	{
	public:
		void RefreshState() {}
		void UpdateDevices() {}
		bool IsMouseButtonPressed(MouseButton button) { return false; }
		bool IsKeyPressed(uint16_t keyCode) { return keyCode == 10 && (_emu->GetFrameCount() % 7) <= 3; }
		vector<uint16_t> GetPressedKeys() { return {}; }
		string GetKeyName(uint16_t keyCode) { return ""; }
		uint16_t GetKeyCode(string keyName) { return 0; }
		bool SetKeyState(uint16_t scanCode, bool state) { return false; }
		void ResetKeyState() {}
		void SetDisabled(bool disabled) {}
	};
	DllExport void __stdcall PgoRunTest(vector<string> testRoms, bool enableDebugger)
	{
		FolderUtilities::SetHomeFolder("../PGOMesenHome");
		PgoKeyManager pgoKeyManager;
		KeyManager::RegisterKeyManager(&pgoKeyManager);
		for(size_t i = 0; i < testRoms.size(); i++) {
			std::cout << "Running: " << testRoms[i] << std::endl;
			KeyManager::SetSettings(_emu->GetSettings());
			_emu->Initialize();
			NesConfig& nesCfg = _emu->GetSettings()->GetNesConfig();
			nesCfg.Port1.Type = ControllerType::NesController;
			nesCfg.Port1.Keys.Mapping1.Start = 10;
			SnesConfig& snesCfg = _emu->GetSettings()->GetSnesConfig();
			snesCfg.Port1.Type = ControllerType::SnesController;
			snesCfg.Port1.Keys.Mapping1.Start = 10;
			GameboyConfig& gbCfg = _emu->GetSettings()->GetGameboyConfig();
			gbCfg.Model = GameboyModel::GameboyColor;
			gbCfg.Controller.Keys.Mapping1.Start = 10;
			PcEngineConfig& pceCfg = _emu->GetSettings()->GetPcEngineConfig();
			pceCfg.Port1.Type = ControllerType::PceController;
			pceCfg.Port1.Keys.Mapping1.Start = 10;
			_emu->GetSettings()->SetFlag(EmulationFlags::MaximumSpeed);
			_emu->LoadRom((VirtualFile)testRoms[i], VirtualFile());
			if(enableDebugger) {
				_emu->GetDebugger(true);
			}
			std::this_thread::sleep_for(std::chrono::duration<int, std::milli>(5000));
			std::cout << "Ran for " << _emu->GetFrameCount() << " frames" << std::endl;
			_emu->Stop(false);
			_emu->Release();
		}
	}
}
```

## File: InteropDLL/HistoryApiWrapper.cpp
```cpp
#include "Common.h"
#include "Core/Shared/Emulator.h"
#include "Core/Shared/EmuSettings.h"
#include "Core/Shared/RewindManager.h"
#include "Core/Shared/HistoryViewer.h"
#include "Core/Shared/Interfaces/IRenderingDevice.h"
#include "Core/Shared/Interfaces/IAudioDevice.h"
#include "Core/Shared/Video/VideoRenderer.h"
#include "Core/Shared/Audio/SoundMixer.h"
#include "Core/Shared/Movies/MovieManager.h"
#include "Shared/Video/SoftwareRenderer.h"
#include "InteropNotificationListeners.h"
#ifdef _WIN32
	#include "Windows/Renderer.h"
	#include "Windows/SoundManager.h"
#elif __APPLE__
	#include "Sdl/SdlSoundManager.h"
#else
	#include "Sdl/SdlRenderer.h"
	#include "Sdl/SdlSoundManager.h"
#endif
extern unique_ptr<Emulator> _emu;
extern bool _softwareRenderer;
unique_ptr<Emulator> _historyPlayer;
unique_ptr<IRenderingDevice> _historyRenderer;
unique_ptr<IAudioDevice> _historySoundManager;
HistoryViewer* _historyViewer = nullptr;
static InteropNotificationListeners _listeners;
extern "C"
{
	DllExport bool __stdcall HistoryViewerEnabled()
	{
		return _emu->GetRewindManager()->HasHistory();
	}
	DllExport void __stdcall HistoryViewerRelease()
	{
		_historyPlayer->Release();
		_historyRenderer.reset();
		_historySoundManager.reset();
		_historyPlayer.reset();
		_historyViewer = nullptr;
	}
	DllExport void __stdcall HistoryViewerInitialize(void* windowHandle, void* viewerHandle)
	{
		_historyPlayer.reset(new Emulator());
		_historyPlayer->Initialize();
		_historyPlayer->GetSettings()->CopySettings(*_emu->GetSettings());
		_historyViewer = _historyPlayer->GetHistoryViewer();
		if(!_historyViewer->Initialize(_emu.get())) {
			HistoryViewerRelease();
			return;
		}
		_historyPlayer->GetSettings()->GetEmulationConfig().EmulationSpeed = 100;
		if(_softwareRenderer) {
			_historyRenderer.reset(new SoftwareRenderer(_historyPlayer.get()));
		} else {
			#ifdef _WIN32
				_historyRenderer.reset(new Renderer(_historyPlayer.get(), (HWND)viewerHandle));
			#elif __APPLE__
				_historyRenderer.reset(new SoftwareRenderer(_historyPlayer.get()));
			#else
				_historyRenderer.reset(new SdlRenderer(_historyPlayer.get(), viewerHandle));
			#endif
		}
		#ifdef _WIN32
			_historySoundManager.reset(new SoundManager(_historyPlayer.get(), (HWND)windowHandle));
		#elif __APPLE__
			_historySoundManager.reset(new SdlSoundManager(_historyPlayer.get()));
		#else
			_historySoundManager.reset(new SdlSoundManager(_historyPlayer.get()));
		#endif
	}
	DllExport HistoryViewerState __stdcall HistoryViewerGetState()
	{
		return _historyViewer ? _historyViewer->GetState() : HistoryViewerState {};
	}
	DllExport void __stdcall HistoryViewerSetOptions(HistoryViewerOptions options)
	{
		if(_historyViewer) {
			_historyViewer->SetOptions(options);
		}
	}
	DllExport bool __stdcall HistoryViewerCreateSaveState(const char* outputFile, uint32_t position)
	{
		return _historyViewer ? _historyViewer->CreateSaveState(outputFile, position) : false;
	}
	DllExport bool __stdcall HistoryViewerSaveMovie(const char* movieFile, uint32_t startPosition, uint32_t endPosition)
	{
		return _historyViewer ? _historyViewer->SaveMovie(movieFile, startPosition, endPosition) : false;
	}
	DllExport void __stdcall HistoryViewerResumeGameplay(uint32_t resumePosition)
	{
		if(_historyViewer) {
			_historyViewer->ResumeGameplay(resumePosition);
		}
	}
	DllExport void __stdcall HistoryViewerSetPosition(uint32_t seekPosition)
	{
		if(_historyViewer) {
			_historyViewer->SeekTo(seekPosition);
		}
	}
	DllExport INotificationListener* __stdcall HistoryViewerRegisterNotificationCallback(NotificationListenerCallback callback)
	{
		return _listeners.RegisterNotificationCallback(callback, _historyPlayer.get());
	}
	DllExport void __stdcall HistoryViewerUnregisterNotificationCallback(INotificationListener* listener)
	{
		_listeners.UnregisterNotificationCallback(listener);
	}
}
```

## File: InteropDLL/InputApiWrapper.cpp
```cpp
#include "Common.h"
#include "Core/Shared/Emulator.h"
#include "Core/Shared/BaseControlManager.h"
#include "Core/Shared/KeyManager.h"
#include "Core/Shared/ShortcutKeyHandler.h"
#include "Utilities/StringUtilities.h"
#include "Core/Shared/Interfaces/IMouseManager.h"
extern unique_ptr<IKeyManager> _keyManager;
extern unique_ptr<IMouseManager> _mouseManager;
extern unique_ptr<Emulator> _emu;
extern "C"
{
	DllExport void __stdcall SetMousePosition(double x, double y)
	{
		KeyManager::SetMousePosition(_emu.get(), x, y);
	}
	DllExport void __stdcall SetMouseMovement(int16_t x, int16_t y)
	{
		KeyManager::SetMouseMovement(x, y);
	}
	DllExport void __stdcall UpdateInputDevices()
	{
		if(_keyManager) {
			_keyManager->UpdateDevices();
		}
	}
	DllExport void __stdcall GetPressedKeys(uint16_t* keyBuffer)
	{
		vector<uint16_t> pressedKeys = KeyManager::GetPressedKeys();
		for(size_t i = 0; i < pressedKeys.size() && i < 3; i++) {
			keyBuffer[i] = pressedKeys[i];
		}
	}
	DllExport void __stdcall DisableAllKeys(bool disabled)
	{
		if(_keyManager) {
			_keyManager->SetDisabled(disabled);
		}
	}
	DllExport void __stdcall SetKeyState(uint16_t scanCode, bool state)
	{
		if(_keyManager) {
			if(_keyManager->SetKeyState(scanCode, state)) {
				_emu->GetShortcutKeyHandler()->ProcessKeys();
			}
		}
	}
	DllExport void __stdcall ResetKeyState()
	{
		if(_keyManager) {
			_keyManager->ResetKeyState();
		}
	}
	DllExport void __stdcall GetKeyName(uint16_t keyCode, char* outKeyName, uint32_t maxLength)
	{
		StringUtilities::CopyToBuffer(KeyManager::GetKeyName(keyCode), outKeyName, maxLength);
	}
	DllExport uint16_t __stdcall GetKeyCode(char* keyName)
	{
		if(keyName) {
			return KeyManager::GetKeyCode(keyName);
		} else {
			return 0;
		}
	}
	DllExport bool __stdcall HasControlDevice(ControllerType type)
	{
		return _emu->HasControlDevice(type);
	}
	DllExport void __stdcall ResetLagCounter()
	{
		_emu->ResetLagCounter();
	}
	DllExport SystemMouseState __stdcall GetSystemMouseState(void* rendererHandle)
	{
		if(_mouseManager) {
			return _mouseManager->GetSystemMouseState(rendererHandle);
		}
		SystemMouseState state = {};
		return state;
	}
	DllExport bool __stdcall CaptureMouse(int32_t x, int32_t y, int32_t width, int32_t height, void* rendererHandle)
	{
		if(_mouseManager) {
			return _mouseManager->CaptureMouse(x, y, width, height, rendererHandle);
		}
		return false;
	}
	DllExport void __stdcall ReleaseMouse()
	{
		if(_mouseManager) {
			_mouseManager->ReleaseMouse();
		}
	}
	DllExport void __stdcall SetSystemMousePosition(int32_t x, int32_t y)
	{
		if(_mouseManager) {
			_mouseManager->SetSystemMousePosition(x, y);
		}
	}
	DllExport void __stdcall SetCursorImage(CursorImage image)
	{
		if(_mouseManager) {
			_mouseManager->SetCursorImage(image);
		}
	}
	DllExport double __stdcall GetPixelScale()
	{
		if(_mouseManager) {
			return _mouseManager->GetPixelScale();
		}
		return 1.0;
	}
}
```

## File: InteropDLL/InteropDLL.vcxproj
```
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="PGO Optimize|x64">
      <Configuration>PGO Optimize</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="PGO Profile|x64">
      <Configuration>PGO Profile</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{37749BB2-FA78-4EC9-8990-5628FC0BBA19}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>InteropDLL</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='PGO Profile|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='PGO Optimize|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='PGO Profile|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='PGO Optimize|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <TargetName>MesenCore</TargetName>
    <OutDir>$(SolutionDir)\bin\win-$(PlatformTarget)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
    <EnableMicrosoftCodeAnalysis>false</EnableMicrosoftCodeAnalysis>
    <IncludePath>$(SolutionDir)/Core;$(SolutionDir);$(ProjectDir);$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <TargetName>MesenCore</TargetName>
    <OutDir>$(SolutionDir)\bin\win-$(PlatformTarget)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
    <EnableMicrosoftCodeAnalysis>false</EnableMicrosoftCodeAnalysis>
    <IncludePath>$(SolutionDir)/Core;$(SolutionDir);$(ProjectDir);$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='PGO Profile|x64'">
    <LinkIncremental>false</LinkIncremental>
    <TargetName>MesenCore</TargetName>
    <OutDir>$(SolutionDir)\bin\win-$(PlatformTarget)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
    <EnableMicrosoftCodeAnalysis>false</EnableMicrosoftCodeAnalysis>
    <IncludePath>$(SolutionDir)/Core;$(SolutionDir);$(ProjectDir);$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='PGO Optimize|x64'">
    <LinkIncremental>false</LinkIncremental>
    <TargetName>MesenCore</TargetName>
    <OutDir>$(SolutionDir)\bin\win-$(PlatformTarget)\PGO Profile\</OutDir>
    <IntDir>obj\$(Platform)\PGO Profile\</IntDir>
    <EnableMicrosoftCodeAnalysis>false</EnableMicrosoftCodeAnalysis>
    <IncludePath>$(SolutionDir)/Core;$(SolutionDir);$(ProjectDir);$(IncludePath)</IncludePath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;INTEROPDLL_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <CallingConvention>Cdecl</CallingConvention>
      <AdditionalIncludeDirectories>
      </AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <MinimalRebuild>false</MinimalRebuild>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>dinput8.lib;Xinput9_1_0.lib;d3d11.lib;d3dcompiler.lib;dxguid.lib;winmm.lib;comctl32.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(OutDir);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalOptions>/ignore:4099 %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;INTEROPDLL_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>
      </AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <WholeProgramOptimization>true</WholeProgramOptimization>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>dinput8.lib;Xinput9_1_0.lib;d3d11.lib;d3dcompiler.lib;dxguid.lib;winmm.lib;comctl32.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(OutDir);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalOptions>/ignore:4099 %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='PGO Profile|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>PGO;WIN32;NDEBUG;_WINDOWS;_USRDLL;INTEROPDLL_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>
      </AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <WholeProgramOptimization>true</WholeProgramOptimization>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>dinput8.lib;Xinput9_1_0.lib;d3d11.lib;d3dcompiler.lib;dxguid.lib;winmm.lib;comctl32.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;</AdditionalDependencies>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <AdditionalLibraryDirectories>$(OutDir);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalOptions>/ignore:4099 /GENPROFILE:NOPATH %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='PGO Optimize|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>PGO;WIN32;NDEBUG;_WINDOWS;_USRDLL;INTEROPDLL_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>
      </AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>dinput8.lib;Xinput9_1_0.lib;d3d11.lib;d3dcompiler.lib;dxguid.lib;winmm.lib;comctl32.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;</AdditionalDependencies>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <AdditionalLibraryDirectories>$(OutDir);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalOptions>/ignore:4099 /USEPROFILE %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="InteropNotificationListeners.h" />
    <ClInclude Include="InteropNotificationListener.h" />
    <ClInclude Include="Common.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="ConfigApiWrapper.cpp" />
    <ClCompile Include="EmuApiWrapper.cpp" />
    <ClCompile Include="DebugApiWrapper.cpp" />
    <ClCompile Include="HistoryApiWrapper.cpp" />
    <ClCompile Include="InputApiWrapper.cpp" />
    <ClCompile Include="NetplayApiWrapper.cpp" />
    <ClCompile Include="RecordApiWrapper.cpp" />
    <ClCompile Include="TestApiWrapper.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\Core\Core.vcxproj">
      <Project>{78fef1a1-6df1-4cbb-a373-ae6fa7ce5ce0}</Project>
    </ProjectReference>
    <ProjectReference Include="..\Lua\Lua.vcxproj">
      <Project>{b609e0a0-5050-4871-91d6-e760633bcdd1}</Project>
    </ProjectReference>
    <ProjectReference Include="..\SevenZip\SevenZip.vcxproj">
      <Project>{52c4ba3a-e699-4305-b23f-c9083fd07ab6}</Project>
    </ProjectReference>
    <ProjectReference Include="..\Utilities\Utilities.vcxproj">
      <Project>{b5330148-e8c7-46ba-b54e-69be59ea337d}</Project>
    </ProjectReference>
    <ProjectReference Include="..\Windows\Windows.vcxproj">
      <Project>{7761e790-b42c-4179-8550-8365ff9eb23e}</Project>
    </ProjectReference>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

## File: InteropDLL/InteropNotificationListener.h
```
#pragma once
#include "pch.h"
#include "Core/Shared/Interfaces/INotificationListener.h"
#include "Core/Shared/NotificationManager.h"
typedef void(__stdcall *NotificationListenerCallback)(int, void*);
class InteropNotificationListener : public INotificationListener
{
	NotificationListenerCallback _callback;
public:
	InteropNotificationListener(NotificationListenerCallback callback)
	{
		_callback = callback;
	}
	virtual ~InteropNotificationListener()
	{
	}
	void ProcessNotification(ConsoleNotificationType type, void* parameter)
	{
		_callback((int)type, parameter);
	}
};
```

## File: InteropDLL/InteropNotificationListeners.h
```
#pragma once
#include "pch.h"
#include "Core/Shared/Interfaces/INotificationListener.h"
#include "Core/Shared/NotificationManager.h"
#include "Core/Shared/Emulator.h"
#include "Utilities/SimpleLock.h"
#include "InteropNotificationListener.h"
typedef void(__stdcall *NotificationListenerCallback)(int, void*);
class InteropNotificationListeners
{
	SimpleLock _externalNotificationListenerLock;
	vector<shared_ptr<INotificationListener>> _externalNotificationListeners;
public:
	INotificationListener* RegisterNotificationCallback(NotificationListenerCallback callback, Emulator* emu)
	{
		auto lock = _externalNotificationListenerLock.AcquireSafe();
		auto listener = shared_ptr<INotificationListener>(new InteropNotificationListener(callback));
		_externalNotificationListeners.push_back(listener);
		emu->GetNotificationManager()->RegisterNotificationListener(listener);
		return listener.get();
	}
	void UnregisterNotificationCallback(INotificationListener *listener)
	{
		auto lock = _externalNotificationListenerLock.AcquireSafe();
		_externalNotificationListeners.erase(
			std::remove_if(
				_externalNotificationListeners.begin(),
				_externalNotificationListeners.end(),
				[=](shared_ptr<INotificationListener> ptr) { return ptr.get() == listener; }
			),
			_externalNotificationListeners.end()
		);
	}
};
```

## File: InteropDLL/NetplayApiWrapper.cpp
```cpp
#include "Common.h"
#include "Core/Shared/Emulator.h"
#include "Core/Shared/EmuSettings.h"
#include "Core/Netplay/ClientConnectionData.h"
#include "Core/Netplay/GameServer.h"
#include "Core/Netplay/GameClient.h"
extern unique_ptr<Emulator> _emu;
extern "C" {
	DllExport void __stdcall StartServer(uint16_t port, char* password) { _emu->GetGameServer()->StartServer(port, password); }
	DllExport void __stdcall StopServer() { _emu->GetGameServer()->StopServer(); }
	DllExport bool __stdcall IsServerRunning() { return _emu->GetGameServer()->Started(); }
	DllExport void __stdcall Connect(char* host, uint16_t port, char* password, bool spectator)
	{
		ClientConnectionData connectionData(host, port, password, spectator);
		_emu->GetGameClient()->Connect(connectionData);
	}
	DllExport void __stdcall Disconnect() { _emu->GetGameClient()->Disconnect(); }
	DllExport bool __stdcall IsConnected() { return _emu->GetGameClient()->Connected(); }
	DllExport void __stdcall NetPlayGetControllerList(NetplayControllerUsageInfo* list, int32_t& length)
	{
		vector<NetplayControllerUsageInfo> controllers;
		if(_emu->GetGameServer()->Started()) {
			controllers = _emu->GetGameServer()->GetControllerList();
		} else {
			controllers = _emu->GetGameClient()->GetControllerList();
		}
		for(size_t i = 0; i < controllers.size() && i < length; i++) {
			list[i] = controllers[i];
		}
		length = (int32_t)controllers.size();
	}
	DllExport void __stdcall NetPlaySelectController(NetplayControllerInfo controller)
	{
		if(_emu->GetGameServer()->Started()) {
			return _emu->GetGameServer()->SetHostControllerPort(controller);
		} else {
			return _emu->GetGameClient()->SelectController(controller);
		}
	}
	DllExport NetplayControllerInfo __stdcall NetPlayGetControllerPort()
	{
		if(_emu->GetGameServer()->Started()) {
			return _emu->GetGameServer()->GetHostControllerPort();
		} else {
			return _emu->GetGameClient()->GetControllerPort();
		}
	}
}
```

## File: InteropDLL/RecordApiWrapper.cpp
```cpp
#include "Common.h"
#include "Core/Shared/Emulator.h"
#include "Core/Shared/Video/VideoRenderer.h"
#include "Core/Shared/Audio/SoundMixer.h"
#include "Core/Shared/Movies/MovieManager.h"
extern unique_ptr<Emulator> _emu;
extern "C"
{
	DllExport void __stdcall AviRecord(char* filename, RecordAviOptions options) { _emu->GetVideoRenderer()->StartRecording(filename, options); }
	DllExport void __stdcall AviStop() { _emu->GetVideoRenderer()->StopRecording(); }
	DllExport bool __stdcall AviIsRecording() { return _emu->GetVideoRenderer()->IsRecording(); }
	DllExport void __stdcall WaveRecord(char* filename) { _emu->GetSoundMixer()->StartRecording(filename); }
	DllExport void __stdcall WaveStop() { _emu->GetSoundMixer()->StopRecording(); }
	DllExport bool __stdcall WaveIsRecording() { return _emu->GetSoundMixer()->IsRecording(); }
	DllExport void __stdcall MoviePlay(char* filename) { _emu->GetMovieManager()->Play(string(filename)); }
	DllExport void __stdcall MovieStop() { _emu->GetMovieManager()->Stop(); }
	DllExport bool __stdcall MoviePlaying() { return _emu->GetMovieManager()->Playing(); }
	DllExport bool __stdcall MovieRecording() { return _emu->GetMovieManager()->Recording(); }
	DllExport void __stdcall MovieRecord(RecordMovieOptions options) { _emu->GetMovieManager()->Record(options); }
}
```

## File: InteropDLL/TestApiWrapper.cpp
```cpp
#include "Common.h"
#include "Core/Shared/RecordedRomTest.h"
#include "Core/Shared/Emulator.h"
#include "Core/Shared/EmuSettings.h"
extern unique_ptr<Emulator> _emu;
shared_ptr<RecordedRomTest> _recordedRomTest;
extern "C"
{
	DllExport RomTestResult __stdcall RunRecordedTest(char* filename, bool inBackground)
	{
		if(inBackground) {
			unique_ptr<Emulator> emu(new Emulator());
			emu->Initialize(false);
			emu->GetSettings()->SetFlag(EmulationFlags::TestMode);
			shared_ptr<RecordedRomTest> romTest(new RecordedRomTest(emu.get(), true));
			RomTestResult result = romTest->Run(filename);
			emu->Release();
			return result;
		} else {
			shared_ptr<RecordedRomTest> romTest(new RecordedRomTest(_emu.get(), false));
			return romTest->Run(filename);
		}
	}
	DllExport uint64_t __stdcall RunTest(char* filename, uint32_t address, MemoryType memType)
	{
		unique_ptr<Emulator> emu(new Emulator());
		emu->Initialize();
		emu->GetSettings()->SetFlag(EmulationFlags::TestMode);
		emu->GetSettings()->GetGameboyConfig().Model = GameboyModel::Gameboy;
		emu->GetSettings()->GetGameboyConfig().RamPowerOnState = RamState::AllZeros;
		emu->LoadRom((VirtualFile)filename, VirtualFile());
		emu->GetSettings()->SetFlag(EmulationFlags::MaximumSpeed);
		while(emu->GetFrameCount() < 500) {
			std::this_thread::sleep_for(std::chrono::duration<int, std::milli>(10));
		}
		ConsoleMemoryInfo memInfo = emu->GetMemory(memType);
		uint8_t* memBuffer = (uint8_t*)memInfo.Memory;
		uint64_t result = memBuffer[address];
		for(int i = 1; i < 8; i++) {
			if(address + i < memInfo.Size) {
				result |= ((uint64_t)memBuffer[address + i] << (8*i));
			} else {
				break;
			}
		}
		emu->Stop(false);
		emu->Release();
		return result;
	}
	DllExport void __stdcall RomTestRecord(char* filename, bool reset)
	{
		_recordedRomTest.reset(new RecordedRomTest(_emu.get(), false));
		_recordedRomTest->Record(filename, reset);
	}
	DllExport void __stdcall RomTestStop()
	{
		if(_recordedRomTest) {
			_recordedRomTest->Stop();
			_recordedRomTest.reset();
		}
	}
	DllExport bool __stdcall RomTestRecording() { return _recordedRomTest != nullptr; }
}
```

## File: LICENSE
```
GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<http://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<http://www.gnu.org/philosophy/why-not-lgpl.html>.
```

## File: linux-debugging/.gitignore
```
tsan.log.*
```

## File: linux-debugging/log_processor.awk
```
#!/usr/bin/gawk -f

BEGIN {
	cmd = "llvm-symbolizer --output-style GNU -Ce bin/linux-x64/Release/MesenCore.so" addr
}

$4 ~ /MesenCore\.so/ {
	match($4, /0x[0-9A-Fa-f]+/)
	ofs = substr($4, RSTART, RLENGTH)
	print ofs |& cmd
	cmd |& getline func_name
	cmd |& getline src

	$2 = func_name
	$3 = src
}

{ print }
```

## File: linux-debugging/suppressions
```
called_from_lib:libcoreclr.so
called_from_lib:libclrjit.so
```

## File: linux-debugging/tsan_launch.sh
```bash
set -euo pipefail
cd "$(dirname "$(realpath "$0")")"
TSAN_OPTIONS="suppressions=$PWD/suppressions log_path=$PWD/tsan.log" LD_PRELOAD=/usr/lib/libtsan.so ../bin/linux-x64/Release/linux-x64/publish/Mesen
```

## File: makefile
```
#Welcome to what must be the most terrible makefile ever (but hey, it works)
#Both clang & gcc work fine - clang seems to output faster code
#.NET 6 (and its dev tools) must be installed to compile the UI.
#The emulation core also requires SDL2.
#Run "make" to build, "make run" to run

MESENFLAGS=

ifeq ($(USE_GCC),true)
	CXX := g++
	CC := gcc
	PROFILE_GEN_FLAG := -fprofile-generate
	PROFILE_USE_FLAG := -fprofile-use
else
	CXX := clang++
	CC := clang
	PROFILE_GEN_FLAG := -fprofile-instr-generate=$(CURDIR)/PGOHelper/pgo.profraw
	PROFILE_USE_FLAG := -fprofile-instr-use=$(CURDIR)/PGOHelper/pgo.profdata
endif

SDL2LIB := $(shell sdl2-config --libs)
SDL2INC := $(shell sdl2-config --cflags)

LINKCHECKUNRESOLVED := -Wl,-z,defs

LINKOPTIONS :=
MESENOS :=
UNAME_S := $(shell uname -s)

ifeq ($(UNAME_S),Linux)
	MESENOS := linux
	SHAREDLIB := MesenCore.so
endif

ifeq ($(UNAME_S),Darwin)
	MESENOS := osx
	SHAREDLIB := MesenCore.dylib
	LTO := false
	STATICLINK := false
	LINKCHECKUNRESOLVED :=
endif

MESENFLAGS += -m64

MACHINE := $(shell uname -m)
ifeq ($(MACHINE),x86_64)
	MESENPLATFORM := $(MESENOS)-x64
endif
ifneq ($(filter %86,$(MACHINE)),)
	MESENPLATFORM := $(MESENOS)-x64
endif
# TODO: this returns `aarch64` on one of my machines...
ifneq ($(filter arm%,$(MACHINE)),)
	MESENPLATFORM := $(MESENOS)-arm64
endif
ifeq ($(MACHINE),aarch64)
	MESENPLATFORM := $(MESENOS)-arm64
	ifeq ($(USE_GCC),true)
		#don't set -m64 on arm64 for gcc (unrecognized option)
		MESENFLAGS=
	endif
endif

DEBUG ?= 0

ifeq ($(DEBUG),0)
	MESENFLAGS += -O3
	ifneq ($(LTO),false)
		MESENFLAGS += -DHAVE_LTO
		ifneq ($(USE_GCC),true)
			MESENFLAGS += -flto=thin
		else
			MESENFLAGS += -flto=auto
		endif
	endif
else
	MESENFLAGS += -O0 -g
	# Note: if compiling with a sanitizer, you will likely need to `LD_PRELOAD` the library `libMesenCore.so` will be linked against.
	ifneq ($(SANITIZER),)
		ifeq ($(SANITIZER),address)
			# Currently, `-fsanitize=address` is not supported together with `-fsanitize=thread`
			MESENFLAGS += -fsanitize=address
		else ifeq ($(SANITIZER),thread)
			# Currently, `-fsanitize=address` is not supported together with `-fsanitize=thread`
			MESENFLAGS += -fsanitize=thread
		else
$(warning Unrecognised $$(SANITIZER) value: $(SANITIZER))
		endif
		# `-Wl,-z,defs` is incompatible with the sanitizers in a shared lib, unless the sanitizer libs are linked dynamically; hence `-shared-libsan` (not the default for Clang).
		# It seems impossible to link dynamically against two sanitizers at the same time, but that might be a Clang limitation.
		ifneq ($(USE_GCC),true)
			MESENFLAGS += -shared-libsan
		endif
	endif
endif

ifeq ($(PGO),profile)
	MESENFLAGS += ${PROFILE_GEN_FLAG}
endif

ifeq ($(PGO),optimize)
	MESENFLAGS += ${PROFILE_USE_FLAG}
endif

ifneq ($(STATICLINK),false)
	LINKOPTIONS += -static-libgcc -static-libstdc++ 
endif

ifeq ($(MESENOS),osx)
	LINKOPTIONS += -framework Foundation -framework Cocoa -framework GameController -framework CoreHaptics -Wl,-rpath,/opt/local/lib
endif

CXXFLAGS = -fPIC -Wall --std=c++17 $(MESENFLAGS) $(SDL2INC) -I $(realpath ./) -I $(realpath ./Core) -I $(realpath ./Utilities) -I $(realpath ./Sdl) -I $(realpath ./Linux) -I $(realpath ./MacOS)
OBJCXXFLAGS = $(CXXFLAGS)
CFLAGS = -fPIC -Wall $(MESENFLAGS)

OBJFOLDER := obj.$(MESENPLATFORM)
DEBUGFOLDER := bin/$(MESENPLATFORM)/Debug
RELEASEFOLDER := bin/$(MESENPLATFORM)/Release
ifeq ($(DEBUG), 0)
	OUTFOLDER = $(RELEASEFOLDER)
	BUILD_TYPE := Release
	OPTIMIZEUI := -p:OptimizeUi=true
else
	OUTFOLDER = $(DEBUGFOLDER)
	BUILD_TYPE := Debug
	OPTIMIZEUI :=
endif


ifeq ($(USE_AOT),true)
	PUBLISHFLAGS ?=  -r $(MESENPLATFORM) -p:PublishSingleFile=false -p:PublishAot=true -p:SelfContained=true
else
	PUBLISHFLAGS ?=  -r $(MESENPLATFORM) --no-self-contained true -p:PublishSingleFile=true
endif


CORESRC := $(shell find Core -name '*.cpp')
COREOBJ := $(CORESRC:.cpp=.o)

UTILSRC := $(shell find Utilities -name '*.cpp' -o -name '*.c')
UTILOBJ := $(addsuffix .o,$(basename $(UTILSRC)))

SDLSRC := $(shell find Sdl -name '*.cpp')
SDLOBJ := $(SDLSRC:.cpp=.o)

SEVENZIPSRC := $(shell find SevenZip -name '*.c')
SEVENZIPOBJ := $(SEVENZIPSRC:.c=.o)

LUASRC := $(shell find Lua -name '*.c')
LUAOBJ := $(LUASRC:.c=.o)

ifeq ($(MESENOS),linux)
	LINUXSRC := $(shell find Linux -name '*.cpp')
else
	LINUXSRC :=
endif
LINUXOBJ := $(LINUXSRC:.cpp=.o)

ifeq ($(MESENOS),osx)
	MACOSSRC := $(shell find MacOS -name '*.mm')
else
	MACOSSRC :=
endif
MACOSOBJ := $(MACOSSRC:.mm=.o)

DLLSRC := $(shell find InteropDLL -name '*.cpp')
DLLOBJ := $(DLLSRC:.cpp=.o)

ifeq ($(SYSTEM_LIBEVDEV), true)
	LIBEVDEVLIB := $(shell pkg-config --libs libevdev)
	LIBEVDEVINC := $(shell pkg-config --cflags libevdev)
else
	LIBEVDEVSRC := $(shell find Linux/libevdev -name '*.c')
	LIBEVDEVOBJ := $(LIBEVDEVSRC:.c=.o)
	LIBEVDEVINC := -I../
endif

ifeq ($(MESENOS),linux)
	X11LIB := -lX11
else
	X11LIB :=
endif

FSLIB := -lstdc++fs

ifeq ($(MESENOS),osx)
	LIBEVDEVOBJ := 
	LIBEVDEVINC := 
	LIBEVDEVSRC := 
	FSLIB := 
	ifeq ($(USE_AOT),true)
		PUBLISHFLAGS := -t:BundleApp -p:UseAppHost=true -p:RuntimeIdentifier=$(MESENPLATFORM) -p:PublishSingleFile=false -p:PublishAot=true -p:SelfContained=true
	else
		PUBLISHFLAGS := -t:BundleApp -p:UseAppHost=true -p:RuntimeIdentifier=$(MESENPLATFORM) -p:SelfContained=true -p:PublishSingleFile=false -p:PublishReadyToRun=false
	endif
endif

all: ui

ui: InteropDLL/$(OBJFOLDER)/$(SHAREDLIB)
	mkdir -p $(OUTFOLDER)/Dependencies
	rm -fr $(OUTFOLDER)/Dependencies/*
	cp InteropDLL/$(OBJFOLDER)/$(SHAREDLIB) $(OUTFOLDER)/$(SHAREDLIB)
	#Called twice because the first call copies native libraries to the bin folder which need to be included in Dependencies.zip
	#Don't run with AOT flags the first time to reduce build duration
	cd UI && dotnet publish -c $(BUILD_TYPE) $(OPTIMIZEUI) -r $(MESENPLATFORM)
	cd UI && dotnet publish -c $(BUILD_TYPE) $(OPTIMIZEUI) $(PUBLISHFLAGS)

core: InteropDLL/$(OBJFOLDER)/$(SHAREDLIB)

pgohelper: InteropDLL/$(OBJFOLDER)/$(SHAREDLIB)
	mkdir -p PGOHelper/$(OBJFOLDER) && cd PGOHelper/$(OBJFOLDER) && $(CXX) $(CXXFLAGS) $(LINKCHECKUNRESOLVED) -o pgohelper ../PGOHelper.cpp ../../bin/pgohelperlib.so -pthread $(FSLIB) $(SDL2LIB) $(LIBEVDEVLIB) $(X11LIB)

%.o: %.c
	$(CC) $(CFLAGS) -c $< -o $@
	
%.o: %.cpp
	$(CXX) $(CXXFLAGS) -c $< -o $@

%.o: %.mm
	$(CXX) $(OBJCXXFLAGS) -c $< -o $@

InteropDLL/$(OBJFOLDER)/$(SHAREDLIB): $(SEVENZIPOBJ) $(LUAOBJ) $(UTILOBJ) $(COREOBJ) $(SDLOBJ) $(LIBEVDEVOBJ) $(LINUXOBJ) $(DLLOBJ) $(MACOSOBJ)
	mkdir -p bin
	mkdir -p InteropDLL/$(OBJFOLDER)
	$(CXX) $(CXXFLAGS) $(LINKOPTIONS) $(LINKCHECKUNRESOLVED) -shared -o $(SHAREDLIB) $(DLLOBJ) $(SEVENZIPOBJ) $(LUAOBJ) $(LINUXOBJ) $(MACOSOBJ) $(LIBEVDEVOBJ) $(UTILOBJ) $(SDLOBJ) $(COREOBJ) $(SDL2INC) -pthread $(FSLIB) $(SDL2LIB) $(LIBEVDEVLIB) $(X11LIB)
	cp $(SHAREDLIB) bin/pgohelperlib.so
	mv $(SHAREDLIB) InteropDLL/$(OBJFOLDER)

pgo:
	./buildPGO.sh

run:
	$(OUTFOLDER)/$(MESENPLATFORM)/publish/Mesen

clean:
	rm -r -f $(COREOBJ)
	rm -r -f $(UTILOBJ)
	rm -r -f $(LINUXOBJ) $(LIBEVDEVOBJ)
	rm -r -f $(SDLOBJ)
	rm -r -f $(SEVENZIPOBJ)
	rm -r -f $(LUAOBJ)
	rm -r -f $(MACOSOBJ)
	rm -r -f $(DLLOBJ)
```

## File: NuGet.Config
```
<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <packageSources>
    <add key="nuget.org" value="https://api.nuget.org/v3/index.json" protocolVersion="3" />
  </packageSources>
</configuration>
```

## File: repomix.config.json
```json
{
  "$schema": "https://repomix.com/schemas/latest/schema.json",
  "input": {
    "maxFileSize": 52428800
  },
  "output": {
    "filePath": "repomix-output.md",
    "style": "markdown",
    "parsableStyle": true,
    "fileSummary": true,
    "directoryStructure": true,
    "files": true,
    "removeComments": true,
    "removeEmptyLines": true,
    "compress": false,
    "topFilesLength": 10,
    "showLineNumbers": false,
    "truncateBase64": false,
    "copyToClipboard": false,
    "includeFullDirectoryStructure": false,
    "tokenCountTree": false,
    "headerText": "CONTEXTO DE INFRAESTRUCTURA MCP:\nEste repositorio (Mesen2) actúa como el motor de emulación. El control programático, la lectura de memoria y la interacción con LLMs se gestionan mediante el repositorio paralelo 'mesen-mcp-infra'.\nLos puntos de entrada clave para el control externo en este repositorio son InteropDLL y Core/Debugger.",
    "git": {
      "sortByChanges": true,
      "sortByChangesMaxCommits": 100,
      "includeDiffs": false,
      "includeLogs": false,
      "includeLogsCount": 50
    }
  },
  "ignore": {
    "useGitignore": true,
    "useDotIgnore": true,
    "useDefaultPatterns": true,
    "customPatterns": [
      "**/repomix-output.*",
      "**/bin/**",
      "**/obj/**",
      "**/*.pdb",
      "**/*.lib",
      "**/*.dll",
      "**/*.zip",
      "**/*.exe",
      "**/*.vcxproj*",
      "**/*.filters",
      "**/*.user",
      "**/*.sln",
      "**/Localization/**",
      "UI/**",
      "SevenZip/**",
      "Lua/**",
      "Utilities/**",
      "Linux/**",
      "MacOS/**",
      "Windows/**",
      "Sdl/**",
      "PGOHelper/**",
      "Core/NES/**",
      "Core/SNES/**",
      "Core/Gameboy/**",
      "Core/GBA/**",
      "Core/PCE/**",
      "Core/SMS/**",
      "Core/WS/**"
    ]
  },
  "security": {
    "enableSecurityCheck": true
  },
  "tokenCount": {
    "encoding": "o200k_base"
  }
}
```

## File: SteamOS.md
```markdown
Running Mesen through the Steam Deck's _Game Mode_ is possible with some caveats regarding rendering the UI.  
Due to Gamescope (SteamOS' compositor) not handling Avalonia UI's popups very well (a [solution](https://github.com/AvaloniaUI/Avalonia/pull/14366) is available but [has been reverted due to other issues](https://github.com/AvaloniaUI/Avalonia/pull/14573)), Mesen's menus for settings are not working through Gamescope unless running Mesen [through running KDE Plasma's Desktop through a script](https://www.reddit.com/r/SteamDeck/comments/zqgx9g/desktop_mode_within_gaming_mode_updated_for_new/).

 Installation instructions:
 * Download the **[Linux - AppImage](https://nightly.link/SourMesen/Mesen2/workflows/build/master/Mesen%20(Linux%20x64%20-%20AppImage).zip)** nightly build.
 * **Mark the AppImage as executable.** (right click > Properties > Permissions > Is executable)
 * Add the application as a non-Steam shortcut to be able to run it through Steam on both _Desktop Mode_ and _Game Mode_. (right click > Add to Steam)
 * Customise the non-Steam shortcut through Steam to your desire. (in Steam: search the AppImage's filename, right click > Properties; from there you can change the icon, shortcut name and launch options)
 * Create a folder called `Mesen.AppImage.Config` in the same directory where the AppImage is stored.
 * Run it the first time. When asking where to store the settings, choose the `Store the data in my user profile` option. ![254295455-88c1942d-b81f-48ee-a3a3-74b9f3ecd9b7-1](https://github.com/kevin-wijnen/Mesen2/assets/58944808/9f4ff1e3-4df6-4441-958b-ce96599ef69d)
 * Set up the controls as asked by Mesen.

**Due to Gamescope not rendering the UI menus, it is recommended to bind some keyboard shortcuts to L4/R4/L5/R5 (the Back Grip Buttons).** You can rebind controls in _Game Mode_ by clicking the Controller icon. You can save the layout by clicking the Cog icon (next to `Edit Layout`) > Export Layout > select `New Template` as the Export Type to use it across multiple shortcuts. 
It is recommended to:
* Bind `Control Key + O Key` to open the file picker for opening a game file.
* Bind `Escape Key` to pause emulation.
* Bind `F11` to enter in or out of fullscreen. 

**If sound does not work**, check if an audio device is chosen by Mesen. (in Mesen: Settings > Audio > General (Device))

**To make game-specific shortcuts**: Repeat the non-Steam shortcut step on the Mesen AppImage. Customise the new shortcut with a Launch Option (in Steam: right click > Properties; Launch Options). To find possible Launch Options, check the Command-line options menu (in Mesen: Help > Command-line options). When you want to supply a game with the shortcut, put the entire file location of the game in double quotes ("game-filepath") as the first part of the launch options. Add additional options (`--fullscreen` for example) _after_ the file location.
```

## File: .github/workflows/build.yml
```yaml
name: Build Mesen
on: [push]
env:
  DOTNET_CLI_TELEMETRY_OPTOUT: 1
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: 1
jobs:
  windows:
    strategy:
      matrix:
        platform: [
          {netversion: 6.x, targetframework: net6.0, aot: false, singleFile: true, aotString: ""},
          {netversion: 8.x, targetframework: net8.0, aot: false, singleFile: true, aotString: ""},
          {netversion: 8.x, targetframework: net8.0, aot: true, singleFile: false, aotString: " - AoT"}
        ]
      fail-fast: false
    runs-on: windows-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Install .NET Core
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ matrix.platform.netversion }}
      - name: Setup MSBuild.exe
        uses: microsoft/setup-msbuild@v2
        with:
          msbuild-architecture: x64
      - name: Restore packages
        run: dotnet restore -p:TargetFramework="${{ matrix.platform.targetframework }}" -r win-x64 -p:PublishAot="${{ matrix.platform.aot }}" -p:BuildWithNetFrameworkHostedCompiler=true
      - name: Write commit SHA1 to file
        uses: ./.github/actions/build-sha1-action
      - name: Build Mesen
        run: msbuild -nologo -v:d -clp:ForceConsoleColor -m -p:Configuration=Release -p:Platform=x64 -t:Clean,UI -p:TargetFramework="${{ matrix.platform.targetframework }}"
      - name: Publish Mesen
        run: dotnet publish --no-restore -c Release -p:PublishAot="${{ matrix.platform.aot }}" -p:SelfContained="${{ matrix.platform.aot }}" -p:PublishSingleFile="${{ matrix.platform.singleFile }}" -p:OptimizeUi="true" -p:Platform="Any CPU" -p:TargetFramework="${{ matrix.platform.targetframework }}" -r win-x64 Mesen.sln /p:PublishProfile=UI\Properties\PublishProfiles\Release.pubxml
      - name: Upload Mesen
        uses: actions/upload-artifact@v4
        with:
          name: Mesen (Windows - ${{ matrix.platform.targetframework }}${{ matrix.platform.aotString }})
          path: |
            build/TmpReleaseBuild/Mesen.exe
  linux:
    strategy:
      matrix:
        compiler: [gcc, clang, clang_aot]
        platform: [
          {os: ubuntu-22.04, path: x64},
          {os: ubuntu-22.04-arm, path: arm64}
        ]
        exclude:
          - platform: { os: ubuntu-22.04-arm, path: arm64 }
            compiler: clang_aot
        include:
          - compiler: gcc
            make_flags: "USE_GCC=true"
          - compiler: clang
            make_flags: ""
          - compiler: clang_aot
            make_flags: "USE_AOT=true"
      fail-fast: false
    runs-on: ${{ matrix.platform.os }}
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Install .NET Core
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.x
      - name: Install dependencies
        run: |
          sudo apt-get update -qy
          sudo apt-get install -qy libsdl2-dev ccache
      - name: Setup CCache
        uses: ./.github/actions/setup-ccache-action
      - name: Write commit SHA1 to file
        uses: ./.github/actions/build-sha1-action
      - name: Build Mesen
        run: |
          make -j$(nproc) -O ${{ matrix.make_flags }} LTO=true STATICLINK=true SYSTEM_LIBEVDEV=false
      - name: Upload Mesen
        uses: actions/upload-artifact@v4
        with:
          name: Mesen (Linux - ${{ matrix.platform.os }} - ${{ matrix.compiler }})
          path: bin/linux-${{ matrix.platform.path }}/Release/linux-${{ matrix.platform.path }}/publish/Mesen
  appimage:
    strategy:
      matrix:
        compiler: [clang_appimage]
        platform: [
          {os: ubuntu-22.04, name: x64, script: Linux/appimage/appimage.sh},
          {os: ubuntu-22.04-arm, name: ARM64, script: Linux/appimage/appimage-arm64.sh}
        ]
    runs-on: ${{ matrix.platform.os }}
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Install .NET Core
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.x
      - name: Install dependencies
        run: |
          sudo apt-get update -qy
          sudo apt-get install -qy libsdl2-dev libfuse2 ccache
      - name: Setup CCache
        uses: ./.github/actions/setup-ccache-action
      - name: Write commit SHA1 to file
        uses: ./.github/actions/build-sha1-action
      - name: Build Mesen (AppImage)
        run: |
          ${{ matrix.platform.script }}
      - name: Upload Mesen (AppImage)
        uses: actions/upload-artifact@v4
        with:
          name: Mesen (Linux ${{ matrix.platform.name }} - AppImage)
          path: Mesen.AppImage
  macos:
    strategy:
      matrix:
        compiler: [clang, clang_aot]
        platform: [
          {os: macos-13, arch: x64},
          {os: macos-14, arch: arm64}
        ]
        include:
          - compiler: clang
            make_flags: ""
          - compiler: clang_aot
            make_flags: "USE_AOT=true"
      fail-fast: false
    runs-on: ${{ matrix.platform.os }}
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Install .NET Core
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.x
      - name: Install dependencies
        run: |
          brew install sdl2 ccache
      - name: Get brew prefix
        run: |
          echo "brewPrefix=$(brew --prefix)" >> "$GITHUB_ENV"
      - name: Setup CCache
        uses: ./.github/actions/setup-ccache-action
        with:
          ccache-path: '${{ env.brewPrefix }}/opt/ccache/libexec'
      - name: Write commit SHA1 to file
        uses: ./.github/actions/build-sha1-action
      - name: Build Mesen
        run: |
          ${{ matrix.make_flags }} make -j$(sysctl -n hw.logicalcpu)
      - name: Sign binary
        env:
          APP_NAME: bin/osx-${{ matrix.platform.arch }}/Release/osx-${{ matrix.platform.arch }}/publish/Mesen.app
          CERT_DATA: ${{ secrets.MACOS_CERTIFICATE }}
          CERT_PASS: ${{ secrets.MACOS_CERTIFICATE_PWD }}
          ENTITLEMENTS: UI/Mesen.entitlements
          SIGNING_IDENTITY: Mesen
        run: |
          echo "$CERT_DATA" | base64 --decode > /tmp/certs.p12
          security create-keychain -p actions macos-build.keychain
          security default-keychain -s macos-build.keychain
          security unlock-keychain -p actions macos-build.keychain
          security set-keychain-settings -t 3600 -u macos-build.keychain
          security import /tmp/certs.p12 -k ~/Library/Keychains/macos-build.keychain -P "$CERT_PASS" -T /usr/bin/codesign -T /usr/bin/productsign
          security set-key-partition-list -S apple-tool:,apple: -s -k actions macos-build.keychain
          security find-identity -v macos-build.keychain
          echo "[INFO] Signing app file"
          codesign --force --deep --timestamp --keychain macos-build.keychain --options=runtime --entitlements "$ENTITLEMENTS" --sign "$SIGNING_IDENTITY" "$APP_NAME"
      - name: Zip Mesen.app
        run: |
          ditto -c -k --sequesterRsrc --keepParent bin/osx-${{ matrix.platform.arch }}/Release/osx-${{ matrix.platform.arch }}/publish/Mesen.app bin/osx-${{ matrix.platform.arch }}/Release/Mesen.app.zip
      - name: Upload Mesen
        uses: actions/upload-artifact@v4
        with:
          name: Mesen (macOS - ${{ matrix.platform.os }} - ${{ matrix.compiler }})
          path: bin/osx-${{ matrix.platform.arch }}/Release/Mesen.app.zip
```

## File: Core/Debugger/Debugger.h
```
#pragma once
#include "pch.h"
#include "Utilities/SimpleLock.h"
#include "Debugger/DebugUtilities.h"
#include "Debugger/DebugTypes.h"
#include "Debugger/DebuggerFeatures.h"
#include "Shared/SettingTypes.h"
class IConsole;
class Emulator;
class SnesCpu;
class SnesPpu;
class Spc;
class BaseCartridge;
class SnesMemoryManager;
class InternalRegisters;
class SnesDmaController;
class EmuSettings;
class ExpressionEvaluator;
class MemoryDumper;
class MemoryAccessCounter;
class Disassembler;
class DisassemblySearch;
class BreakpointManager;
class PpuTools;
class CodeDataLogger;
class CallstackManager;
class LabelManager;
class CdlManager;
class ScriptManager;
class Breakpoint;
class BaseEventManager;
class IAssembler;
class IDebugger;
class ITraceLogger;
class TraceLogFileSaver;
class FrozenAddressManager;
struct TraceRow;
struct BaseState;
enum class EventType;
enum class MemoryOperationType;
enum class EvalResultType : int32_t;
struct CpuInfo
{
	unique_ptr<IDebugger> Debugger;
	unique_ptr<ExpressionEvaluator> Evaluator;
};
class Debugger
{
private:
	Emulator* _emu = nullptr;
	IConsole* _console = nullptr;
	EmuSettings* _settings = nullptr;
	CpuInfo _debuggers[(int)DebugUtilities::GetLastCpuType() + 1];
	CpuType _mainCpuType = CpuType::Snes;
	unordered_set<CpuType> _cpuTypes;
	ConsoleType _consoleType = ConsoleType::Snes;
	unique_ptr<ScriptManager> _scriptManager;
	unique_ptr<MemoryDumper> _memoryDumper;
	unique_ptr<MemoryAccessCounter> _memoryAccessCounter;
	unique_ptr<CodeDataLogger> _codeDataLogger;
	unique_ptr<Disassembler> _disassembler;
	unique_ptr<DisassemblySearch> _disassemblySearch;
	unique_ptr<LabelManager> _labelManager;
	unique_ptr<CdlManager> _cdlManager;
	unique_ptr<TraceLogFileSaver> _traceLogSaver;
	SimpleLock _logLock;
	std::list<string> _debuggerLog;
	atomic<bool> _executionStopped;
	atomic<uint32_t> _breakRequestCount;
	atomic<uint32_t> _suspendRequestCount;
	DebugControllerState _inputOverrides[8] = {};
	bool _waitForBreakResume = false;
	void Reset();
	__noinline bool ProcessStepBack(IDebugger* debugger);
	template<CpuType type, typename DebuggerType> DebuggerType* GetDebugger();
	template<CpuType type> uint64_t GetCpuCycleCount();
	template<CpuType type, typename T> void ProcessScripts(uint32_t addr, T& value, MemoryOperationType opType);
	template<CpuType type, typename T> void ProcessScripts(uint32_t addr, T& value, MemoryType memType, MemoryOperationType opType);
	bool IsDebugWindowOpened(CpuType cpuType);
	bool IsBreakOptionEnabled(BreakSource src);
	template<CpuType type> void SleepOnBreakRequest();
	void ClearPendingBreakExceptions();
	bool IsBreakpointForbidden(BreakSource source, CpuType sourceCpu, MemoryOperationInfo* operation);
public:
	Debugger(Emulator* emu, IConsole* console);
	~Debugger();
	void Release();
	template<CpuType type> void ProcessInstruction();
	template<CpuType type, uint8_t accessWidth = 1, MemoryAccessFlags flags = MemoryAccessFlags::None, typename T> void ProcessMemoryRead(uint32_t addr, T& value, MemoryOperationType opType);
	template<CpuType type, uint8_t accessWidth = 1, MemoryAccessFlags flags = MemoryAccessFlags::None, typename T> bool ProcessMemoryWrite(uint32_t addr, T& value, MemoryOperationType opType);
	template<CpuType cpuType, MemoryType memType, MemoryOperationType opType, typename T> void ProcessMemoryAccess(uint32_t addr, T& value);
	template<CpuType type> void ProcessIdleCycle();
	template<CpuType type> void ProcessHaltedCpu();
	template<CpuType type, typename T> void ProcessPpuRead(uint16_t addr, T& value, MemoryType memoryType, MemoryOperationType opType);
	template<CpuType type, typename T> void ProcessPpuWrite(uint16_t addr, T& value, MemoryType memoryType);
	template<CpuType type> void ProcessPpuCycle();
	template<CpuType type> void ProcessInterrupt(uint32_t originalPc, uint32_t currentPc, bool forNmi);
	void InternalProcessInterrupt(CpuType cpuType, IDebugger& dbg, StepRequest& stepRequest, AddressInfo& src, uint32_t srcAddr, AddressInfo& dest, uint32_t destAddr, AddressInfo& ret, uint32_t retAddr, uint32_t retSp, bool forNmi);
	void ProcessEvent(EventType type, std::optional<CpuType> cpuType);
	void ProcessConfigChange();
	void GetTokenList(CpuType cpuType, char* tokenList);
	int64_t EvaluateExpression(string expression, CpuType cpuType, EvalResultType &resultType, bool useCache);
	void Run();
	void PauseOnNextFrame();
	void Step(CpuType cpuType, int32_t stepCount, StepType type, BreakSource source = BreakSource::Unspecified);
	bool IsPaused();
	bool IsExecutionStopped();
	bool HasBreakRequest();
	void BreakRequest(bool release);
	void ResetSuspendCounter();
	void SuspendDebugger(bool release);
	__noinline void BreakImmediately(CpuType sourceCpu, BreakSource source);
	template<uint8_t accessWidth = 1> void ProcessPredictiveBreakpoint(CpuType sourceCpu, BreakpointManager* bpManager, MemoryOperationInfo& operation, AddressInfo& addressInfo);
	template<uint8_t accessWidth = 1> void ProcessBreakConditions(CpuType sourceCpu, StepRequest& step, BreakpointManager* bpManager, MemoryOperationInfo& operation, AddressInfo& addressInfo);
	void SleepUntilResume(CpuType sourceCpu, BreakSource source, MemoryOperationInfo* operation = nullptr, int breakpointId = -1);
	void GetCpuState(BaseState& dstState, CpuType cpuType);
	void SetCpuState(BaseState& srcState, CpuType cpuType);
	BaseState& GetCpuStateRef(CpuType cpuType);
	void GetPpuState(BaseState& state, CpuType cpuType);
	void SetPpuState(BaseState& srcState, CpuType cpuType);
	void GetConsoleState(BaseState& state, ConsoleType consoleType);
	DebuggerFeatures GetDebuggerFeatures(CpuType cpuType);
	uint32_t GetProgramCounter(CpuType cpuType, bool forInstStart);
	uint8_t GetCpuFlags(CpuType cpuType, uint32_t addr);
	CpuInstructionProgress GetInstructionProgress(CpuType cpuType);
	void SetProgramCounter(CpuType cpuType, uint32_t addr);
	AddressInfo GetAbsoluteAddress(AddressInfo relAddress);
	AddressInfo GetRelativeAddress(AddressInfo absAddress, CpuType cpuType);
	bool HasCpuType(CpuType cpuType);
	void SetBreakpoints(Breakpoint breakpoints[], uint32_t length);
	void SetInputOverrides(uint32_t index, DebugControllerState state);
	void GetAvailableInputOverrides(uint8_t* availableIndexes);
	void Log(string message);
	string GetLog();
	bool SaveRomToDisk(string filename, bool saveAsIps, CdlStripOption stripOption);
	void ClearExecutionTrace();
	uint32_t GetExecutionTrace(TraceRow output[], uint32_t startOffset, uint32_t maxLineCount);
	CpuType GetMainCpuType() { return _mainCpuType; }
	IDebugger* GetMainDebugger();
	TraceLogFileSaver* GetTraceLogFileSaver() { return _traceLogSaver.get(); }
	MemoryDumper* GetMemoryDumper() { return _memoryDumper.get(); }
	MemoryAccessCounter* GetMemoryAccessCounter() { return _memoryAccessCounter.get(); }
	Disassembler* GetDisassembler() { return _disassembler.get(); }
	DisassemblySearch* GetDisassemblySearch() { return _disassemblySearch.get(); }
	LabelManager* GetLabelManager() { return _labelManager.get(); }
	CdlManager* GetCdlManager() { return _cdlManager.get(); }
	ScriptManager* GetScriptManager() { return _scriptManager.get(); }
	IConsole* GetConsole() { return _console; }
	Emulator* GetEmulator() { return _emu; }
	FrozenAddressManager* GetFrozenAddressManager(CpuType cpuType);
	ITraceLogger* GetTraceLogger(CpuType cpuType);
	PpuTools* GetPpuTools(CpuType cpuType);
	BaseEventManager* GetEventManager(CpuType cpuType);
	CallstackManager* GetCallstackManager(CpuType cpuType);
	IAssembler* GetAssembler(CpuType cpuType);
};
```

## File: Core/Debugger/Disassembler.cpp
```cpp
#include "pch.h"
#include <algorithm>
#include "Debugger/Disassembler.h"
#include "Debugger/DisassemblyInfo.h"
#include "Debugger/CdlManager.h"
#include "Debugger/Debugger.h"
#include "Debugger/LabelManager.h"
#include "Debugger/MemoryDumper.h"
#include "Debugger/CodeDataLogger.h"
#include "Debugger/DebugBreakHelper.h"
#include "Debugger/DebugUtilities.h"
#include "Debugger/IDebugger.h"
#include "SNES/SnesCpuTypes.h"
#include "SNES/SpcTypes.h"
#include "SNES/Coprocessors/GSU/GsuTypes.h"
#include "SNES/Coprocessors/CX4/Cx4Types.h"
#include "SNES/Coprocessors/ST018/ArmV3Types.h"
#include "Gameboy/GbTypes.h"
#include "GBA/GbaTypes.h"
#include "NES/NesTypes.h"
#include "PCE/PceTypes.h"
#include "SMS/SmsTypes.h"
#include "WS/WsTypes.h"
#include "WS/Debugger/WsDisUtils.h"
#include "Shared/EmuSettings.h"
#include "Utilities/FastString.h"
#include "Utilities/HexUtilities.h"
#include "Utilities/StringUtilities.h"
Disassembler::Disassembler(IConsole* console, Debugger* debugger)
{
	_debugger = debugger;
	_labelManager = debugger->GetLabelManager();
	_console = console;
	_settings = debugger->GetEmulator()->GetSettings();
	_memoryDumper = _debugger->GetMemoryDumper();
	for(int i = (int)MemoryType::SnesPrgRom; i < DebugUtilities::GetMemoryTypeCount(); i++) {
		InitSource((MemoryType)i);
	}
}
void Disassembler::InitSource(MemoryType type)
{
	uint32_t size = _memoryDumper->GetMemorySize(type);
	_sources[(int)type] = { vector<DisassemblyInfo>(size), size };
}
DisassemblerSource& Disassembler::GetSource(MemoryType type)
{
	return _sources[(int)type];
}
uint32_t Disassembler::BuildCache(AddressInfo &addrInfo, uint8_t cpuFlags, CpuType type)
{
	DisassemblerSource& src = GetSource(addrInfo.Type);
	int returnSize = 0;
	int32_t address = addrInfo.Address;
	do {
		DisassemblyInfo &disInfo = src.Cache[address];
		if(!disInfo.IsInitialized() || !disInfo.IsValid(cpuFlags)) {
			disInfo.Initialize(address, cpuFlags, type, addrInfo.Type, _memoryDumper);
			for(int i = 1; i < disInfo.GetOpSize() && address + i < src.Cache.size() ; i++) {
				src.Cache[address + i] = DisassemblyInfo();
			}
			returnSize += disInfo.GetOpSize();
		} else {
			returnSize += disInfo.GetOpSize();
			break;
		}
		if(!disInfo.CanDisassembleNextOp()) {
			break;
		}
		disInfo.UpdateCpuFlags(cpuFlags);
		address += disInfo.GetOpSize();
	} while(address >= 0 && address < (int32_t)src.Cache.size());
	return returnSize;
}
void Disassembler::ResetPrgCache()
{
	InitSource(MemoryType::SnesPrgRom);
	InitSource(MemoryType::GbPrgRom);
	InitSource(MemoryType::NesPrgRom);
	InitSource(MemoryType::PcePrgRom);
	InitSource(MemoryType::SmsPrgRom);
	InitSource(MemoryType::GbaPrgRom);
	InitSource(MemoryType::WsPrgRom);
}
void Disassembler::InvalidateCache(AddressInfo addrInfo, CpuType type)
{
	if(addrInfo.Address >= 0) {
		DisassemblerSource& src = GetSource(addrInfo.Type);
		for(int i = 0; i < 4; i++) {
			if(addrInfo.Address >= i) {
				src.Cache[addrInfo.Address - i].Reset();
			}
		}
	}
}
vector<DisassemblyResult> Disassembler::Disassemble(CpuType cpuType, uint16_t bank)
{
	if(!_debugger->HasCpuType(cpuType)) {
		return {};
	}
	constexpr int bytesPerRow = 8;
	vector<DisassemblyResult> results;
	results.reserve(20000);
	DebugConfig& cfg = _settings->GetDebugConfig();
	bool disUnident = cfg.DisassembleUnidentifiedData;
	bool disData = cfg.DisassembleVerifiedData;
	bool showUnident = cfg.ShowUnidentifiedData;
	bool showData = cfg.ShowVerifiedData;
	bool showJumpLabels = cfg.ShowJumpLabels;
	bool inUnknownBlock = false;
	bool inVerifiedBlock = false;
	bool inUnmappedBlock = false;
	LabelInfo labelInfo;
	AddressInfo prevAddrInfo = {};
	int byteCounter = 0;
	AddressInfo relAddress = {};
	relAddress.Type = DebugUtilities::GetCpuMemoryType(cpuType);
	if(bank > GetMaxBank(cpuType)) {
		return results;
	}
	int32_t bankStart = bank << 16;
	int32_t bankEnd = (bank + 1) << 16;
	bankEnd = std::min<int32_t>(bankEnd, (int32_t)_memoryDumper->GetMemorySize(relAddress.Type));
	AddressInfo addrInfo = {};
	auto pushEndBlock = [&]() {
		if(inUnknownBlock || inVerifiedBlock) {
			int flags = LineFlags::BlockEnd;
			if(inVerifiedBlock) {
				flags |= LineFlags::VerifiedData;
			}
			if((inVerifiedBlock && showData) || (inUnknownBlock && showUnident)) {
				flags |= LineFlags::ShowAsData;
			}
			results[results.size() - 1].SetByteCount(bytesPerRow - byteCounter + 1);
			results.push_back(DisassemblyResult(prevAddrInfo, relAddress.Address - 1, flags));
			inUnknownBlock = false;
			inVerifiedBlock = false;
			byteCounter = 0;
		}
	};
	uint8_t cpuFlags[4] = {};
	for(int i = 0; i < 4; i++) {
		cpuFlags[i] = _debugger->GetMainDebugger()->GetCpuFlags(i);
	}
	auto pushUnmappedBlock = [&]() {
		int32_t prevAddress = results.size() > 0 ? results[results.size() - 1].CpuAddress + 1 : bankStart;
		results.push_back(DisassemblyResult(prevAddress, LineFlags::BlockStart | LineFlags::UnmappedMemory));
		results.push_back(DisassemblyResult(prevAddress, LineFlags::UnmappedMemory | LineFlags::Empty));
		results.push_back(DisassemblyResult(relAddress.Address - 1, LineFlags::BlockEnd | LineFlags::UnmappedMemory));
		inUnmappedBlock = false;
	};
	for(int32_t i = bankStart; i < bankEnd; i++) {
		relAddress.Address = i;
		addrInfo = _console->GetAbsoluteAddress(relAddress);
		if(addrInfo.Address < 0 || addrInfo.Type == MemoryType::SnesRegister) {
			pushEndBlock();
			inUnmappedBlock = true;
			continue;
		}
		if(inUnmappedBlock) {
			pushUnmappedBlock();
		}
		DisassemblerSource& src = GetSource(addrInfo.Type);
		DisassemblyInfo disassemblyInfo = src.Cache[addrInfo.Address];
		CodeDataLogger* cdl = _debugger->GetCdlManager()->GetCodeDataLogger(addrInfo.Type);
		uint8_t opSize = 0;
		bool isCode = cdl ? cdl->IsCode(addrInfo.Address) : false;
		bool isData = cdl ? cdl->IsData(addrInfo.Address) : false;
		if(disassemblyInfo.IsInitialized()) {
			opSize = disassemblyInfo.GetOpSize();
		} else if((isData && disData) || (!isData && !isCode && disUnident)) {
			disassemblyInfo.Initialize(i, cpuFlags[addrInfo.Address & 0x03], cpuType, relAddress.Type, _memoryDumper);
			opSize = disassemblyInfo.GetOpSize();
		}
		if(opSize > 0) {
			pushEndBlock();
			if(cdl && cdl->IsSubEntryPoint(addrInfo.Address)) {
				results.push_back(DisassemblyResult(addrInfo, i, LineFlags::SubStart | LineFlags::BlockStart | LineFlags::VerifiedCode | LineFlags::Empty));
			}
			if(_labelManager->GetLabelAndComment(addrInfo, labelInfo)) {
				bool hasMultipleComment = labelInfo.Comment.find_first_of('\n') != string::npos;
				if(hasMultipleComment) {
					int16_t lineCount = 0;
					for(char c : labelInfo.Comment) {
						if(c == '\n') {
							results.push_back(DisassemblyResult(addrInfo, i, LineFlags::Comment, lineCount));
							lineCount++;
						}
					}
					results.push_back(DisassemblyResult(addrInfo, i, LineFlags::Comment, lineCount));
				}
				if(labelInfo.Label.size()) {
					results.push_back(DisassemblyResult(addrInfo, i, LineFlags::Label));
				} else if(showJumpLabels && cdl && (cdl->IsJumpTarget(addrInfo.Address) || cdl->IsSubEntryPoint(addrInfo.Address))) {
					results.push_back(DisassemblyResult(addrInfo, i, LineFlags::Label));
				}
				if(!hasMultipleComment && labelInfo.Comment.size()) {
					results.push_back(DisassemblyResult(addrInfo, i, LineFlags::Comment));
				} else {
					results.push_back(DisassemblyResult(addrInfo, i));
				}
			} else if(showJumpLabels && cdl && (cdl->IsJumpTarget(addrInfo.Address) || cdl->IsSubEntryPoint(addrInfo.Address))) {
				results.push_back(DisassemblyResult(addrInfo, i, LineFlags::Label));
				results.push_back(DisassemblyResult(addrInfo, i));
			} else {
				results.push_back(DisassemblyResult(addrInfo, i));
			}
			if(disassemblyInfo.IsReturnInstruction()) {
				results.push_back(DisassemblyResult(i, LineFlags::VerifiedCode | LineFlags::BlockEnd | LineFlags::Empty));
			}
			MemoryType prevMemType = addrInfo.Type;
			for(int j = 1; j < opSize && i + j < bankEnd; j++) {
				relAddress.Address = i + 1;
				addrInfo = _console->GetAbsoluteAddress(relAddress);
				if(addrInfo.Type != prevMemType || addrInfo.Address < 0 || src.Cache[addrInfo.Address].IsInitialized()) {
					break;
				}
				i++;
			}
		} else {
			if(showData || showUnident) {
				if((isData && inUnknownBlock) || (!isData && inVerifiedBlock)) {
					pushEndBlock();
				}
			}
			if(byteCounter > 0) {
				byteCounter--;
				if(byteCounter == 0) {
					results[results.size() - 1].SetByteCount(bytesPerRow);
					results.push_back(DisassemblyResult(addrInfo, i, LineFlags::ShowAsData | (isData ? LineFlags::VerifiedData : 0), bytesPerRow));
					byteCounter = bytesPerRow;
				}
			} else if(!inUnknownBlock && !inVerifiedBlock) {
				bool showAsData = (isData && showData) || ((!isData && !isCode) && showUnident);
				if(isData) {
					inVerifiedBlock = true;
					results.push_back(DisassemblyResult(addrInfo, i, LineFlags::BlockStart | LineFlags::VerifiedData | (showAsData ? LineFlags::ShowAsData : 0)));
				} else {
					inUnknownBlock = true;
					results.push_back(DisassemblyResult(addrInfo, i, LineFlags::BlockStart | (showAsData ? LineFlags::ShowAsData : 0)));
				}
				if(showAsData) {
					results.push_back(DisassemblyResult(addrInfo, i, LineFlags::ShowAsData | (isData ? LineFlags::VerifiedData : 0)));
					byteCounter = bytesPerRow;
				} else {
					results.push_back(DisassemblyResult(addrInfo, i, LineFlags::Empty | (isData ? LineFlags::VerifiedData : 0)));
				}
			}
			prevAddrInfo = addrInfo;
		}
	}
	relAddress.Address = bankEnd;
	pushEndBlock();
	if(inUnmappedBlock) {
		pushUnmappedBlock();
	}
	return results;
}
void Disassembler::GetLineData(DisassemblyResult& row, CpuType type, MemoryType memType, CodeLineData& data)
{
	data.Address = row.CpuAddress;
	data.AbsoluteAddress = row.Address;
	data.EffectiveAddress = {};
	data.Value = 0;
	data.Flags = row.Flags;
	data.LineCpuType = type;
	switch(row.Address.Type) {
		default: break;
		case MemoryType::GbPrgRom:
		case MemoryType::SnesPrgRom:
		case MemoryType::NesPrgRom:
		case MemoryType::PcePrgRom:
			data.Flags |= (uint8_t)LineFlags::PrgRom;
			break;
		case MemoryType::GbWorkRam:
		case MemoryType::SnesWorkRam:
		case MemoryType::NesWorkRam:
		case MemoryType::PceWorkRam:
			data.Flags |= (uint8_t)LineFlags::WorkRam;
			break;
		case MemoryType::GbCartRam:
		case MemoryType::SnesSaveRam:
		case MemoryType::NesSaveRam:
		case MemoryType::PceSaveRam:
			data.Flags |= (uint8_t)LineFlags::SaveRam;
			break;
	}
	bool showMemoryValues = _settings->GetDebugConfig().ShowMemoryValues;
	bool isBlockStartEnd = (data.Flags & (LineFlags::BlockStart | LineFlags::BlockEnd | LineFlags::Empty)) != 0;
	if(!isBlockStartEnd && row.Address.Address >= 0) {
		if((data.Flags & LineFlags::ShowAsData)) {
			FastString str(".db", 3);
			for(int i = 0; i < row.GetByteCount(); i++) {
				str.Write(" $", 2);
				str.Write(HexUtilities::ToHexChar(_memoryDumper->GetMemoryValue(memType, row.CpuAddress + i)), 2);
			}
			data.OpSize = row.GetByteCount();
			memcpy(data.Text, str.ToString(), str.GetSize() + 1);
		} else if((data.Flags & LineFlags::Comment) && row.CommentLine >= 0) {
			string comment = ";" + StringUtilities::Split(_labelManager->GetComment(row.Address), '\n')[row.CommentLine];
			data.Flags |= LineFlags::VerifiedCode;
			memcpy(data.Comment, comment.c_str(), std::min<int>((int)comment.size() + 1, 1000));
		} else if(data.Flags & LineFlags::Label) {
			string label = _labelManager->GetLabel(row.Address);
			if(label.empty()) {
				label = "$" + DebugUtilities::AddressToHex(type, row.CpuAddress);
				if(_settings->GetDebugConfig().UseLowerCaseDisassembly) {
					std::transform(label.begin(), label.end(), label.begin(), ::tolower);
				}
			}
			label += ":";
			data.Flags |= LineFlags::VerifiedCode;
			memcpy(data.Text, label.c_str(), std::min<int>((int)label.size() + 1, 1000));
		} else {
			DisassemblerSource& src = GetSource(row.Address.Type);
			DisassemblyInfo disInfo = src.Cache[row.Address.Address];
			CpuType lineCpuType = type != CpuType::Sa1 && disInfo.IsInitialized() ? disInfo.GetCpuType() : type;
			data.LineCpuType = lineCpuType;
			CdlManager* cdlManager = _debugger->GetCdlManager();
			switch(lineCpuType) {
				case CpuType::Snes:
				case CpuType::Sa1:
				{
					SnesCpuState state = (SnesCpuState&)_debugger->GetCpuStateRef(lineCpuType);
					state.PC = (uint16_t)row.CpuAddress;
					state.K = (row.CpuAddress >> 16);
					CodeDataLogger* cdl = cdlManager->GetCodeDataLogger(row.Address.Type);
					if(!disInfo.IsInitialized()) {
						disInfo = DisassemblyInfo(row.Address.Address, state.PS, lineCpuType, row.Address.Type, _memoryDumper);
					} else {
						data.Flags |= (!cdl || cdl->IsCode(data.AbsoluteAddress.Address)) ? LineFlags::VerifiedCode : LineFlags::UnexecutedCode;
					}
					data.OpSize = disInfo.GetOpSize();
					data.EffectiveAddress = disInfo.GetEffectiveAddress(_debugger, &state, lineCpuType);
					if(showMemoryValues && data.EffectiveAddress.ValueSize >= 0) {
						data.Value = disInfo.GetMemoryValue(data.EffectiveAddress, _memoryDumper, memType);
					}
					break;
				}
				case CpuType::Spc:
				{
					SpcState state = (SpcState&)_debugger->GetCpuStateRef(lineCpuType);
					state.PC = (uint16_t)row.CpuAddress;
					if(!disInfo.IsInitialized()) {
						disInfo = DisassemblyInfo(row.Address.Address, 0, CpuType::Spc, row.Address.Type, _memoryDumper);
					} else {
						data.Flags |= LineFlags::VerifiedCode;
					}
					data.OpSize = disInfo.GetOpSize();
					data.EffectiveAddress = disInfo.GetEffectiveAddress(_debugger, &state, lineCpuType);
					if(showMemoryValues && data.EffectiveAddress.ValueSize >= 0) {
						data.Value = disInfo.GetMemoryValue(data.EffectiveAddress, _memoryDumper, memType);
					}
					break;
				}
				case CpuType::Gsu:
				{
					GsuState state = (GsuState&)_debugger->GetCpuStateRef(lineCpuType);
					state.R[15] = (uint16_t)row.CpuAddress;
					state.ProgramBank = (row.CpuAddress >> 16);
					if(!disInfo.IsInitialized()) {
						disInfo = DisassemblyInfo(row.Address.Address, 0, CpuType::Gsu, row.Address.Type, _memoryDumper);
					} else {
						data.Flags |= LineFlags::VerifiedCode;
					}
					data.OpSize = disInfo.GetOpSize();
					data.EffectiveAddress = disInfo.GetEffectiveAddress(_debugger, &state, lineCpuType);
					if(showMemoryValues && data.EffectiveAddress.ValueSize >= 0) {
						data.Value = disInfo.GetMemoryValue(data.EffectiveAddress, _memoryDumper, memType);
					}
					break;
				}
				case CpuType::NecDsp:
					if(!disInfo.IsInitialized()) {
						disInfo = DisassemblyInfo(row.Address.Address, 0, type, row.Address.Type, _memoryDumper);
					} else {
						data.Flags |= LineFlags::VerifiedCode;
					}
					data.OpSize = disInfo.GetOpSize();
					break;
				case CpuType::Cx4:
				{
					Cx4State state = (Cx4State&)_debugger->GetCpuStateRef(lineCpuType);
					if(!disInfo.IsInitialized()) {
						disInfo = DisassemblyInfo(row.Address.Address, 0, type, row.Address.Type, _memoryDumper);
					} else {
						data.Flags |= LineFlags::VerifiedCode;
					}
					data.OpSize = disInfo.GetOpSize();
					data.EffectiveAddress = disInfo.GetEffectiveAddress(_debugger, &state, lineCpuType);
					if(showMemoryValues && data.EffectiveAddress.ValueSize >= 0) {
						data.Value = disInfo.GetMemoryValue(data.EffectiveAddress, _memoryDumper, memType);
					}
					break;
				}
				case CpuType::St018:
				{
					ArmV3CpuState state = (ArmV3CpuState&)_debugger->GetCpuStateRef(lineCpuType);
					if(!disInfo.IsInitialized()) {
						disInfo = DisassemblyInfo(row.Address.Address, state.CPSR.ToInt32(), CpuType::St018, row.Address.Type, _memoryDumper);
					} else {
						data.Flags |= LineFlags::VerifiedCode;
					}
					data.OpSize = disInfo.GetOpSize();
					state.Pipeline.Execute.Address = (uint32_t)row.CpuAddress;
					state.R[15] = state.Pipeline.Execute.Address + (data.OpSize * 2);
					data.EffectiveAddress = disInfo.GetEffectiveAddress(_debugger, &state, lineCpuType);
					if(showMemoryValues && data.EffectiveAddress.ValueSize >= 0) {
						data.Value = disInfo.GetMemoryValue(data.EffectiveAddress, _memoryDumper, memType);
					}
					break;
				}
				case CpuType::Gameboy:
				{
					GbCpuState state = (GbCpuState&)_debugger->GetCpuStateRef(lineCpuType);
					state.PC = (uint16_t)row.CpuAddress;
					CodeDataLogger* cdl = cdlManager->GetCodeDataLogger(row.Address.Type);
					if(!disInfo.IsInitialized()) {
						disInfo = DisassemblyInfo(row.Address.Address, 0, CpuType::Gameboy, row.Address.Type, _memoryDumper);
					} else {
						data.Flags |= (!cdl || cdl->IsCode(data.AbsoluteAddress.Address)) ? LineFlags::VerifiedCode : LineFlags::UnexecutedCode;
					}
					data.OpSize = disInfo.GetOpSize();
					data.EffectiveAddress = disInfo.GetEffectiveAddress(_debugger, &state, lineCpuType);
					if(showMemoryValues && data.EffectiveAddress.ValueSize >= 0) {
						data.Value = disInfo.GetMemoryValue(data.EffectiveAddress, _memoryDumper, memType);
					}
					break;
				}
				case CpuType::Nes:
				{
					NesCpuState state = (NesCpuState&)_debugger->GetCpuStateRef(lineCpuType);
					state.PC = (uint16_t)row.CpuAddress;
					CodeDataLogger* cdl = cdlManager->GetCodeDataLogger(row.Address.Type);
					if(!disInfo.IsInitialized()) {
						disInfo = DisassemblyInfo(row.Address.Address, 0, CpuType::Nes, row.Address.Type, _memoryDumper);
					} else {
						data.Flags |= (!cdl || cdl->IsCode(data.AbsoluteAddress.Address)) ? LineFlags::VerifiedCode : LineFlags::UnexecutedCode;
					}
					data.OpSize = disInfo.GetOpSize();
					data.EffectiveAddress = disInfo.GetEffectiveAddress(_debugger, &state, lineCpuType);
					if(showMemoryValues && data.EffectiveAddress.ValueSize >= 0) {
						data.Value = disInfo.GetMemoryValue(data.EffectiveAddress, _memoryDumper, memType);
					}
					break;
				}
				case CpuType::Pce:
				{
					PceCpuState state = (PceCpuState&)_debugger->GetCpuStateRef(lineCpuType);
					state.PC = (uint16_t)row.CpuAddress;
					CodeDataLogger* cdl = cdlManager->GetCodeDataLogger(row.Address.Type);
					if(!disInfo.IsInitialized()) {
						disInfo = DisassemblyInfo(row.Address.Address, 0, CpuType::Pce, row.Address.Type, _memoryDumper);
					} else {
						data.Flags |= (!cdl || cdl->IsCode(data.AbsoluteAddress.Address)) ? LineFlags::VerifiedCode : LineFlags::UnexecutedCode;
					}
					data.OpSize = disInfo.GetOpSize();
					data.EffectiveAddress = disInfo.GetEffectiveAddress(_debugger, &state, lineCpuType);
					if(showMemoryValues && data.EffectiveAddress.ValueSize >= 0) {
						data.Value = disInfo.GetMemoryValue(data.EffectiveAddress, _memoryDumper, memType);
					}
					break;
				}
				case CpuType::Sms:
				{
					SmsCpuState state = (SmsCpuState&)_debugger->GetCpuStateRef(lineCpuType);
					state.PC = (uint16_t)row.CpuAddress;
					CodeDataLogger* cdl = cdlManager->GetCodeDataLogger(row.Address.Type);
					if(!disInfo.IsInitialized()) {
						disInfo = DisassemblyInfo(row.Address.Address, 0, CpuType::Sms, row.Address.Type, _memoryDumper);
					} else {
						data.Flags |= (!cdl || cdl->IsCode(data.AbsoluteAddress.Address)) ? LineFlags::VerifiedCode : LineFlags::UnexecutedCode;
					}
					data.OpSize = disInfo.GetOpSize();
					data.EffectiveAddress = disInfo.GetEffectiveAddress(_debugger, &state, lineCpuType);
					if(showMemoryValues && data.EffectiveAddress.ValueSize >= 0) {
						data.Value = disInfo.GetMemoryValue(data.EffectiveAddress, _memoryDumper, memType);
					}
					break;
				}
				case CpuType::Gba:
				{
					GbaCpuState state = (GbaCpuState&)_debugger->GetCpuStateRef(lineCpuType);
					CodeDataLogger* cdl = cdlManager->GetCodeDataLogger(row.Address.Type);
					if(!disInfo.IsInitialized()) {
						disInfo = DisassemblyInfo(row.Address.Address, _debugger->GetMainDebugger()->GetCpuFlags(row.Address.Address), CpuType::Gba, row.Address.Type, _memoryDumper);
					} else {
						data.Flags |= (!cdl || cdl->IsCode(data.AbsoluteAddress.Address)) ? LineFlags::VerifiedCode : LineFlags::UnexecutedCode;
					}
					data.OpSize = disInfo.GetOpSize();
					state.CPSR.Thumb = data.OpSize == 2;
					state.Pipeline.Execute.Address = (uint32_t)row.CpuAddress;
					state.R[15] = state.Pipeline.Execute.Address + (data.OpSize * 2);
					data.EffectiveAddress = disInfo.GetEffectiveAddress(_debugger, &state, lineCpuType);
					if(showMemoryValues && data.EffectiveAddress.ValueSize >= 0) {
						data.Value = disInfo.GetMemoryValue(data.EffectiveAddress, _memoryDumper, memType);
					}
					break;
				}
				case CpuType::Ws:
				{
					WsCpuState state = (WsCpuState&)_debugger->GetCpuStateRef(lineCpuType);
					WsDisUtils::UpdateAddressCsIp(row.CpuAddress, state);
					CodeDataLogger* cdl = cdlManager->GetCodeDataLogger(row.Address.Type);
					if(!disInfo.IsInitialized()) {
						disInfo = DisassemblyInfo(row.Address.Address, 0, CpuType::Ws, row.Address.Type, _memoryDumper);
					} else {
						data.Flags |= (!cdl || cdl->IsCode(data.AbsoluteAddress.Address)) ? LineFlags::VerifiedCode : LineFlags::UnexecutedCode;
					}
					data.OpSize = disInfo.GetOpSize();
					data.EffectiveAddress = disInfo.GetEffectiveAddress(_debugger, &state, lineCpuType);
					if(showMemoryValues && data.EffectiveAddress.ValueSize >= 0) {
						data.Value = disInfo.GetMemoryValue(data.EffectiveAddress, _memoryDumper, memType);
					}
					break;
				}
			}
			if(!showMemoryValues) {
				data.EffectiveAddress.ValueSize = 0;
			}
			string text;
			disInfo.GetDisassembly(text, row.CpuAddress, _labelManager, _settings);
			memcpy(data.Text, text.c_str(), std::min<int>((int)text.size() + 1, 1000));
			disInfo.GetByteCode(data.ByteCode);
			if(data.Flags & LineFlags::Comment) {
				string comment = ";" + _labelManager->GetComment(row.Address);
				memcpy(data.Comment, comment.c_str(), std::min<int>((int)comment.size() + 1, 1000));
			} else {
				data.Comment[0] = 0;
			}
		}
	} else {
		if(data.Flags & LineFlags::SubStart) {
			string label = _labelManager->GetLabel(row.Address);
			if(label.empty()) {
				label = "sub start";
			}
			memcpy(data.Text, label.c_str(), label.size() + 1);
		} else if(data.Flags & LineFlags::BlockStart) {
			string label = (data.Flags & LineFlags::VerifiedData) ? "data" : "unidentified";
			if(data.Flags & LineFlags::UnmappedMemory) {
				label = "unmapped";
			}
			memcpy(data.Text, label.c_str(), label.size() + 1);
		}
	}
}
int32_t Disassembler::GetMatchingRow(vector<DisassemblyResult>& rows, uint32_t address, bool returnFirstRow)
{
	int32_t i;
	for(i = 0; i < (int32_t)rows.size(); i++) {
		if(rows[i].CpuAddress == (int32_t)address) {
			if(i + 1 >= rows.size() || rows[i + 1].CpuAddress != (int32_t)address || address == 0 || returnFirstRow) {
				break;
			}
		} else if(rows[i].CpuAddress > (int32_t)address) {
			while(i > 0 && (rows[i].CpuAddress > (int32_t)address || rows[i].CpuAddress < 0)) {
				i--;
			}
			break;
		}
	}
	return std::max(0, i);
}
uint32_t Disassembler::GetDisassemblyOutput(CpuType type, uint32_t address, CodeLineData output[], uint32_t rowCount)
{
	uint16_t bank = address >> 16;
	Timer timer;
	vector<DisassemblyResult> rows = Disassemble(type, bank);
	int32_t i = GetMatchingRow(rows, address, true);
	if(i >= (int32_t)rows.size()) {
		return 0;
	}
	MemoryType memType = DebugUtilities::GetCpuMemoryType(type);
	uint32_t maxBank = (_memoryDumper->GetMemorySize(memType) - 1) >> 16;
	int32_t row;
	for(row = 0; row < (int32_t)rowCount; row++){
		if(row + i >= rows.size()) {
			if(bank < maxBank) {
				bank++;
				rows = Disassemble(type, bank);
				if(rows.size() == 0) {
					break;
				}
				i = -row;
			} else {
				break;
			}
		}
		GetLineData(rows[row + i], type, memType, output[row]);
	}
	return row;
}
uint16_t Disassembler::GetMaxBank(CpuType cpuType)
{
	AddressInfo relAddress = {};
	relAddress.Type = DebugUtilities::GetCpuMemoryType(cpuType);
	return (_memoryDumper->GetMemorySize(relAddress.Type) - 1) >> 16;
}
int32_t Disassembler::GetDisassemblyRowAddress(CpuType cpuType, uint32_t address, int32_t rowOffset)
{
	uint16_t bank = address >> 16;
	vector<DisassemblyResult> rows = Disassemble(cpuType, bank);
	int32_t len = (int32_t)rows.size();
	if(len == 0) {
		return address;
	}
	uint16_t maxBank = GetMaxBank(cpuType);
	int32_t i = GetMatchingRow(rows, address, false);
	if(rowOffset > 0) {
		while(len > 0) {
			for(; i < len; i++) {
				if(rowOffset <= 0 && rows[i].CpuAddress >= 0 && rows[i].CpuAddress != (int32_t)address) {
					return rows[i].CpuAddress;
				}
				rowOffset--;
			}
			if(bank == maxBank) {
				return rows[len - 1].CpuAddress >= 0 ? rows[len - 1].CpuAddress : address;
			}
			bank++;
			rows = Disassemble(cpuType, bank);
			len = (int32_t)rows.size();
			i = 0;
		}
	} else if(rowOffset < 0) {
		while(len > 0) {
			for(; i >= 0; i--) {
				if(rowOffset >= 0 && rows[i].CpuAddress >= 0 && rows[i].CpuAddress != (int32_t)address) {
					return rows[i].CpuAddress;
				}
				rowOffset++;
			}
			if(bank == 0) {
				return rows[0].CpuAddress >= 0 ? rows[0].CpuAddress : address;
			}
			bank--;
			rows = Disassemble(cpuType, bank);
			len = (int32_t)rows.size();
			i = len - 1;
		}
	}
	return address;
}
```

## File: Core/Debugger/IDebugger.h
```
#pragma once
#include "pch.h"
#include "Debugger/DebuggerFeatures.h"
#include "Debugger/DebugTypes.h"
#include "Debugger/StepBackManager.h"
#include "Debugger/FrozenAddressManager.h"
enum class StepType;
class BreakpointManager;
class CallstackManager;
class IAssembler;
class BaseEventManager;
class CodeDataLogger;
class ITraceLogger;
class PpuTools;
class Emulator;
struct BaseState;
enum class EventType;
enum class MemoryOperationType;
class IDebugger
{
protected:
	unique_ptr<StepRequest> _step;
	unique_ptr<StepBackManager> _stepBackManager;
	FrozenAddressManager _frozenAddressManager;
public:
	bool IgnoreBreakpoints = false;
	bool AllowChangeProgramCounter = false;
	CpuInstructionProgress InstructionProgress = {};
	IDebugger(Emulator* emu) : _stepBackManager(new StepBackManager(emu, this)) {}
	virtual ~IDebugger() = default;
	StepRequest* GetStepRequest() { return _step.get(); }
	bool CheckStepBack() { return _stepBackManager->CheckStepBack(); }
	bool IsStepBack() { return _stepBackManager->IsRewinding(); }
	void ResetStepBackCache() { return _stepBackManager->ResetCache(); }
	void StepBack(int32_t stepCount) { return _stepBackManager->StepBack((StepBackType)stepCount); }
	virtual StepBackConfig GetStepBackConfig() { return { GetCpuCycleCount(), 0, 0 }; }
	FrozenAddressManager& GetFrozenAddressManager() { return _frozenAddressManager; }
	virtual void ResetPrevOpCode() {}
	virtual void OnBeforeBreak(CpuType cpuType) {}
	virtual void Step(int32_t stepCount, StepType type) = 0;
	virtual void Reset() = 0;
	virtual void Run() = 0;
	virtual void Init() {}
	virtual void ProcessConfigChange() {}
	virtual void ProcessInterrupt(uint32_t originalPc, uint32_t currentPc, bool forNmi) {}
	virtual void ProcessInputOverrides(DebugControllerState inputOverrides[8]) {}
	virtual void DrawPartialFrame() { }
	virtual DebuggerFeatures GetSupportedFeatures() { return {}; }
	virtual uint64_t GetCpuCycleCount(bool forProfiler = false) { return 0; }
	virtual uint32_t GetProgramCounter(bool getInstPc) = 0;
	virtual void SetProgramCounter(uint32_t addr, bool updateDebuggerOnly = false) = 0;
	virtual uint8_t GetCpuFlags(uint32_t addr) { return 0; }
	virtual BreakpointManager* GetBreakpointManager() = 0;
	virtual CallstackManager* GetCallstackManager() = 0;
	virtual IAssembler* GetAssembler() = 0;
	virtual BaseEventManager* GetEventManager() = 0;
	virtual ITraceLogger* GetTraceLogger() = 0;
	virtual PpuTools* GetPpuTools() { return nullptr; }
	virtual void GetRomHeader(uint8_t* headerData, uint32_t& size) {}
	virtual BaseState& GetState() = 0;
	virtual void GetPpuState(BaseState& state) {};
	virtual void SetPpuState(BaseState& state) {};
};
```

## File: Core/Debugger/LuaApi.cpp
```cpp
#include "pch.h"
#include "LuaApi.h"
#include "Lua/lua.hpp"
#include "Debugger/LuaCallHelper.h"
#include "Debugger/Debugger.h"
#include "Debugger/MemoryDumper.h"
#include "Debugger/ScriptingContext.h"
#include "Debugger/MemoryAccessCounter.h"
#include "Debugger/CdlManager.h"
#include "Debugger/LabelManager.h"
#include "Shared/SystemActionManager.h"
#include "Shared/Video/DebugHud.h"
#include "Shared/Video/VideoDecoder.h"
#include "Shared/MessageManager.h"
#include "Shared/CheatManager.h"
#include "Shared/RewindManager.h"
#include "Shared/SaveStateManager.h"
#include "Shared/Emulator.h"
#include "Shared/Video/BaseVideoFilter.h"
#include "Shared/Video/VideoRenderer.h"
#include "Shared/Video/DrawScreenBufferCommand.h"
#include "Shared/Video/DrawStringCommand.h"
#include "Shared/KeyManager.h"
#include "Shared/Interfaces/IConsole.h"
#include "Shared/Interfaces/IKeyManager.h"
#include "Shared/ControllerHub.h"
#include "Shared/BaseControlManager.h"
#include "Utilities/HexUtilities.h"
#include "Utilities/FolderUtilities.h"
#include "Utilities/magic_enum.hpp"
#include "Shared/MemoryOperationType.h"
#ifdef _MSC_VER
#pragma warning ( disable : 4702 )
#endif
#define lua_pushintvalue(name, value) lua_pushliteral(lua, #name); lua_pushinteger(lua, (int)value); lua_settable(lua, -3);
#define lua_pushdoublevalue(name, value) lua_pushliteral(lua, #name); lua_pushnumber(lua, (double)value); lua_settable(lua, -3);
#define lua_pushboolvalue(name, value) lua_pushliteral(lua, #name); lua_pushboolean(lua, (int)value); lua_settable(lua, -3);
#define lua_pushstringvalue(name, value) lua_pushliteral(lua, #name); lua_pushstring(lua, value.c_str()); lua_settable(lua, -3);
#define lua_pusharrayvalue(index, value) lua_pushinteger(lua, index); lua_pushinteger(lua, value); lua_settable(lua, -3);
#define lua_starttable(name) lua_pushliteral(lua, #name); lua_newtable(lua);
#define lua_endtable() lua_settable(lua, -3);
#define lua_readint(name, dest) lua_getfield(lua, -1, #name); dest = l.ReadInteger();
#define lua_readbool(name, dest) lua_getfield(lua, -1, #name); dest = l.ReadBool();
#define error(text) luaL_error(lua, text); return 0;
#define errorCond(cond, text) if(cond) { luaL_error(lua, text); return 0; }
#define checkEnum(enumType, enumValue, text) if(!magic_enum::enum_contains<enumType>(enumValue)) { luaL_error(lua, text); return 0; }
#define checkparams() if(!l.CheckParamCount()) { return 0; }
#define checkminparams(x) if(!l.CheckParamCount(x)) { return 0; }
#define checkinitdone() if(!_context->CheckInitDone()) { error("This function cannot be called outside a callback"); }
#define checksavestateconditions() if(!_context->IsSaveStateAllowed()) { error("This function must be called inside an exec memory operation callback for the main CPU"); }
Debugger* LuaApi::_debugger = nullptr;
Emulator* LuaApi::_emu = nullptr;
MemoryDumper* LuaApi::_memoryDumper = nullptr;
ScriptingContext* LuaApi::_context = nullptr;
enum class AccessCounterType
{
	ReadCount,
	WriteCount,
	ExecCount,
	LastReadClock,
	LastWriteClock,
	LastExecClock
};
void LuaApi::SetContext(ScriptingContext* context)
{
	_context = context;
	_debugger = _context->GetDebugger();
	_memoryDumper = _debugger->GetMemoryDumper();
	_emu = _debugger->GetEmulator();
}
void LuaApi::LuaPushIntValue(lua_State* lua, string name, int value)
{
	lua_pushstring(lua, name.c_str());
	lua_pushinteger(lua, value);
	lua_settable(lua, -3);
}
int LuaApi::GetLibrary(lua_State *lua)
{
	static const luaL_Reg apilib[] = {
		{ "getMemorySize", LuaApi::GetMemorySize },
		{ "read", LuaApi::ReadMemory },
		{ "write", LuaApi::WriteMemory },
		{ "read16", LuaApi::ReadMemory16 },
		{ "write16", LuaApi::WriteMemory16 },
		{ "read32", LuaApi::ReadMemory32 },
		{ "write32", LuaApi::WriteMemory32 },
		{ "readWord", LuaApi::ReadMemory16 },
		{ "writeWord", LuaApi::WriteMemory16 },
		{ "convertAddress", LuaApi::ConvertAddress },
		{ "getLabelAddress", LuaApi::GetLabelAddress },
		{ "addMemoryCallback", LuaApi::RegisterMemoryCallback },
		{ "removeMemoryCallback", LuaApi::UnregisterMemoryCallback },
		{ "addEventCallback", LuaApi::RegisterEventCallback },
		{ "removeEventCallback", LuaApi::UnregisterEventCallback },
		{ "measureString", LuaApi::MeasureString },
		{ "drawString", LuaApi::DrawString },
		{ "drawPixel", LuaApi::DrawPixel },
		{ "drawLine", LuaApi::DrawLine },
		{ "drawRectangle", LuaApi::DrawRectangle },
		{ "clearScreen", LuaApi::ClearScreen },
		{ "getScreenSize", LuaApi::GetScreenSize },
		{ "getDrawSurfaceSize", LuaApi::GetDrawSurfaceSize },
		{ "getScreenBuffer", LuaApi::GetScreenBuffer },
		{ "setScreenBuffer", LuaApi::SetScreenBuffer },
		{ "getPixel", LuaApi::GetPixel },
		{ "getMouseState", LuaApi::GetMouseState },
		{ "log", LuaApi::Log },
		{ "displayMessage", LuaApi::DisplayMessage },
		{ "reset", LuaApi::Reset },
		{ "stop", LuaApi::Stop },
		{ "breakExecution", LuaApi::BreakExecution },
		{ "resume", LuaApi::Resume },
		{ "step", LuaApi::Step },
		{ "rewind", LuaApi::Rewind },
		{ "takeScreenshot", LuaApi::TakeScreenshot },
		{ "isKeyPressed", LuaApi::IsKeyPressed },
		{ "getInput", LuaApi::GetInput },
		{ "setInput", LuaApi::SetInput },
		{ "getAccessCounters", LuaApi::GetAccessCounters },
		{ "resetAccessCounters", LuaApi::ResetAccessCounters },
		{ "getCdlData", LuaApi::GetCdlData},
		{ "addCheat", LuaApi::AddCheat },
		{ "clearCheats", LuaApi::ClearCheats },
		{ "createSavestate", LuaApi::CreateSavestate },
		{ "loadSavestate", LuaApi::LoadSavestate },
		{ "getState", LuaApi::GetState },
		{ "setState", LuaApi::SetState },
		{ "selectDrawSurface", LuaApi::SelectDrawSurface },
		{ "getScriptDataFolder", LuaApi::GetScriptDataFolder },
		{ "getRomInfo", LuaApi::GetRomInfo },
		{ "getLogWindowLog", LuaApi::GetLogWindowLog },
		{ NULL,NULL }
	};
	luaL_newlib(lua, apilib);
	lua_pushliteral(lua, "memType");
	lua_newtable(lua);
	for(auto& entry : magic_enum::enum_entries<MemoryType>()) {
		string name = string(entry.second);
		name[0] = ::tolower(name[0]);
		if(DebugUtilities::IsRelativeMemory(entry.first)) {
			string debugName = name.substr(0, name.size() - 6) + "Debug";
			LuaPushIntValue(lua, debugName, (int)entry.first | 0x100);
		}
		LuaPushIntValue(lua, name, (int)entry.first);
	}
	lua_settable(lua, -3);
	GenerateEnumDefinition<CallbackType>(lua, "callbackType");
	GenerateEnumDefinition<CheatType>(lua, "cheatType");
	GenerateEnumDefinition<AccessCounterType>(lua, "counterType");
	GenerateEnumDefinition<CpuType>(lua, "cpuType");
	GenerateEnumDefinition<ScriptDrawSurface>(lua, "drawSurface");
	GenerateEnumDefinition<EventType>(lua, "eventType", { EventType::LastValue });
	GenerateEnumDefinition<StepType>(lua, "stepType", { StepType::StepBack });
	return 1;
}
template<typename T>
void LuaApi::GenerateEnumDefinition(lua_State* lua, string enumName, unordered_set<T> excludedValues)
{
	lua_pushstring(lua, enumName.c_str());
	lua_newtable(lua);
	for(auto& entry : magic_enum::enum_entries<T>()) {
		if(excludedValues.find(entry.first) == excludedValues.end()) {
			string name = string(entry.second);
			name[0] = ::tolower(name[0]);
			LuaPushIntValue(lua, name, (int)entry.first);
		}
	}
	lua_settable(lua, -3);
}
DebugHud* LuaApi::GetHud()
{
	if(_context->GetDrawSurface() == ScriptDrawSurface::ConsoleScreen) {
		return _emu->GetDebugHud();
	} else {
		return _emu->GetScriptHud();
	}
}
int LuaApi::SelectDrawSurface(lua_State* lua)
{
	LuaCallHelper l(lua);
	l.ForceParamCount(2);
	int surfaceScale = l.ReadInteger(-1);
	ScriptDrawSurface surface = (ScriptDrawSurface)l.ReadInteger();
	checkminparams(1);
	if(surfaceScale != -1) {
		errorCond(surface == ScriptDrawSurface::ConsoleScreen && surfaceScale != 1, "scale for the console screen must be 1");
		errorCond(surface == ScriptDrawSurface::ScriptHud && (surfaceScale < 1 || surfaceScale > 4), "scale for the script HUD must be between 1 and 4");
	}
	checkEnum(ScriptDrawSurface, surface, "invalid draw surface value");
	_context->SetDrawSurface(surface);
	if(surfaceScale != -1 && surface == ScriptDrawSurface::ScriptHud) {
		_emu->GetVideoRenderer()->SetScriptHudScale(surfaceScale);
	}
	return 0;
}
int LuaApi::GetMemorySize(lua_State* lua)
{
	LuaCallHelper l(lua);
	MemoryType memType = (MemoryType)l.ReadInteger();
	checkEnum(MemoryType, memType, "invalid memory type");
	l.Return(_memoryDumper->GetMemorySize(memType));
	return l.ReturnCount();
}
int LuaApi::ReadMemory(lua_State *lua)
{
	LuaCallHelper l(lua);
	l.ForceParamCount(3);
	bool returnSignedValue = l.ReadBool();
	int type = l.ReadInteger();
	bool disableSideEffects = (type & 0x100) == 0x100;
	MemoryType memType = (MemoryType)(type & 0xFF);
	int address = l.ReadInteger();
	checkminparams(2);
	errorCond(address < 0, "address must be >= 0");
	checkEnum(MemoryType, memType, "invalid memory type");
	uint8_t value = _memoryDumper->GetMemoryValue(memType, address, disableSideEffects);
	l.Return(returnSignedValue ? (int8_t)value : value);
	return l.ReturnCount();
}
int LuaApi::WriteMemory(lua_State *lua)
{
	LuaCallHelper l(lua);
	int type = l.ReadInteger();
	bool disableSideEffects = (type & 0x100) == 0x100;
	MemoryType memType = (MemoryType)(type & 0xFF);
	int value = l.ReadInteger();
	int address = l.ReadInteger();
	checkparams();
	errorCond(value > 255 || value < -128, "value out of range");
	errorCond(address < 0, "address must be >= 0");
	checkEnum(MemoryType, memType, "invalid memory type");
	_memoryDumper->SetMemoryValue(memType, address, value, disableSideEffects);
	return l.ReturnCount();
}
int LuaApi::ReadMemory16(lua_State *lua)
{
	LuaCallHelper l(lua);
	l.ForceParamCount(3);
	bool returnSignedValue = l.ReadBool();
	int type = l.ReadInteger();
	bool disableSideEffects = (type & 0x100) == 0x100;
	MemoryType memType = (MemoryType)(type & 0xFF);
	int address = l.ReadInteger();
	checkminparams(2);
	errorCond(address < 0, "address must be >= 0");
	checkEnum(MemoryType, memType, "invalid memory type");
	uint16_t value = _memoryDumper->GetMemoryValue16(memType, address, disableSideEffects);
	l.Return(returnSignedValue ? (int16_t)value : value);
	return l.ReturnCount();
}
int LuaApi::ReadMemory32(lua_State* lua)
{
	LuaCallHelper l(lua);
	l.ForceParamCount(3);
	bool returnSignedValue = l.ReadBool();
	int type = l.ReadInteger();
	bool disableSideEffects = (type & 0x100) == 0x100;
	MemoryType memType = (MemoryType)(type & 0xFF);
	int address = l.ReadInteger();
	checkminparams(2);
	errorCond(address < 0, "address must be >= 0");
	checkEnum(MemoryType, memType, "invalid memory type");
	uint32_t value = _memoryDumper->GetMemoryValue32(memType, address, disableSideEffects);
	l.Return(returnSignedValue ? (int32_t)value : value);
	return l.ReturnCount();
}
int LuaApi::WriteMemory16(lua_State *lua)
{
	LuaCallHelper l(lua);
	int type = l.ReadInteger();
	bool disableSideEffects = (type & 0x100) == 0x100;
	MemoryType memType = (MemoryType)(type & 0xFF);
	int value = l.ReadInteger();
	int address = l.ReadInteger();
	checkparams();
	errorCond(value > 65535 || value < -32768, "value out of range");
	errorCond(address < 0, "address must be >= 0");
	checkEnum(MemoryType, memType, "invalid memory type");
	_memoryDumper->SetMemoryValue16(memType, address, value, disableSideEffects);
	return l.ReturnCount();
}
int LuaApi::WriteMemory32(lua_State* lua)
{
	LuaCallHelper l(lua);
	int type = l.ReadInteger();
	bool disableSideEffects = (type & 0x100) == 0x100;
	MemoryType memType = (MemoryType)(type & 0xFF);
	int value = l.ReadInteger();
	int address = l.ReadInteger();
	checkparams();
	errorCond(address < 0, "address must be >= 0");
	checkEnum(MemoryType, memType, "invalid memory type");
	_memoryDumper->SetMemoryValue32(memType, address, value, disableSideEffects);
	return l.ReturnCount();
}
int LuaApi::ConvertAddress(lua_State *lua)
{
	LuaCallHelper l(lua);
	l.ForceParamCount(3);
	CpuType cpuType = (CpuType)l.ReadInteger((uint32_t)_context->GetDefaultCpuType());
	MemoryType memType = (MemoryType)l.ReadInteger((uint32_t)_context->GetDefaultMemType());
	uint32_t address = l.ReadInteger();
	checkminparams(1);
	checkEnum(CpuType, cpuType, "invalid cpu type");
	checkEnum(MemoryType, memType, "invalid memory type");
	errorCond(address < 0 || address >= _memoryDumper->GetMemorySize(memType), "address is out of range");
	AddressInfo src { (int32_t)address, memType };
	AddressInfo result;
	if(DebugUtilities::IsRelativeMemory(memType)) {
		result = _debugger->GetAbsoluteAddress(src);
	} else {
		result = _debugger->GetRelativeAddress(src, cpuType);
	}
	if(result.Address < 0) {
		lua_pushnil(lua);
	} else {
		lua_newtable(lua);
		lua_pushintvalue(address, result.Address);
		lua_pushintvalue(memType, result.Type);
	}
	return 1;
}
int LuaApi::GetLabelAddress(lua_State* lua)
{
	LuaCallHelper l(lua);
	string label = l.ReadString();
	checkparams();
	errorCond(label.length() == 0, "label cannot be empty");
	LabelManager* labelManager = _debugger->GetLabelManager();
	AddressInfo addr = labelManager->GetLabelAbsoluteAddress(label);
	if(addr.Address < 0) {
		string mbLabel = label + "+0";
		addr = labelManager->GetLabelAbsoluteAddress(mbLabel);
	}
	if(addr.Address < 0) {
		lua_pushnil(lua);
	} else {
		lua_newtable(lua);
		lua_pushintvalue(address, addr.Address);
		lua_pushintvalue(memType, addr.Type);
	}
	return 1;
}
int LuaApi::RegisterMemoryCallback(lua_State *lua)
{
	LuaCallHelper l(lua);
	l.ForceParamCount(6);
	MemoryType memType = (MemoryType)l.ReadInteger((int)_context->GetDefaultMemType());
	CpuType cpuType = (CpuType)l.ReadInteger((int)_context->GetDefaultCpuType());
	int32_t endAddr = l.ReadInteger(-1);
	uint32_t startAddr = l.ReadInteger();
	CallbackType callbackType = (CallbackType)l.ReadInteger();
	int reference = l.GetReference();
	checkminparams(3);
	if(endAddr == -1) {
		endAddr = startAddr;
	}
	errorCond(startAddr < 0, "start address must be >= 0");
	errorCond(startAddr > (uint32_t)endAddr, "start address must be <= end address");
	checkEnum(CallbackType, callbackType, "invalid callback type");
	checkEnum(MemoryType, memType, "invalid memory type");
	checkEnum(CpuType, cpuType, "invalid cpu type");
	errorCond(reference == LUA_NOREF, "callback function could not be found");
	_context->RegisterMemoryCallback(callbackType, startAddr, endAddr, memType, cpuType, reference);
	_context->Log("Registered memory callback from $" + HexUtilities::ToHex((uint32_t)startAddr) + " to $" + HexUtilities::ToHex((uint32_t)endAddr));
	l.Return(reference);
	return l.ReturnCount();
}
int LuaApi::UnregisterMemoryCallback(lua_State *lua)
{
	LuaCallHelper l(lua);
	l.ForceParamCount(6);
	MemoryType memType = (MemoryType)l.ReadInteger((int)_context->GetDefaultMemType());
	CpuType cpuType = (CpuType)l.ReadInteger((int)_context->GetDefaultCpuType());
	int endAddr = l.ReadInteger(-1);
	int startAddr = l.ReadInteger();
	CallbackType callbackType = (CallbackType)l.ReadInteger();
	int reference = l.ReadInteger();
	checkminparams(3);
	if(endAddr == -1) {
		endAddr = startAddr;
	}
	errorCond(startAddr < 0, "start address must be >= 0");
	errorCond(startAddr > endAddr, "start address must be <= end address");
	checkEnum(CallbackType, callbackType, "invalid callback type");
	checkEnum(MemoryType, memType, "invalid memory type");
	checkEnum(CpuType, cpuType, "invalid cpu type");
	errorCond(reference == LUA_NOREF, "callback function could not be found");
	_context->UnregisterMemoryCallback(callbackType, startAddr, endAddr, memType, cpuType, reference);
	return l.ReturnCount();
}
int LuaApi::RegisterEventCallback(lua_State *lua)
{
	LuaCallHelper l(lua);
	EventType type = (EventType)l.ReadInteger();
	int reference = l.GetReference();
	checkparams();
	checkEnum(EventType, type, "invalid event type");
	errorCond(reference == LUA_NOREF, "callback function could not be found");
	_context->RegisterEventCallback(type, reference);
	l.Return(reference);
	return l.ReturnCount();
}
int LuaApi::UnregisterEventCallback(lua_State *lua)
{
	LuaCallHelper l(lua);
	EventType type = (EventType)l.ReadInteger();
	int reference = l.ReadInteger();
	checkparams();
	checkEnum(EventType, type, "invalid event type");
	errorCond(reference == LUA_NOREF, "callback function could not be found");
	_context->UnregisterEventCallback(type, reference);
	return l.ReturnCount();
}
int LuaApi::MeasureString(lua_State* lua)
{
	LuaCallHelper l(lua);
	l.ForceParamCount(2);
	int maxWidth = l.ReadInteger(0);
	string text = l.ReadString();
	checkminparams(1);
	TextSize size = DrawStringCommand::MeasureString(text, maxWidth);
	lua_newtable(lua);
	lua_pushintvalue(width, size.X);
	lua_pushintvalue(height, size.Y);
	return 1;
}
int LuaApi::DrawString(lua_State *lua)
{
	LuaCallHelper l(lua);
	l.ForceParamCount(8);
	int displayDelay = l.ReadInteger(0);
	int frameCount = l.ReadInteger(1);
	int maxWidth = l.ReadInteger(0);
	int backColor = l.ReadInteger(0);
	int color = l.ReadInteger(0xFFFFFF);
	string text = l.ReadString();
	int y = l.ReadInteger();
	int x = l.ReadInteger();
	checkminparams(3);
	int startFrame = _emu->GetFrameCount() + displayDelay;
	GetHud()->DrawString(x, y, text, color, backColor, frameCount, startFrame, maxWidth);
	return l.ReturnCount();
}
int LuaApi::DrawLine(lua_State *lua)
{
	LuaCallHelper l(lua);
	l.ForceParamCount(7);
	int displayDelay = l.ReadInteger(0);
	int frameCount = l.ReadInteger(1);
	int color = l.ReadInteger(0xFFFFFF);
	int y2 = l.ReadInteger();
	int x2 = l.ReadInteger();
	int y = l.ReadInteger();
	int x = l.ReadInteger();
	checkminparams(4);
	int startFrame = _emu->GetFrameCount() + displayDelay;
	GetHud()->DrawLine(x, y, x2, y2, color, frameCount, startFrame);
	return l.ReturnCount();
}
int LuaApi::DrawPixel(lua_State *lua)
{
	LuaCallHelper l(lua);
	l.ForceParamCount(5);
	int displayDelay = l.ReadInteger(0);
	int frameCount = l.ReadInteger(1);
	int color = l.ReadInteger();
	int y = l.ReadInteger();
	int x = l.ReadInteger();
	checkminparams(3);
	int startFrame = _emu->GetFrameCount() + displayDelay;
	GetHud()->DrawPixel(x, y, color, frameCount, startFrame);
	return l.ReturnCount();
}
int LuaApi::DrawRectangle(lua_State *lua)
{
	LuaCallHelper l(lua);
	l.ForceParamCount(8);
	int displayDelay = l.ReadInteger(0);
	int frameCount = l.ReadInteger(1);
	bool fill = l.ReadBool(false);
	int color = l.ReadInteger(0xFFFFFF);
	int height = l.ReadInteger();
	int width = l.ReadInteger();
	int y = l.ReadInteger();
	int x = l.ReadInteger();
	checkminparams(4);
	int startFrame = _emu->GetFrameCount() + displayDelay;
	GetHud()->DrawRectangle(x, y, width, height, color, fill, frameCount, startFrame);
	return l.ReturnCount();
}
int LuaApi::ClearScreen(lua_State *lua)
{
	LuaCallHelper l(lua);
	checkparams();
	_emu->GetDebugHud()->ClearScreen();
	_emu->GetScriptHud()->ClearScreen();
	return l.ReturnCount();
}
FrameInfo LuaApi::InternalGetScreenSize()
{
	PpuFrameInfo frame = _emu->GetPpuFrame();
	FrameInfo frameSize;
	frameSize.Height = frame.Height;
	frameSize.Width = frame.Width;
	unique_ptr<BaseVideoFilter> filter(_emu->GetVideoFilter());
	filter->SetBaseFrameInfo(frameSize);
	filter->SetOverscan({});
	return filter->GetFrameInfo((uint16_t*)frame.FrameBuffer, false);
}
int LuaApi::GetScreenSize(lua_State* lua)
{
	LuaCallHelper l(lua);
	FrameInfo size = InternalGetScreenSize();
	lua_newtable(lua);
	lua_pushintvalue(width, size.Width);
	lua_pushintvalue(height, size.Height);
	return 1;
}
int LuaApi::GetDrawSurfaceSize(lua_State* lua)
{
	LuaCallHelper l(lua);
	l.ForceParamCount(1);
	ScriptDrawSurface surface = (ScriptDrawSurface)l.ReadInteger((uint32_t)_context->GetDrawSurface());
	checkEnum(ScriptDrawSurface, surface, "invalid draw surface");
	FrameInfo size;
	OverscanDimensions overscan;
	if(surface == ScriptDrawSurface::ConsoleScreen) {
		size = _emu->GetVideoDecoder()->GetBaseFrameInfo(true);
		overscan = _emu->GetSettings()->GetOverscan();
	} else {
		std::tie(size, overscan) = _emu->GetVideoRenderer()->GetScriptHudSize();
	}
	lua_newtable(lua);
	lua_pushintvalue(width, size.Width + overscan.Left + overscan.Right);
	lua_pushintvalue(height, size.Height + overscan.Top + overscan.Bottom);
	lua_pushintvalue(visibleWidth, size.Width);
	lua_pushintvalue(visibleHeight, size.Height);
	lua_starttable(overscan);
	lua_pushintvalue(top, overscan.Top);
	lua_pushintvalue(bottom, overscan.Bottom);
	lua_pushintvalue(left, overscan.Left);
	lua_pushintvalue(right, overscan.Right);
	lua_endtable();
	return 1;
}
std::pair<unique_ptr<BaseVideoFilter>, FrameInfo> LuaApi::GetRenderedFrame()
{
	PpuFrameInfo frame = _emu->GetPpuFrame();
	FrameInfo frameSize;
	frameSize.Height = frame.Height;
	frameSize.Width = frame.Width;
	unique_ptr<BaseVideoFilter> filter(_emu->GetVideoFilter());
	filter->SetBaseFrameInfo(frameSize);
	frameSize = filter->SendFrame((uint16_t*)frame.FrameBuffer, _emu->GetFrameCount(), _emu->GetFrameCount() & 0x01, nullptr, false);
	return std::make_pair(std::move(filter), frameSize);
}
int LuaApi::GetScreenBuffer(lua_State *lua)
{
	LuaCallHelper l(lua);
	auto [filter, frameSize] = GetRenderedFrame();
	uint32_t* rgbBuffer = filter->GetOutputBuffer();
	lua_createtable(lua, frameSize.Height*frameSize.Width, 0);
	for(int32_t i = 0, len = frameSize.Height * frameSize.Width; i < len; i++) {
		lua_pushinteger(lua, rgbBuffer[i] & 0xFFFFFF);
		lua_rawseti(lua, -2, i + 1);
	}
	return 1;
}
int LuaApi::SetScreenBuffer(lua_State *lua)
{
	LuaCallHelper l(lua);
	FrameInfo size = InternalGetScreenSize();
	int startFrame = _emu->GetFrameCount();
	unique_ptr<DrawScreenBufferCommand> cmd(new DrawScreenBufferCommand(size.Width, size.Height, startFrame));
	luaL_checktype(lua, 1, LUA_TTABLE);
	for(int i = 0, len = size.Height * size.Width; i < len; i++) {
		lua_rawgeti(lua, 1, i+1);
		uint32_t color = (uint32_t)lua_tointeger(lua, -1);
		lua_pop(lua, 1);
		cmd->SetPixel(i, color ^ 0xFF000000);
	}
	_emu->GetDebugHud()->AddCommand(std::move(cmd));
	return l.ReturnCount();
}
int LuaApi::GetPixel(lua_State *lua)
{
	LuaCallHelper l(lua);
	int y = l.ReadInteger();
	int x = l.ReadInteger();
	checkparams();
	auto [filter, frameSize] = GetRenderedFrame();
	errorCond(x < 0 || x >= (int)frameSize.Width || y < 0 || y >= (int)frameSize.Height, "invalid x,y coordinates");
	uint32_t* rgbBuffer = filter->GetOutputBuffer();
	l.Return(rgbBuffer[y * frameSize.Width + x] & 0xFFFFFF);
	return l.ReturnCount();
}
int LuaApi::GetMouseState(lua_State *lua)
{
	LuaCallHelper l(lua);
	MousePosition pos = KeyManager::GetMousePosition();
	checkparams();
	lua_newtable(lua);
	lua_pushintvalue(x, pos.X);
	lua_pushintvalue(y, pos.Y);
	lua_pushdoublevalue(relativeX, pos.RelativeX);
	lua_pushdoublevalue(relativeY, pos.RelativeY);
	lua_pushboolvalue(left, KeyManager::IsMouseButtonPressed(MouseButton::LeftButton));
	lua_pushboolvalue(middle, KeyManager::IsMouseButtonPressed(MouseButton::MiddleButton));
	lua_pushboolvalue(right, KeyManager::IsMouseButtonPressed(MouseButton::RightButton));
	return 1;
}
int LuaApi::Log(lua_State *lua)
{
	LuaCallHelper l(lua);
	string text = l.ReadString();
	checkparams();
	_context->Log(text);
	return l.ReturnCount();
}
int LuaApi::DisplayMessage(lua_State *lua)
{
	LuaCallHelper l(lua);
	string text = l.ReadString();
	string category = l.ReadString();
	checkparams();
	MessageManager::DisplayMessage(category, text);
	return l.ReturnCount();
}
int LuaApi::Reset(lua_State *lua)
{
	LuaCallHelper l(lua);
	checkparams();
	checkinitdone();
	_emu->GetSystemActionManager()->Reset();
	return l.ReturnCount();
}
int LuaApi::Stop(lua_State* lua)
{
	LuaCallHelper l(lua);
	int32_t stopCode = l.ReadInteger(0);
	checkminparams(0);
	_emu->SetStopCode(stopCode);
	return l.ReturnCount();
}
int LuaApi::BreakExecution(lua_State *lua)
{
	LuaCallHelper l(lua);
	checkparams();
	checkinitdone();
	_debugger->Step(_context->GetDefaultCpuType(), 1, StepType::Step);
	return l.ReturnCount();
}
int LuaApi::Resume(lua_State *lua)
{
	LuaCallHelper l(lua);
	checkparams();
	checkinitdone();
	_debugger->Run();
	return l.ReturnCount();
}
int LuaApi::Step(lua_State *lua)
{
	LuaCallHelper l(lua);
	l.ForceParamCount(3);
	CpuType cpuType = (CpuType)l.ReadInteger((uint32_t)_context->GetDefaultCpuType());
	StepType stepType = (StepType)l.ReadInteger();
	int count = l.ReadInteger();
	checkminparams(2);
	checkinitdone();
	errorCond(count <= 0, "count must be >= 1");
	checkEnum(StepType, stepType, "invalid step type");
	checkEnum(CpuType, cpuType, "invalid cpu type");
	_debugger->Step(cpuType, count, stepType);
	return l.ReturnCount();
}
int LuaApi::Rewind(lua_State *lua)
{
	LuaCallHelper l(lua);
	int seconds = l.ReadInteger();
	checkparams();
	errorCond(seconds <= 0, "seconds must be >= 1");
	_emu->GetRewindManager()->RewindSeconds(seconds);
	return l.ReturnCount();
}
int LuaApi::TakeScreenshot(lua_State *lua)
{
	LuaCallHelper l(lua);
	checkparams();
	stringstream ss;
	_emu->GetVideoDecoder()->TakeScreenshot(ss);
	l.Return(ss.str());
	return l.ReturnCount();
}
int LuaApi::IsKeyPressed(lua_State *lua)
{
	LuaCallHelper l(lua);
	string keyName = l.ReadString();
	checkparams();
	uint32_t keyCode = KeyManager::GetKeyCode(keyName);
	errorCond(keyCode == 0, "Invalid key name");
	l.Return(KeyManager::IsKeyPressed(keyCode));
	return l.ReturnCount();
}
int LuaApi::GetInput(lua_State *lua)
{
	LuaCallHelper l(lua);
	l.ForceParamCount(2);
	int subport = l.ReadInteger(0);
	int port = l.ReadInteger();
	checkminparams(1);
	errorCond(port < 0 || port > 5, "Invalid port number - must be between 0 to 4");
	errorCond(subport < 0 || subport > IControllerHub::MaxSubPorts, "Invalid subport number");
	shared_ptr<BaseControlDevice> controller = _emu->GetConsoleUnsafe()->GetControlManager()->GetControlDevice(port, subport);
	lua_newtable(lua);
	if(controller) {
		vector<DeviceButtonName> buttons = controller->GetKeyNameAssociations();
		for(DeviceButtonName& btn : buttons) {
			lua_pushstring(lua, btn.Name.c_str());
			if(btn.IsNumeric) {
				if(btn.ButtonId == BaseControlDevice::DeviceXCoordButtonId) {
					lua_pushinteger(lua, controller->GetCoordinates().X);
				} else if(btn.ButtonId == BaseControlDevice::DeviceYCoordButtonId) {
					lua_pushinteger(lua, controller->GetCoordinates().Y);
				}
			} else {
				lua_pushboolean(lua, controller->IsPressed(btn.ButtonId));
			}
			lua_settable(lua, -3);
		}
	}
	return 1;
}
int LuaApi::SetInput(lua_State* lua)
{
	LuaCallHelper l(lua);
	l.ForceParamCount(3);
	lua_settop(lua, 4);
	int subport = l.ReadInteger(0);
	int port = l.ReadInteger();
	errorCond(port < 0 || port > 5, "Invalid port number - must be between 0 to 4");
	errorCond(subport < 0 || subport > IControllerHub::MaxSubPorts, "Invalid subport number");
	shared_ptr<BaseControlDevice> controller = _emu->GetConsoleUnsafe()->GetControlManager()->GetControlDevice(port, subport);
	if(!controller) {
		return 0;
	}
	luaL_checktype(lua, 1, LUA_TTABLE);
	vector<DeviceButtonName> buttons = controller->GetKeyNameAssociations();
	for(DeviceButtonName& btn : buttons) {
		lua_getfield(lua, 1, btn.Name.c_str());
		if(btn.IsNumeric) {
			Nullable<int32_t> btnState = l.ReadOptionalInteger();
			if(btnState.HasValue) {
				if(btn.ButtonId == BaseControlDevice::DeviceXCoordButtonId) {
					MousePosition pos = controller->GetCoordinates();
					pos.X = (int16_t)btnState.Value;
					controller->SetCoordinates(pos);
				} else if(btn.ButtonId == BaseControlDevice::DeviceYCoordButtonId) {
					MousePosition pos = controller->GetCoordinates();
					pos.Y = (int16_t)btnState.Value;
					controller->SetCoordinates(pos);
				}
			}
		} else {
			Nullable<bool> btnState = l.ReadOptionalBool();
			if(btnState.HasValue) {
				controller->SetBitValue(btn.ButtonId, btnState.Value);
			}
		}
	}
	controller->RefreshStateBuffer();
	lua_pop(lua, 1);
	return l.ReturnCount();
}
int LuaApi::GetAccessCounters(lua_State *lua)
{
	LuaCallHelper l(lua);
	AccessCounterType counterType = (AccessCounterType)l.ReadInteger();
	MemoryType memoryType = (MemoryType)l.ReadInteger();
	checkEnum(MemoryType, memoryType, "Invalid memory type");
	checkEnum(AccessCounterType, counterType, "Invalid counter type");
	checkparams();
	uint32_t size = _memoryDumper->GetMemorySize(memoryType);
	vector<AddressCounters> counts;
	counts.resize(size, {});
	_debugger->GetMemoryAccessCounter()->GetAccessCounts(0, size, memoryType, counts.data());
	auto getValue = [&](AddressCounters& counter) -> uint64_t {
		switch(counterType) {
			default:
			case AccessCounterType::ReadCount: return counter.ReadCounter;
			case AccessCounterType::WriteCount: return counter.WriteCounter;
			case AccessCounterType::ExecCount: return counter.ExecCounter;
			case AccessCounterType::LastReadClock: return counter.ReadStamp;
			case AccessCounterType::LastWriteClock: return counter.WriteStamp;
			case AccessCounterType::LastExecClock: return counter.ExecStamp;
		}
	};
	lua_newtable(lua);
	for(uint32_t i = 0; i < size; i++) {
		lua_pushinteger(lua, getValue(counts[i]));
		lua_rawseti(lua, -2, i);
	}
	return 1;
}
int LuaApi::ResetAccessCounters(lua_State *lua)
{
	LuaCallHelper l(lua);
	checkparams();
	_debugger->GetMemoryAccessCounter()->ResetCounts();
	return l.ReturnCount();
}
int LuaApi::GetCdlData(lua_State* lua)
{
	LuaCallHelper l(lua);
	MemoryType memoryType = (MemoryType)l.ReadInteger();
	checkEnum(MemoryType, memoryType, "Invalid memory type");
	checkparams();
	if(!_debugger->GetCdlManager()->GetCodeDataLogger(memoryType)) {
		error("This memory type does not support CDL data (only some ROM memory types support it)");
	}
	uint32_t size = _memoryDumper->GetMemorySize(memoryType);
	vector<uint8_t> cdlData;
	cdlData.resize(size, {});
	_debugger->GetCdlManager()->GetCdlData(0, size, memoryType, cdlData.data());
	lua_newtable(lua);
	for(uint32_t i = 0; i < size; i++) {
		lua_pushinteger(lua, cdlData[i]);
		lua_rawseti(lua, -2, i);
	}
	return 1;
}
int LuaApi::GetScriptDataFolder(lua_State *lua)
{
	LuaCallHelper l(lua);
	checkparams();
	if(_emu->GetSettings()->GetDebugConfig().ScriptAllowIoOsAccess) {
		string baseFolder = FolderUtilities::CombinePath(FolderUtilities::GetHomeFolder(), "LuaScriptData");
		FolderUtilities::CreateFolder(baseFolder);
		string scriptFolder = FolderUtilities::CombinePath(baseFolder, FolderUtilities::GetFilename(_context->GetScriptName(), false));
		FolderUtilities::CreateFolder(scriptFolder);
		l.Return(scriptFolder);
	} else {
		l.Return("");
	}
	return l.ReturnCount();
}
int LuaApi::GetRomInfo(lua_State *lua)
{
	LuaCallHelper l(lua);
	checkparams();
	RomInfo romInfo = _emu->GetRomInfo();
	lua_newtable(lua);
	lua_pushstringvalue(name, romInfo.RomFile.GetFileName());
	lua_pushstringvalue(path, romInfo.RomFile.GetFilePath());
	lua_pushstringvalue(fileSha1Hash, _emu->GetHash(HashType::Sha1));
	return 1;
}
int LuaApi::GetLogWindowLog(lua_State *lua)
{
	LuaCallHelper l(lua);
	checkparams();
	l.Return(MessageManager::GetLog());
	return l.ReturnCount();
}
int LuaApi::AddCheat(lua_State* lua)
{
	LuaCallHelper l(lua);
	string code = l.ReadString();
	CheatType cheatType = (CheatType)l.ReadInteger();
	checkparams();
	checkEnum(CheatType, cheatType, "invalid cheat type");
	errorCond(code.length() > 15, "codes must be 15 characters or less");
	CheatCode cheatCode = {};
	cheatCode.Type = cheatType;
	memcpy(cheatCode.Code, code.c_str(), code.length());
	if(!_emu->GetCheatManager()->AddCheat(cheatCode)) {
		error("invalid cheat code")
	}
	return l.ReturnCount();
}
int LuaApi::ClearCheats(lua_State* lua)
{
	LuaCallHelper l(lua);
	checkparams();
	_emu->GetCheatManager()->InternalClearCheats();
	return l.ReturnCount();
}
int LuaApi::CreateSavestate(lua_State* lua)
{
	LuaCallHelper l(lua);
	stringstream ss;
	_emu->GetSaveStateManager()->SaveState(ss);
	l.Return(ss.str());
	return l.ReturnCount();
}
int LuaApi::LoadSavestate(lua_State* lua)
{
	LuaCallHelper l(lua);
	string savestate = l.ReadString();
	checkparams();
	stringstream ss;
	ss << savestate;
	bool result = _emu->GetSaveStateManager()->LoadState(ss);
	l.Return(result);
	return l.ReturnCount();
}
int LuaApi::GetState(lua_State *lua)
{
	LuaCallHelper l(lua);
	checkparams();
	Serializer s(0, true, SerializeFormat::Map);
	s.Stream(*_emu->GetConsole().get(), "", -1);
	//Add some more Lua-specific values
	uint32_t frameCount = _emu->GetFrameCount();
	uint32_t masterClock = _emu->GetMasterClock();
	uint32_t clockRate = _emu->GetMasterClockRate();
	string consoleType = string(magic_enum::enum_name<ConsoleType>(_emu->GetConsoleType()));
	string region = string(magic_enum::enum_name<ConsoleRegion>(_emu->GetRegion()));
	SV(clockRate);
	SV(consoleType);
	SV(region);
	SV(frameCount);
	SV(masterClock);
	unordered_map<string, SerializeMapValue>& values = s.GetMapValues();
	lua_newtable(lua);
	for(auto& kvp : values) {
		lua_pushlstring(lua, kvp.first.c_str(), kvp.first.size());
		switch(kvp.second.Format) {
			case SerializeMapValueFormat::Integer: lua_pushinteger(lua, kvp.second.Value.Integer); break;
			case SerializeMapValueFormat::Double: lua_pushnumber(lua, kvp.second.Value.Double); break;
			case SerializeMapValueFormat::Bool: lua_pushboolean(lua, kvp.second.Value.Bool); break;
			case SerializeMapValueFormat::String: lua_pushlstring(lua, kvp.second.StringValue.c_str(), kvp.second.StringValue.size()); break;
		}
		lua_settable(lua, -3);
	}
	return 1;
}
int LuaApi::SetState(lua_State* lua)
{
	lua_settop(lua, 1);
	luaL_checktype(lua, -1, LUA_TTABLE);
	unordered_map<string, SerializeMapValue> map;
	lua_pushnil(lua);  /* first key */
	while(lua_next(lua, -2) != 0) {
		/* uses 'key' (at index -2) and 'value' (at index -1) */
		if(lua_type(lua, -2) == LUA_TSTRING) {
			size_t len = 0;
			const char* cstr = lua_tolstring(lua, -2, &len);
			string key = string(cstr, len);
			switch(lua_type(lua, -1)) {
				case LUA_TBOOLEAN: {
					map.try_emplace(key, SerializeMapValueFormat::Bool, (bool)lua_toboolean(lua, -1));
					break;
				}
				case LUA_TNUMBER: {
					if(lua_isinteger(lua, -1)) {
						map.try_emplace(key, SerializeMapValueFormat::Integer, (int64_t)lua_tointeger(lua, -1));
					} else if(lua_isnumber(lua, -1)) {
						map.try_emplace(key, SerializeMapValueFormat::Double, (double)lua_tonumber(lua, -1));
					}
					break;
				}
			}
		}
		/* removes 'value'; keeps 'key' for next iteration */
		lua_pop(lua, 1);
	}
	Serializer s(0, false, SerializeFormat::Map);
	s.LoadFromMap(map);
	s.Stream(*_emu->GetConsole().get(), "", -1);
	return 0;
}
```

## File: Core/Shared/BaseControlDevice.h
```
#pragma once
#include "pch.h"
#include "Shared/ControlDeviceState.h"
#include "Shared/SettingTypes.h"
#include "Shared/Interfaces/IKeyManager.h"
#include "Utilities/SimpleLock.h"
#include "Utilities/ISerializable.h"
class Emulator;
class InputHud;
struct DeviceButtonName
{
	string Name;
	int ButtonId = 0;
	bool IsNumeric = false;
};
class BaseControlDevice : public ISerializable
{
protected:
	ControlDeviceState _state = {};
	Emulator* _emu = nullptr;
	vector<KeyMapping> _keyMappings;
	bool _strobe = false;
	ControllerType _type = ControllerType::None;
	uint8_t _port = 0;
	bool _connected = true;
	SimpleLock _stateLock;
	void EnsureCapacity(int32_t minBitCount);
	uint32_t GetByteIndex(uint8_t bit);
	virtual bool HasCoordinates();
	virtual bool IsRawString();
	bool IsCurrentPort(uint16_t addr);
	bool IsExpansionDevice();
	void StrobeProcessRead();
	void StrobeProcessWrite(uint8_t value);
	virtual string GetKeyNames() { return ""; }
	void SetPressedState(uint8_t bit, uint16_t keyCode);
	void SetPressedState(uint8_t bit, bool enabled);
	void SetMovement(MouseMovement mov);
	MouseMovement GetMovement();
	virtual void InternalSetStateFromInput();
public:
	static constexpr int DeviceXCoordButtonId = 0xFFFE;
	static constexpr int DeviceYCoordButtonId = 0xFFFF;
	static constexpr uint8_t ExpDevicePort = 4;
	static constexpr uint8_t ConsoleInputPort = 5;
	static constexpr uint8_t MapperInputPort = 6;
	static constexpr uint8_t ExpDevicePort2 = 7;
	static constexpr uint8_t PortCount = ExpDevicePort2 + 1;
	BaseControlDevice(Emulator* emu, ControllerType type, uint8_t port, KeyMappingSet keyMappingSet = KeyMappingSet());
	virtual ~BaseControlDevice();
	virtual void Init() {}
	uint8_t GetPort();
	ControllerType GetControllerType();
	bool IsPressed(uint8_t bit);
	MousePosition GetCoordinates();
	void SetCoordinates(MousePosition pos);
	void Connect();
	void Disconnect();
	bool IsConnected();
	void ClearState();
	void SetBit(uint8_t bit);
	void ClearBit(uint8_t bit);
	void InvertBit(uint8_t bit);
	void SetBitValue(uint8_t bit, bool set);
	virtual void SetTextState(string state);
	virtual string GetTextState();
	void SetStateFromInput();
	virtual void OnAfterSetState() { }
	virtual void SetRawState(ControlDeviceState state);
	virtual ControlDeviceState GetRawState();
	virtual void InternalDrawController(InputHud& hud) {}
	virtual void DrawController(InputHud& hud);
	virtual uint8_t ReadRam(uint16_t addr) = 0;
	virtual void WriteRam(uint16_t addr, uint8_t value) = 0;
	virtual void RefreshStateBuffer() { }
	virtual vector<DeviceButtonName> GetKeyNameAssociations() { return {}; }
	virtual bool HasControllerType(ControllerType type);
	void static SwapButtons(shared_ptr<BaseControlDevice> state1, uint8_t button1, shared_ptr<BaseControlDevice> state2, uint8_t button2);
	void Serialize(Serializer &s) override;
};
```

## File: Core/Shared/CdReader.cpp
```cpp
#include "pch.h"
#include "Shared/CdReader.h"
#include "Shared/MessageManager.h"
#include "Utilities/StringUtilities.h"
#include "Utilities/FolderUtilities.h"
#include "Utilities/magic_enum.hpp"
struct CueIndexEntry
{
	uint32_t Number;
	DiscPosition Position;
};
struct CueGapEntry
{
	bool HasGap = false;
	DiscPosition Length;
};
struct CueTrackEntry
{
	uint32_t Number;
	string Format;
	CueGapEntry PreGap = {};
	vector<CueIndexEntry> Indexes;
};
struct CueFileEntry
{
	string Filename;
	vector<CueTrackEntry> Tracks;
};
bool CdReader::LoadCue(VirtualFile& cueFile, DiscInfo& disc)
{
	vector<CueFileEntry> files;
	stringstream ss;
	cueFile.ReadFile(ss);
	string line;
	while(std::getline(ss, line)) {
		line = StringUtilities::TrimLeft(StringUtilities::TrimRight(line));
		if(line.substr(0, 4) == string("FILE")) {
			size_t start = line.find_first_of('"');
			size_t end = line.find_last_of('"');
			string filename;
			if(start != end && start != string::npos && end != string::npos) {
				filename = line.substr(start + 1, end - start - 1);
			} else {
				start = line.find_first_of(' ');
				end = line.find_last_of(' ');
				if(end == start && start != string::npos) {
					end = line.size();
				}
				if(start != end && start != string::npos && end != string::npos) {
					filename = line.substr(start + 1, end - start - 1);
				}
			}
			filename = StringUtilities::Trim(filename);
			if(!filename.empty()) {
				VirtualFile dataFile = cueFile.GetFolderPath() + filename;
				if(cueFile.IsArchive()) {
					dataFile = VirtualFile(cueFile.GetFilePath(), filename);
				}
				files.push_back({ dataFile });
			} else {
				MessageManager::Log("[CUE] Invalid FILE entry");
				return false;
			}
		} else if(line.substr(0, 5) == string("TRACK")) {
			if(files.size() == 0) {
				MessageManager::Log("[CUE] Unexpected TRACK entry");
				return false;
			}
			vector<string> entry = StringUtilities::Split(line, ' ');
			if(entry.size() < 3) {
				MessageManager::Log("[CUE] Invalid TRACK entry");
				return false;
			}
			CueTrackEntry trk = {};
			try {
				trk.Number = std::stoi(entry[1]);
			} catch(const std::exception&) {
				MessageManager::Log("[CUE] Invalid TRACK number");
				return false;
			}
			trk.Format = entry[2];
			files[files.size() - 1].Tracks.push_back(trk);
		} else if(line.substr(0, 6) == string("PREGAP")) {
			if(files.empty() || files[files.size() - 1].Tracks.empty()) {
				MessageManager::Log("[CUE] Unexpected PREGAP entry");
				return false;
			}
			vector<string> entry = StringUtilities::Split(line, ' ');
			CueGapEntry gap = {};
			vector<string> lengthParts = StringUtilities::Split(entry[1], ':');
			if(lengthParts.size() != 3) {
				MessageManager::Log("[CUE] Invalid PREGAP time format");
				return false;
			}
			try {
				gap.Length.Minutes = std::stoi(lengthParts[0]);
				gap.Length.Seconds = std::stoi(lengthParts[1]);
				gap.Length.Frames = std::stoi(lengthParts[2]);
				gap.HasGap = true;
			} catch(const std::exception&) {
				MessageManager::Log("[CUE] Invalid PREGAP time format");
				return false;
			}
			files[files.size() - 1].Tracks[files[files.size() - 1].Tracks.size() - 1].PreGap = gap;
		} else if(line.substr(0, 5) == string("INDEX")) {
			if(files.empty() || files[files.size() - 1].Tracks.empty()) {
				MessageManager::Log("[CUE] Unexpected INDEX entry");
				return false;
			}
			vector<string> entry = StringUtilities::Split(line, ' ');
			CueIndexEntry idx = {};
			try {
				idx.Number = std::stoi(entry[1]);
			} catch(const std::exception&) {
				MessageManager::Log("[CUE] Invalid INDEX number");
				return false;
			}
			vector<string> lengthParts = StringUtilities::Split(entry[2], ':');
			if(lengthParts.size() != 3) {
				MessageManager::Log("[CUE] Invalid INDEX time format");
				return false;
			}
			try {
				idx.Position.Minutes = std::stoi(lengthParts[0]);
				idx.Position.Seconds = std::stoi(lengthParts[1]);
				idx.Position.Frames = std::stoi(lengthParts[2]);
			} catch(const std::exception&) {
				MessageManager::Log("[CUE] Invalid INDEX time format");
				return false;
			}
			files[files.size() - 1].Tracks[files[files.size() - 1].Tracks.size() - 1].Indexes.push_back(idx);
		}
	}
	uint32_t totalPregapLbaLength = 0;
	for(size_t i = 0; i < files.size(); i++) {
		VirtualFile physicalFile = files[i].Filename;
		if(!physicalFile.IsValid()) {
			MessageManager::Log("[CUE] Missing or invalid file: " + files[i].Filename);
			return false;
		}
		disc.Files.push_back(files[i].Filename);
		int startSector = i == 0 ? 0 : (disc.Tracks[disc.Tracks.size() - 1].LastSector + 1);
		for(size_t j = 0; j < files[i].Tracks.size(); j++) {
			CueTrackEntry entry = files[i].Tracks[j];
			TrackInfo trk = {};
			if(entry.PreGap.HasGap) {
				totalPregapLbaLength += entry.PreGap.Length.ToLba();
			}
			DiscPosition startPos;
			for(CueIndexEntry& idx : entry.Indexes) {
				if(idx.Number == 0) {
					trk.HasLeadIn = true;
					trk.LeadInPosition = DiscPosition::FromLba(idx.Position.ToLba() + startSector);
				} else if(idx.Number == 1) {
					if(entry.PreGap.HasGap) {
						trk.HasLeadIn = true;
						trk.LeadInPosition = DiscPosition::FromLba(idx.Position.ToLba() + totalPregapLbaLength - entry.PreGap.Length.ToLba() + startSector);
					}
					trk.StartPosition = DiscPosition::FromLba(idx.Position.ToLba() + totalPregapLbaLength + startSector);
					startPos = idx.Position;
				} else {
					MessageManager::Log("[CUE] Unsupported index number: " + std::to_string(idx.Number));
					return false;
				}
			}
			if(entry.Format == "AUDIO") {
				trk.Format = TrackFormat::Audio;
			} else if(entry.Format == "MODE1/2352") {
				trk.Format = TrackFormat::Mode1_2352;
			} else if(entry.Format == "MODE1/2048") {
				trk.Format = TrackFormat::Mode1_2048;
			} else {
				MessageManager::Log("[CUE] Unsupported track format: " + entry.Format);
				return false;
			}
			trk.FirstSector = trk.StartPosition.ToLba();
			if(disc.Tracks.size() > 0) {
				uint32_t currentFileOffset = 0;
				TrackInfo& prvTrk = disc.Tracks[disc.Tracks.size() - 1];
				if(prvTrk.Size == 0) {
					prvTrk.EndPosition = DiscPosition::FromLba((trk.HasLeadIn ? trk.LeadInPosition.ToLba() : trk.FirstSector) - 1);
					prvTrk.LastSector = prvTrk.EndPosition.ToLba();
					prvTrk.SectorCount = prvTrk.LastSector - prvTrk.FirstSector + 1;
					prvTrk.Size = prvTrk.SectorCount * trk.GetSectorSize();
					currentFileOffset = prvTrk.FileOffset + prvTrk.Size;
				}
				trk.FileOffset = currentFileOffset;
			} else {
				trk.FileOffset = trk.FirstSector * trk.GetSectorSize();
			}
			if(trk.HasLeadIn && !entry.PreGap.HasGap) {
				trk.FileOffset += (trk.StartPosition.ToLba() - trk.LeadInPosition.ToLba()) * trk.GetSectorSize();
			}
			trk.FileIndex = (uint32_t)disc.Files.size() - 1;
			disc.Tracks.push_back(trk);
		}
		TrackInfo& lastTrk = disc.Tracks[disc.Tracks.size() - 1];
		lastTrk.Size = (uint32_t)((disc.Files[lastTrk.FileIndex].GetSize() - lastTrk.FileOffset) / lastTrk.GetSectorSize() * lastTrk.GetSectorSize());
		lastTrk.SectorCount = lastTrk.Size / lastTrk.GetSectorSize();
		lastTrk.EndPosition = DiscPosition::FromLba(lastTrk.FirstSector + lastTrk.SectorCount - 1);
		lastTrk.LastSector = lastTrk.EndPosition.ToLba();
	}
	TrackInfo& discLastTrk = disc.Tracks[disc.Tracks.size() - 1];
	disc.DiscSize = discLastTrk.FileOffset + discLastTrk.Size;
	disc.DiscSectorCount = discLastTrk.LastSector + 1;
	disc.EndPosition = DiscPosition::FromLba(disc.DiscSectorCount + 2 * 75);
	MessageManager::Log("---- DISC TRACKS ----");
	int i = 1;
	for(TrackInfo& trk : disc.Tracks) {
		MessageManager::Log("Track " + std::to_string(i) + " (" + string(magic_enum::enum_name(trk.Format)) + ")");
		if(trk.HasLeadIn) {
			MessageManager::Log("  Lead-in: " + trk.LeadInPosition.ToString());
		}
		MessageManager::Log("  Time: " + trk.StartPosition.ToString() + " - " + trk.EndPosition.ToString());
		MessageManager::Log("  Sectors: " + std::to_string(trk.FirstSector) + " - " + std::to_string(trk.LastSector));
		MessageManager::Log("  File offset: " + std::to_string(trk.FileOffset) + " - " + std::to_string(trk.FileOffset+trk.Size-1));
		i++;
	}
	MessageManager::Log("---- END TRACKS ----");
	LoadSubcodeFile(cueFile, disc);
	return disc.Tracks.size() > 0;
}
void CdReader::LoadSubcodeFile(VirtualFile& cueFile, DiscInfo& disc)
{
	VirtualFile subFile = FolderUtilities::CombinePath(FolderUtilities::GetFolderName(cueFile.GetFilePath()), FolderUtilities::GetFilename(cueFile.GetFileName(), false)) + ".sub";
	if(subFile.IsValid()) {
		vector<uint8_t>& subCode = disc.DecodedSubCode;
		subFile.ReadFile(subCode);
		for(int i = 0; i < disc.DecodedSubCode.size() / 96; i++) {
			disc.SubCode.push_back(0x00);
			disc.SubCode.push_back(0x80);
			for(int j = 0; j < 12; j++) {
				for(int k = 7; k >= 0; k--) {
					uint8_t encoded = (
						(((subCode[i * 96 + j + 0] >> k) & 0x01) << 7) |
						(((subCode[i * 96 + j + 12] >> k) & 0x01) << 6) |
						(((subCode[i * 96 + j + 24] >> k) & 0x01) << 5) |
						(((subCode[i * 96 + j + 36] >> k) & 0x01) << 4) |
						(((subCode[i * 96 + j + 48] >> k) & 0x01) << 3) |
						(((subCode[i * 96 + j + 60] >> k) & 0x01) << 2) |
						(((subCode[i * 96 + j + 72] >> k) & 0x01) << 1) |
						(((subCode[i * 96 + j + 84] >> k) & 0x01) << 0)
					);
					disc.SubCode.push_back(encoded);
				}
			}
		}
	}
}
```

## File: Core/Shared/CdReader.h
```
#pragma once
#include "pch.h"
#include "Utilities/VirtualFile.h"
#include "Shared/MessageManager.h"
enum class TrackFormat
{
	Audio,
	Mode1_2352,
	Mode1_2048
};
struct DiscPosition
{
	uint32_t Minutes;
	uint32_t Seconds;
	uint32_t Frames;
	uint32_t ToLba()
	{
		return ((Minutes * 60) + Seconds) * 75 + Frames;
	}
	string ToString()
	{
		return GetValueString(Minutes) + ":" + GetValueString(Seconds) + ":" + GetValueString(Frames);
	}
	static DiscPosition FromLba(uint32_t lba)
	{
		DiscPosition pos;
		pos.Minutes = lba / 75 / 60;
		pos.Seconds = lba / 75 % 60;
		pos.Frames = lba % 75;
		return pos;
	}
private:
	string GetValueString(uint32_t val)
	{
		if(val < 10) {
			return "0" + std::to_string(val);
		} else {
			return std::to_string(val);
		}
	}
};
struct TrackInfo
{
	uint32_t Size;
	uint32_t SectorCount;
	bool HasLeadIn;
	DiscPosition LeadInPosition;
	DiscPosition StartPosition;
	DiscPosition EndPosition;
	TrackFormat Format;
	uint32_t FileIndex;
	uint32_t FileOffset;
	uint32_t FirstSector;
	uint32_t LastSector;
	uint32_t GetSectorSize()
	{
		switch(Format) {
			default:
			case TrackFormat::Audio: return 2352;
			case TrackFormat::Mode1_2352: return 2352;
			case TrackFormat::Mode1_2048: return 2048;
		}
	}
};
struct DiscInfo
{
	static constexpr int SectorSize = 2352;
	vector<VirtualFile> Files;
	vector<TrackInfo> Tracks;
	vector<uint8_t> SubCode;
	vector<uint8_t> DecodedSubCode;
	uint32_t DiscSize;
	uint32_t DiscSectorCount;
	DiscPosition EndPosition;
	int32_t GetTrack(uint32_t sector)
	{
		for(size_t i = 0; i < Tracks.size(); i++) {
			if(sector >= Tracks[i].FirstSector && sector <= Tracks[i].LastSector) {
				return (int32_t)i;
			}
		}
		return -1;
	}
	int32_t GetTrackFirstSector(int32_t track)
	{
		if(track < Tracks.size()) {
			return Tracks[track].FirstSector;
		} else if(track > 0 && track == Tracks.size()) {
			return Tracks[track - 1].LastSector;
		}
		return -1;
	}
	int32_t GetTrackLastSector(int32_t track)
	{
		if(track < Tracks.size()) {
			return Tracks[track].LastSector;
		}
		return -1;
	}
	template<typename T>
	void ReadDataSector(uint32_t sector, T& outData)
	{
		constexpr int Mode1_2352_SectorHeaderSize = 16;
		int32_t track = GetTrack(sector);
		if(track < 0) {
			LogDebug("Invalid sector/track (or inside pregap)");
			outData.insert(outData.end(), 2048, 0);
		} else {
			TrackInfo& trk = Tracks[track];
			uint32_t sectorSize = trk.GetSectorSize();
			uint32_t sectorHeaderSize = trk.Format == TrackFormat::Mode1_2352 ? Mode1_2352_SectorHeaderSize : 0;
			uint32_t byteOffset = trk.FileOffset + (sector - trk.FirstSector) * sectorSize;
			if(!Files[trk.FileIndex].ReadChunk(outData, byteOffset + sectorHeaderSize, 2048)) {
				LogDebug("Invalid read offsets");
			}
		}
	}
	int16_t ReadAudioSample(uint32_t sector, uint32_t sample, uint32_t byteOffset)
	{
		int32_t track = GetTrack(sector);
		if(track < 0) {
			LogDebug("Invalid sector/track");
			return 0;
		}
		uint32_t fileIndex = Tracks[track].FileIndex;
		uint32_t startByte = Tracks[track].FileOffset + (sector - Tracks[track].FirstSector) * DiscInfo::SectorSize;
		return (int16_t)(Files[fileIndex].ReadByte(startByte + sample * 4 + byteOffset) | (Files[fileIndex].ReadByte(startByte + sample * 4 + 1 + byteOffset) << 8));
	}
	int16_t ReadLeftSample(uint32_t sector, uint32_t sample)
	{
		return ReadAudioSample(sector, sample, 0);
	}
	int16_t ReadRightSample(uint32_t sector, uint32_t sample)
	{
		return ReadAudioSample(sector, sample, 2);
	}
	void GetSubCodeQ(uint32_t sector, std::deque<uint8_t>& out)
	{
		uint32_t startPos = sector * 96 + 12;
		uint32_t endPos = startPos + 10;
		if(endPos <= DecodedSubCode.size()) {
			out.insert(out.end(), DecodedSubCode.begin() + startPos, DecodedSubCode.begin() + endPos);
		}
	}
};
class CdReader
{
	static void LoadSubcodeFile(VirtualFile& cueFile, DiscInfo& disc);
public:
	static bool LoadCue(VirtualFile& file, DiscInfo& disc);
	static uint8_t ToBcd(uint8_t value)
	{
		uint8_t div = value / 10;
		uint8_t rem = value % 10;
		return (div << 4) | rem;
	}
	static uint8_t FromBcd(uint8_t value)
	{
		return ((value >> 4) & 0x0F) * 10 + (value & 0x0F);
	}
};
```

## File: Core/Shared/Emulator.h
```
#pragma once
#include "pch.h"
#include "Core/Debugger/DebugTypes.h"
#include "Core/Debugger/Debugger.h"
#include "Core/Debugger/DebugUtilities.h"
#include "Core/Shared/EmulatorLock.h"
#include "Core/Shared/Interfaces/IConsole.h"
#include "Core/Shared/Audio/AudioPlayerTypes.h"
#include "Utilities/Timer.h"
#include "Utilities/safe_ptr.h"
#include "Utilities/SimpleLock.h"
#include "Utilities/VirtualFile.h"
class Debugger;
class DebugHud;
class SoundMixer;
class VideoRenderer;
class VideoDecoder;
class NotificationManager;
class EmuSettings;
class SaveStateManager;
class RewindManager;
class BatteryManager;
class CheatManager;
class MovieManager;
class HistoryViewer;
class FrameLimiter;
class DebugStats;
class BaseControlManager;
class VirtualFile;
class BaseVideoFilter;
class ShortcutKeyHandler;
class SystemActionManager;
class AudioPlayerHud;
class GameServer;
class GameClient;
class McpServer;
class IInputRecorder;
class IInputProvider;
struct RomInfo;
struct TimingInfo;
enum class MemoryOperationType;
enum class MemoryType;
enum class EventType;
enum class ConsoleRegion;
enum class ConsoleType;
enum class HashType;
enum class TapeRecorderAction;
struct ConsoleMemoryInfo
{
	void* Memory;
	uint32_t Size;
};
class Emulator
{
private:
	friend class DebuggerRequest;
	friend class EmulatorLock;
	unique_ptr<thread> _emuThread;
	unique_ptr<AudioPlayerHud> _audioPlayerHud;
	safe_ptr<IConsole> _console;
	shared_ptr<ShortcutKeyHandler> _shortcutKeyHandler;
	safe_ptr<Debugger> _debugger;
	shared_ptr<SystemActionManager> _systemActionManager;
	const unique_ptr<EmuSettings> _settings;
	const unique_ptr<DebugHud> _debugHud;
	const unique_ptr<DebugHud> _scriptHud;
	const unique_ptr<NotificationManager> _notificationManager;
	const unique_ptr<BatteryManager> _batteryManager;
	const unique_ptr<SoundMixer> _soundMixer;
	const unique_ptr<VideoRenderer> _videoRenderer;
	const unique_ptr<VideoDecoder> _videoDecoder;
	const unique_ptr<SaveStateManager> _saveStateManager;
	const unique_ptr<CheatManager> _cheatManager;
	const unique_ptr<MovieManager> _movieManager;
	const unique_ptr<HistoryViewer> _historyViewer;
	const shared_ptr<GameServer> _gameServer;
	const shared_ptr<GameClient> _gameClient;
	const shared_ptr<RewindManager> _rewindManager;
	unique_ptr<McpServer> _mcpServer;
	thread_local static thread::id _currentThreadId;
	thread::id _emulationThreadId;
	atomic<uint32_t> _lockCounter;
	SimpleLock _runLock;
	SimpleLock _loadLock;
	SimpleLock _debuggerLock;
	atomic<bool> _stopFlag;
	atomic<bool> _paused;
	atomic<bool> _pauseOnNextFrame;
	atomic<bool> _threadPaused;
	atomic<int> _debugRequestCount;
	atomic<int> _blockDebuggerRequestCount;
	atomic<bool> _isRunAheadFrame;
	bool _frameRunning = false;
	RomInfo _rom;
	ConsoleType _consoleType = {};
	ConsoleMemoryInfo _consoleMemory[DebugUtilities::GetMemoryTypeCount()] = {};
	unique_ptr<DebugStats> _stats;
	unique_ptr<FrameLimiter> _frameLimiter;
	Timer _lastFrameTimer;
	double _frameDelay = 0;
	uint32_t _autoSaveStateFrameCounter = 0;
	int32_t _stopCode = 0;
	bool _stopRequested = false;
	void WaitForLock();
	void WaitForPauseEnd();
	void ProcessAutoSaveState();
	bool ProcessSystemActions();
	void RunFrameWithRunAhead();
	void BlockDebuggerRequests();
	void ResetDebugger(bool startDebugger = false);
	double GetFrameDelay();
	void TryLoadRom(VirtualFile& romFile, LoadRomResult& result, unique_ptr<IConsole>& console, bool useFileSignature);
	template<typename T> void TryLoadRom(VirtualFile& romFile, LoadRomResult& result, unique_ptr<IConsole>& console, bool useFileSignature);
	void InitConsole(unique_ptr<IConsole>& newConsole, ConsoleMemoryInfo originalConsoleMemory[], bool preserveRom);
	bool InternalLoadRom(VirtualFile romFile, VirtualFile patchFile, bool stopRom = true, bool forPowerCycle = false);
public:
	Emulator();
	~Emulator();
	void Initialize(bool enableShortcuts = true);
	void Release();
	void Run();
	void Stop(bool sendNotification, bool preventRecentGameSave = false, bool saveBattery = true);
	void OnBeforeSendFrame();
	void ProcessEndOfFrame();
	void Reset();
	void ReloadRom(bool forPowerCycle);
	void PowerCycle();
	void PauseOnNextFrame();
	void Pause();
	void Resume();
	bool IsPaused();
	void OnBeforePause(bool clearAudioBuffer);
	bool LoadRom(VirtualFile romFile, VirtualFile patchFile, bool stopRom = true, bool forPowerCycle = false);
	RomInfo& GetRomInfo() { return _rom; }
	string GetHash(HashType type);
	uint32_t GetCrc32();
	PpuFrameInfo GetPpuFrame();
	ConsoleRegion GetRegion();
	shared_ptr<IConsole> GetConsole();
	IConsole* GetConsoleUnsafe();
	ConsoleType GetConsoleType();
	vector<CpuType> GetCpuTypes();
	uint64_t GetMasterClock();
	uint32_t GetMasterClockRate();
	EmulatorLock AcquireLock(bool allowDebuggerLock = true);
	void Lock();
	void Unlock();
	bool IsThreadPaused();
	bool IsDebuggerBlocked() { return _blockDebuggerRequestCount > 0; }
	void SuspendDebugger(bool release);
	void Serialize(ostream& out, bool includeSettings, int compressionLevel = 1);
	DeserializeResult Deserialize(istream& in, uint32_t fileFormatVersion, bool includeSettings, optional<ConsoleType> consoleType = std::nullopt, bool sendNotification = true);
	SoundMixer* GetSoundMixer() { return _soundMixer.get(); }
	VideoRenderer* GetVideoRenderer() { return _videoRenderer.get(); }
	VideoDecoder* GetVideoDecoder() { return _videoDecoder.get(); }
	ShortcutKeyHandler* GetShortcutKeyHandler() { return _shortcutKeyHandler.get(); }
	NotificationManager* GetNotificationManager() { return _notificationManager.get(); }
	EmuSettings* GetSettings() { return _settings.get(); }
	SaveStateManager* GetSaveStateManager() { return _saveStateManager.get(); }
	RewindManager* GetRewindManager() { return _rewindManager.get(); }
	DebugHud* GetDebugHud() { return _debugHud.get(); }
	DebugHud* GetScriptHud() { return _scriptHud.get(); }
	BatteryManager* GetBatteryManager() { return _batteryManager.get(); }
	CheatManager* GetCheatManager() { return _cheatManager.get(); }
	MovieManager* GetMovieManager() { return _movieManager.get(); }
	HistoryViewer* GetHistoryViewer() { return _historyViewer.get(); }
	GameServer* GetGameServer() { return _gameServer.get(); }
	GameClient* GetGameClient() { return _gameClient.get(); }
	McpServer* GetMcpServer() { return _mcpServer.get(); }
	shared_ptr<SystemActionManager> GetSystemActionManager() { return _systemActionManager; }
	BaseVideoFilter* GetVideoFilter(bool getDefaultFilter = false);
	void GetScreenRotationOverride(uint32_t& rotation);
	void InputBarcode(uint64_t barcode, uint32_t digitCount);
	void ProcessTapeRecorderAction(TapeRecorderAction action, string filename);
	ShortcutState IsShortcutAllowed(EmulatorShortcut shortcut, uint32_t shortcutParam);
	bool IsKeyboardConnected();
	void InitDebugger();
	void StopDebugger();
	DebuggerRequest GetDebugger(bool autoInit = false);
	bool IsDebugging() { return !!_debugger; }
	Debugger* InternalGetDebugger() { return _debugger.get(); }
	thread::id GetEmulationThreadId() { return _emulationThreadId; }
	bool IsEmulationThread();
	int32_t GetStopCode() { return _stopCode; }
	void SetStopCode(int32_t stopCode);
	void RegisterMemory(MemoryType type, void* memory, uint32_t size);
	ConsoleMemoryInfo GetMemory(MemoryType type);
	AudioTrackInfo GetAudioTrackInfo();
	void ProcessAudioPlayerAction(AudioPlayerActionParams p);
	AudioPlayerHud* GetAudioPlayerHud() { return _audioPlayerHud.get(); }
	bool IsRunning() { return _console != nullptr; }
	bool IsRunAheadFrame() { return _isRunAheadFrame; }
	TimingInfo GetTimingInfo(CpuType cpuType);
	uint32_t GetFrameCount();
	uint32_t GetLagCounter();
	void ResetLagCounter();
	bool HasControlDevice(ControllerType type);
	void RegisterInputRecorder(IInputRecorder* recorder);
	void UnregisterInputRecorder(IInputRecorder* recorder);
	void RegisterInputProvider(IInputProvider* provider);
	void UnregisterInputProvider(IInputProvider* provider);
	double GetFps();
	template<CpuType type> __forceinline void ProcessInstruction()
	{
		if(_debugger) {
			_debugger->ProcessInstruction<type>();
		}
	}
	template<CpuType type, uint8_t accessWidth = 1, MemoryAccessFlags flags = MemoryAccessFlags::None, typename T> __forceinline void ProcessMemoryRead(uint32_t addr, T& value, MemoryOperationType opType)
	{
		if(_debugger) {
			_debugger->ProcessMemoryRead<type, accessWidth, flags>(addr, value, opType);
		}
	}
	template<CpuType type, uint8_t accessWidth = 1, MemoryAccessFlags flags = MemoryAccessFlags::None, typename T> __forceinline bool ProcessMemoryWrite(uint32_t addr, T& value, MemoryOperationType opType)
	{
		if(_debugger) {
			return _debugger->ProcessMemoryWrite<type, accessWidth, flags>(addr, value, opType);
		}
		return true;
	}
	template<CpuType cpuType, MemoryType memType, MemoryOperationType opType, typename T> __forceinline void ProcessMemoryAccess(uint32_t addr, T value)
	{
		if(_debugger) {
			_debugger->ProcessMemoryAccess<cpuType, memType, opType, T>(addr, value);
		}
	}
	template<CpuType type> __forceinline void ProcessIdleCycle()
	{
		if(_debugger) {
			_debugger->ProcessIdleCycle<type>();
		}
	}
	template<CpuType type> __forceinline void ProcessHaltedCpu()
	{
		if(_debugger) {
			_debugger->ProcessHaltedCpu<type>();
		}
	}
	template<CpuType type, typename T> __forceinline void ProcessPpuRead(uint32_t addr, T& value, MemoryType memoryType, MemoryOperationType opType = MemoryOperationType::Read)
	{
		if(_debugger) {
			_debugger->ProcessPpuRead<type>(addr, value, memoryType, opType);
		}
	}
	template<CpuType type, typename T> __forceinline void ProcessPpuWrite(uint32_t addr, T& value, MemoryType memoryType)
	{
		if(_debugger) {
			_debugger->ProcessPpuWrite<type>(addr, value, memoryType);
		}
	}
	template<CpuType type> __forceinline void ProcessPpuCycle()
	{
		if(_debugger) {
			_debugger->ProcessPpuCycle<type>();
		}
	}
	template<CpuType type> void ProcessInterrupt(uint32_t originalPc, uint32_t currentPc, bool forNmi)
	{
		if(_debugger) {
			_debugger->ProcessInterrupt<type>(originalPc, currentPc, forNmi);
		}
	}
	__forceinline void DebugLog(string log)
	{
		if(_debugger) {
			_debugger->Log(log);
		}
	}
	void ProcessEvent(EventType type, std::optional<CpuType> cpuType = std::nullopt);
	template<CpuType cpuType> void AddDebugEvent(DebugEventType evtType);
	void BreakIfDebugging(CpuType sourceCpu, BreakSource source);
};
enum class HashType
{
	Sha1,
	Sha1Cheat
};
```

## File: Core/Shared/Interfaces/IKeyManager.h
```
#pragma once
#include "pch.h"
enum class MouseButton
{
	LeftButton = 0,
	RightButton = 1,
	MiddleButton = 2,
	Button4 = 3,
	Button5 = 4
};
struct MousePosition
{
	int16_t X;
	int16_t Y;
	double RelativeX;
	double RelativeY;
};
struct MouseMovement
{
	int16_t dx;
	int16_t dy;
};
class IKeyManager
{
public:
	static constexpr int BaseMouseButtonIndex = 0x200;
	static constexpr int BaseGamepadIndex = 0x1000;
	virtual ~IKeyManager() {}
	virtual void RefreshState() = 0;
	virtual void UpdateDevices() = 0;
	virtual bool IsMouseButtonPressed(MouseButton button) = 0;
	virtual bool IsKeyPressed(uint16_t keyCode) = 0;
	virtual optional<int16_t> GetAxisPosition(uint16_t keyCode) { return std::nullopt; }
	virtual vector<uint16_t> GetPressedKeys() = 0;
	virtual string GetKeyName(uint16_t keyCode) = 0;
	virtual uint16_t GetKeyCode(string keyName) = 0;
	virtual bool SetKeyState(uint16_t scanCode, bool state) = 0;
	virtual void ResetKeyState() = 0;
	virtual void SetDisabled(bool disabled) = 0;
	virtual void SetForceFeedback(uint16_t magnitudeRight, uint16_t magnitudeLeft) {}
};
```

## File: Core/Shared/KeyManager.cpp
```cpp
#include "pch.h"
#include "Shared/Interfaces/IKeyManager.h"
#include "Shared/KeyManager.h"
#include "Shared/EmuSettings.h"
#include "Shared/Emulator.h"
#include "Shared/Video/VideoDecoder.h"
#include "Shared/Video/VideoRenderer.h"
IKeyManager* KeyManager::_keyManager = nullptr;
MousePosition KeyManager::_mousePosition = { 0, 0 };
double KeyManager::_xMouseMovement;
double KeyManager::_yMouseMovement;
EmuSettings* KeyManager::_settings = nullptr;
SimpleLock KeyManager::_lock;
void KeyManager::RegisterKeyManager(IKeyManager* keyManager)
{
	_xMouseMovement = 0;
	_yMouseMovement = 0;
	_keyManager = keyManager;
}
void KeyManager::RefreshKeyState()
{
	if(_keyManager != nullptr) {
		return _keyManager->RefreshState();
	}
}
void KeyManager::SetSettings(EmuSettings *settings)
{
	_settings = settings;
}
bool KeyManager::IsKeyPressed(uint16_t keyCode)
{
	if(_keyManager != nullptr) {
		return _settings->IsInputEnabled() && _keyManager->IsKeyPressed(keyCode);
	}
	return false;
}
optional<int16_t> KeyManager::GetAxisPosition(uint16_t keyCode)
{
	if(_keyManager != nullptr && _settings->IsInputEnabled()) {
		return _keyManager->GetAxisPosition(keyCode);
	}
	return std::nullopt;
}
bool KeyManager::IsMouseButtonPressed(MouseButton button)
{
	if(_keyManager != nullptr) {
		return _settings->IsInputEnabled() && _keyManager->IsMouseButtonPressed(button);
	}
	return false;
}
vector<uint16_t> KeyManager::GetPressedKeys()
{
	if(_keyManager != nullptr) {
		return _keyManager->GetPressedKeys();
	}
	return vector<uint16_t>();
}
string KeyManager::GetKeyName(uint16_t keyCode)
{
	if(_keyManager != nullptr) {
		return _keyManager->GetKeyName(keyCode);
	}
	return "";
}
uint16_t KeyManager::GetKeyCode(string keyName)
{
	if(_keyManager != nullptr) {
		return _keyManager->GetKeyCode(keyName);
	}
	return 0;
}
void KeyManager::UpdateDevices()
{
	if(_keyManager != nullptr) {
		_keyManager->UpdateDevices();
	}
}
void KeyManager::SetMouseMovement(int16_t x, int16_t y)
{
	auto lock = _lock.AcquireSafe();
	_xMouseMovement += x;
	_yMouseMovement += y;
}
MouseMovement KeyManager::GetMouseMovement(Emulator* emu, uint32_t mouseSensitivity)
{
	constexpr double divider[10] = { 0.25, 0.33, 0.5, 0.66, 0.75, 1, 1.5, 2, 3, 4 };
	FrameInfo rendererSize = emu->GetVideoRenderer()->GetRendererSize();
	FrameInfo frameSize = emu->GetVideoDecoder()->GetFrameInfo();
	double scale = (double)rendererSize.Width / frameSize.Width;
	double factor = scale / divider[mouseSensitivity];
	MouseMovement mov = {};
	auto lock = _lock.AcquireSafe();
	mov.dx = (int16_t)(_xMouseMovement / factor);
	mov.dy = (int16_t)(_yMouseMovement / factor);
	_xMouseMovement -= (mov.dx * factor);
	_yMouseMovement -= (mov.dy * factor);
	return mov;
}
void KeyManager::SetMousePosition(Emulator* emu, double x, double y)
{
	if(x < 0 || y < 0) {
		_mousePosition.X = -1;
		_mousePosition.Y = -1;
		_mousePosition.RelativeX = -1;
		_mousePosition.RelativeY = -1;
	} else {
		OverscanDimensions overscan = emu->GetSettings()->GetOverscan();
		FrameInfo frame = emu->GetVideoDecoder()->GetBaseFrameInfo(true);
		_mousePosition.X = (int32_t)(x*frame.Width + overscan.Left);
		_mousePosition.Y = (int32_t)(y*frame.Height + overscan.Top);
		_mousePosition.RelativeX = x;
		_mousePosition.RelativeY = y;
	}
}
MousePosition KeyManager::GetMousePosition()
{
	return _mousePosition;
}
void KeyManager::SetForceFeedback(uint16_t magnitudeRight, uint16_t magnitudeLeft)
{
	if(_keyManager != nullptr) {
		double intensity = _settings->GetInputConfig().ForceFeedbackIntensity;
		_keyManager->SetForceFeedback(magnitudeRight * intensity, magnitudeLeft * intensity);
	}
}
void KeyManager::SetForceFeedback(uint16_t magnitude)
{
	SetForceFeedback(magnitude, magnitude);
}
```

## File: Core/Shared/KeyManager.h
```
#pragma once
#include "pch.h"
#include "Shared/Interfaces/IKeyManager.h"
#include "Utilities/SimpleLock.h"
class Emulator;
class EmuSettings;
class KeyManager
{
private:
	static IKeyManager* _keyManager;
	static MousePosition _mousePosition;
	static double _xMouseMovement;
	static double _yMouseMovement;
	static EmuSettings* _settings;
	static SimpleLock _lock;
public:
	static void RegisterKeyManager(IKeyManager* keyManager);
	static void SetSettings(EmuSettings* settings);
	static void RefreshKeyState();
	static bool IsKeyPressed(uint16_t keyCode);
	static optional<int16_t> GetAxisPosition(uint16_t keyCode);
	static bool IsMouseButtonPressed(MouseButton button);
	static vector<uint16_t> GetPressedKeys();
	static string GetKeyName(uint16_t keyCode);
	static uint16_t GetKeyCode(string keyName);
	static void UpdateDevices();
	static void SetMouseMovement(int16_t x, int16_t y);
	static MouseMovement GetMouseMovement(Emulator* emu, uint32_t mouseSensitivity);
	static void SetMousePosition(Emulator* emu, double x, double y);
	static MousePosition GetMousePosition();
	static void SetForceFeedback(uint16_t magnitude);
	static void SetForceFeedback(uint16_t magnitudeRight, uint16_t magnitudeLeft);
};
```

## File: Core/Shared/MessageManager.h
```
#pragma once
#include "pch.h"
#include "Core/Shared/Interfaces/IMessageManager.h"
#include <unordered_map>
#include "Utilities/SimpleLock.h"
#ifdef _DEBUG
	#define LogDebug(msg) MessageManager::Log(msg);
	#define LogDebugIf(cond, msg) if(cond) { MessageManager::Log(msg); }
#else
	#define LogDebug(msg)
	#define LogDebugIf(cond, msg)
#endif
class MessageManager
{
private:
	static IMessageManager* _messageManager;
	static std::unordered_map<string, string> _enResources;
	static bool _osdEnabled;
	static bool _outputToStdout;
	static SimpleLock _logLock;
	static SimpleLock _messageLock;
	static std::list<string> _log;
public:
	static void SetOptions(bool osdEnabled, bool outputToStdout);
	static string Localize(string key);
	static void RegisterMessageManager(IMessageManager* messageManager);
	static void UnregisterMessageManager(IMessageManager* messageManager);
	static void DisplayMessage(string title, string message, string param1 = "", string param2 = "");
	static void Log(string message = "");
	static void ClearLog();
	static string GetLog();
};
```

## File: Core/Shared/RecordedRomTest.cpp
```cpp
#include "pch.h"
#include "Shared/RecordedRomTest.h"
#include "Shared/Emulator.h"
#include "Shared/EmuSettings.h"
#include "Shared/MessageManager.h"
#include "Shared/NotificationManager.h"
#include "Shared/Movies/MovieManager.h"
#include "Utilities/VirtualFile.h"
#include "Utilities/FolderUtilities.h"
#include "Utilities/md5.h"
#include "Utilities/ZipWriter.h"
#include "Utilities/ZipReader.h"
#include "Utilities/ArchiveReader.h"
RecordedRomTest::RecordedRomTest(Emulator* emu, bool inBackground)
{
	_emu = emu;
	_inBackground = inBackground;
	Reset();
}
RecordedRomTest::~RecordedRomTest()
{
	Reset();
}
void RecordedRomTest::SaveFrame()
{
	PpuFrameInfo frame = _emu->GetPpuFrame();
	uint8_t md5Hash[16];
	GetMd5Sum(md5Hash, frame.FrameBuffer, frame.FrameBufferSize);
	if(memcmp(_previousHash, md5Hash, 16) == 0 && _currentCount < 255) {
		_currentCount++;
	} else {
		uint8_t* hash = new uint8_t[16];
		memcpy(hash, md5Hash, 16);
		_screenshotHashes.push_back(hash);
		if(_currentCount > 0) {
			_repetitionCount.push_back(_currentCount);
		}
		_currentCount = 1;
		memcpy(_previousHash, md5Hash, 16);
		_signal.Signal();
	}
}
void RecordedRomTest::ValidateFrame()
{
	PpuFrameInfo frame = _emu->GetPpuFrame();
	uint8_t md5Hash[16];
	GetMd5Sum(md5Hash, frame.FrameBuffer, frame.FrameBufferSize);
	if(_currentCount == 0) {
		_currentCount = _repetitionCount.front();
		_repetitionCount.pop_front();
		_screenshotHashes.pop_front();
	}
	_currentCount--;
	if(memcmp(_screenshotHashes.front(), md5Hash, 16) != 0) {
		_badFrameCount++;
		_isLastFrameGood = false;
	} else {
		_isLastFrameGood = true;
	}
	if(_currentCount == 0 && _repetitionCount.empty()) {
		_runningTest = false;
		_signal.Signal();
	}
}
void RecordedRomTest::ProcessNotification(ConsoleNotificationType type, void* parameter)
{
	switch(type) {
		case ConsoleNotificationType::PpuFrameDone:
			if(_recording) {
				SaveFrame();
			} else if(_runningTest) {
				ValidateFrame();
			}
			break;
		default:
			break;
	}
}
void RecordedRomTest::Reset()
{
	memset(_previousHash, 0xFF, 16);
	_currentCount = 0;
	_repetitionCount.clear();
	for(uint8_t* hash : _screenshotHashes) {
		delete[] hash;
	}
	_screenshotHashes.clear();
	_runningTest = false;
	_recording = false;
	_badFrameCount = 0;
}
void RecordedRomTest::Record(string filename, bool reset)
{
	_emu->GetNotificationManager()->RegisterNotificationListener(shared_from_this());
	_filename = filename;
	string mrtFilename = FolderUtilities::CombinePath(FolderUtilities::GetFolderName(filename), FolderUtilities::GetFilename(filename, false) + ".mrt");
	_file.open(mrtFilename, ios::out | ios::binary);
	if(_file) {
		_emu->Lock();
		Reset();
		EmuSettings* settings = _emu->GetSettings();
		settings->GetSnesConfig().RamPowerOnState = RamState::AllZeros;
		settings->GetNesConfig().RamPowerOnState = RamState::AllZeros;
		settings->GetGameboyConfig().RamPowerOnState = RamState::AllZeros;
		settings->GetPcEngineConfig().RamPowerOnState = RamState::AllZeros;
		settings->GetSmsConfig().RamPowerOnState = RamState::AllZeros;
		settings->GetCvConfig().RamPowerOnState = RamState::AllZeros;
		settings->GetGbaConfig().RamPowerOnState = RamState::AllZeros;
		settings->GetSnesConfig().DisableFrameSkipping = true;
		settings->GetPcEngineConfig().DisableFrameSkipping = true;
		settings->GetGbaConfig().DisableFrameSkipping = true;
		settings->GetGbaConfig().SkipBootScreen = false;
		settings->GetWsConfig().UseBootRom = true;
		settings->GetWsConfig().LcdShowIcons = true;
		RecordMovieOptions options;
		string movieFilename = FolderUtilities::CombinePath(FolderUtilities::GetFolderName(filename), FolderUtilities::GetFilename(filename, false) + ".mmo");
		memcpy(options.Filename, movieFilename.c_str(), std::min(1000, (int)movieFilename.size()));
		options.RecordFrom = reset ? RecordMovieFrom::StartWithSaveData : RecordMovieFrom::CurrentState;
		_emu->GetMovieManager()->Record(options);
		_recording = true;
		_emu->Unlock();
	}
}
RomTestResult RecordedRomTest::Run(string filename)
{
	RomTestResult result = {};
	_emu->GetNotificationManager()->RegisterNotificationListener(shared_from_this());
	EmuSettings* settings = _emu->GetSettings();
	string testName = FolderUtilities::GetFilename(filename, false);
	ZipReader zipReader;
	zipReader.LoadArchive(filename);
	vector<string> files = zipReader.GetFileList();
	string romFile = "";
	for(string& file : files) {
		if(file.length() > 7 && file.substr(0, 7) == "TestRom") {
			romFile = file;
		}
	}
	if(romFile.empty()) {
		result.ErrorCode = -4;
		return result;
	}
	VirtualFile testMovie(filename, "TestMovie.mmo");
	VirtualFile testRom(filename, romFile);
	stringstream testData;
	zipReader.GetStream("TestData.mrt", testData);
	if(testData && testMovie.IsValid() && testRom.IsValid()) {
		char header[3];
		testData.read((char*)&header, 3);
		if(memcmp((char*)&header, "MRT", 3) != 0) {
			result.ErrorCode = -3;
			return result;
		}
		Reset();
		uint32_t hashCount;
		testData.read((char*)&hashCount, sizeof(uint32_t));
		for(uint32_t i = 0; i < hashCount; i++) {
			uint8_t repeatCount = 0;
			testData.read((char*)&repeatCount, sizeof(uint8_t));
			_repetitionCount.push_back(repeatCount);
			uint8_t* screenshotHash = new uint8_t[16];
			testData.read((char*)screenshotHash, 16);
			_screenshotHashes.push_back(screenshotHash);
		}
		_currentCount = _repetitionCount.front();
		_repetitionCount.pop_front();
		if(testName.compare("demo_pal") == 0 || testName.substr(0, 4).compare("pal_") == 0) {
			settings->GetNesConfig().Region = ConsoleRegion::Pal;
		} else {
			settings->GetNesConfig().Region = ConsoleRegion::Auto;
		}
		settings->GetSnesConfig().RamPowerOnState = RamState::AllZeros;
		settings->GetNesConfig().RamPowerOnState = RamState::AllZeros;
		settings->GetGameboyConfig().RamPowerOnState = RamState::AllZeros;
		settings->GetPcEngineConfig().RamPowerOnState = RamState::AllZeros;
		settings->GetSmsConfig().RamPowerOnState = RamState::AllZeros;
		settings->GetCvConfig().RamPowerOnState = RamState::AllZeros;
		settings->GetGbaConfig().RamPowerOnState = RamState::AllZeros;
		settings->GetSnesConfig().DisableFrameSkipping = true;
		settings->GetPcEngineConfig().DisableFrameSkipping = true;
		settings->GetGbaConfig().DisableFrameSkipping = true;
		settings->GetGbaConfig().SkipBootScreen = false;
		settings->GetWsConfig().UseBootRom = true;
		settings->GetWsConfig().LcdShowIcons = true;
		_emu->Lock();
		if(_emu->LoadRom(testRom, VirtualFile(""))) {
			_emu->GetMovieManager()->Play(testMovie, true);
			settings->SetFlag(EmulationFlags::MaximumSpeed);
			_runningTest = true;
			_emu->Unlock();
			_emu->Resume();
			_signal.Wait();
			_emu->Stop(!_inBackground);
			_runningTest = false;
		} else {
			//Something went wrong when loading the rom
			_emu->Unlock();
			result.ErrorCode = -2;
			return result;
		}
		settings->ClearFlag(EmulationFlags::MaximumSpeed);
		result.ErrorCode = _badFrameCount;
		result.State = _badFrameCount == 0 ? RomTestState::Passed : (_isLastFrameGood ? RomTestState::PassedWithWarnings : RomTestState::Failed);
		return result;
	}
	result.ErrorCode = -1;
	return result;
}
void RecordedRomTest::Stop()
{
	if(_recording) {
		Save();
	}
	Reset();
}
void RecordedRomTest::Save()
{
	//Wait until the next frame is captured to end the recording
	_signal.Wait();
	_repetitionCount.push_back(_currentCount);
	_recording = false;
	//Stop playing/recording the movie
	_emu->GetMovieManager()->Stop();
	_file.write("MRT", 3);
	uint32_t hashCount = (uint32_t)_screenshotHashes.size();
	_file.write((char*)&hashCount, sizeof(uint32_t));
	for(uint32_t i = 0; i < hashCount; i++) {
		_file.write((char*)&_repetitionCount[i], sizeof(uint8_t));
		_file.write((char*)&_screenshotHashes[i][0], 16);
	}
	_file.close();
	ZipWriter writer;
	writer.Initialize(_filename);
	string mrtFilename = FolderUtilities::CombinePath(FolderUtilities::GetFolderName(_filename), FolderUtilities::GetFilename(_filename, false) + ".mrt");
	writer.AddFile(mrtFilename, "TestData.mrt");
	std::remove(mrtFilename.c_str());
	string mmoFilename = FolderUtilities::CombinePath(FolderUtilities::GetFolderName(_filename), FolderUtilities::GetFilename(_filename, false) + ".mmo");
	writer.AddFile(mmoFilename, "TestMovie.mmo");
	std::remove(mmoFilename.c_str());
	writer.AddFile(_emu->GetRomInfo().RomFile.GetFilePath(), "TestRom" + _emu->GetRomInfo().RomFile.GetFileExtension());
	writer.Save();
	MessageManager::DisplayMessage("Test", "TestFileSavedTo", FolderUtilities::GetFilename(_filename, true));
}
```

## File: Core/Shared/SaveStateManager.cpp
```cpp
#include "pch.h"
#include "Utilities/FolderUtilities.h"
#include "Utilities/ZipWriter.h"
#include "Utilities/ZipReader.h"
#include "Utilities/PNGHelper.h"
#include "Shared/SaveStateManager.h"
#include "Shared/MessageManager.h"
#include "Shared/Emulator.h"
#include "Shared/EmuSettings.h"
#include "Shared/Movies/MovieManager.h"
#include "Shared/RenderedFrame.h"
#include "Shared/EventType.h"
#include "Debugger/Debugger.h"
#include "Netplay/GameClient.h"
#include "Shared/Video/VideoDecoder.h"
#include "Shared/Video/VideoRenderer.h"
#include "Shared/Video/BaseVideoFilter.h"
SaveStateManager::SaveStateManager(Emulator* emu)
{
	_emu = emu;
	_lastIndex = 1;
}
string SaveStateManager::GetStateFilepath(int stateIndex)
{
	string romFile = _emu->GetRomInfo().RomFile.GetFileName();
	string folder = FolderUtilities::GetSaveStateFolder();
	string filename = FolderUtilities::GetFilename(romFile, false) + "_" + std::to_string(stateIndex) + ".mss";
	return FolderUtilities::CombinePath(folder, filename);
}
void SaveStateManager::SelectSaveSlot(int slotIndex)
{
	_lastIndex = slotIndex;
	MessageManager::DisplayMessage("SaveStates", "SaveStateSlotSelected", std::to_string(_lastIndex));
}
void SaveStateManager::MoveToNextSlot()
{
	_lastIndex = (_lastIndex % MaxIndex) + 1;
	MessageManager::DisplayMessage("SaveStates", "SaveStateSlotSelected", std::to_string(_lastIndex));
}
void SaveStateManager::MoveToPreviousSlot()
{
	_lastIndex = (_lastIndex == 1 ? SaveStateManager::MaxIndex : (_lastIndex - 1));
	MessageManager::DisplayMessage("SaveStates", "SaveStateSlotSelected", std::to_string(_lastIndex));
}
void SaveStateManager::SaveState()
{
	SaveState(_lastIndex);
}
bool SaveStateManager::LoadState()
{
	return LoadState(_lastIndex);
}
void SaveStateManager::GetSaveStateHeader(ostream &stream)
{
	uint32_t emuVersion = _emu->GetSettings()->GetVersion();
	uint32_t formatVersion = SaveStateManager::FileFormatVersion;
	stream.write("MSS", 3);
	WriteValue(stream, emuVersion);
	WriteValue(stream, formatVersion);
	WriteValue(stream, (uint32_t)_emu->GetConsoleType());
	SaveVideoData(stream);
	RomInfo romInfo = _emu->GetRomInfo();
	string romName = FolderUtilities::GetFilename(romInfo.RomFile.GetFileName(), true);
	WriteValue(stream, (uint32_t)romName.size());
	stream.write(romName.c_str(), romName.size());
}
void SaveStateManager::SaveState(ostream &stream)
{
	GetSaveStateHeader(stream);
	_emu->Serialize(stream, false);
}
bool SaveStateManager::SaveState(string filepath, bool showSuccessMessage)
{
	ofstream file(filepath, ios::out | ios::binary);
	if(file) {
		{
			auto lock = _emu->AcquireLock();
			SaveState(file);
			_emu->ProcessEvent(EventType::StateSaved);
		}
		file.close();
		if(showSuccessMessage) {
			MessageManager::DisplayMessage("SaveStates", "SaveStateSavedFile", filepath);
		}
		return true;
	}
	return false;
}
void SaveStateManager::SaveState(int stateIndex, bool displayMessage)
{
	string filepath = SaveStateManager::GetStateFilepath(stateIndex);
	if(SaveState(filepath, false)) {
		if(displayMessage) {
			MessageManager::DisplayMessage("SaveStates", "SaveStateSaved", std::to_string(stateIndex));
		}
	}
}
void SaveStateManager::SaveVideoData(ostream& stream)
{
	PpuFrameInfo frame = _emu->GetPpuFrame();
	WriteValue(stream, frame.FrameBufferSize);
	WriteValue(stream, frame.Width);
	WriteValue(stream, frame.Height);
	WriteValue(stream, (uint32_t)(_emu->GetVideoDecoder()->GetLastFrameScale() * 100));
	unsigned long compressedSize = compressBound(frame.FrameBufferSize);
	vector<uint8_t> compressedData(compressedSize, 0);
	compress2(compressedData.data(), &compressedSize, (const unsigned char*)frame.FrameBuffer, frame.FrameBufferSize, MZ_DEFAULT_LEVEL);
	WriteValue(stream, (uint32_t)compressedSize);
	stream.write((char*)compressedData.data(), (uint32_t)compressedSize);
}
bool SaveStateManager::GetVideoData(vector<uint8_t>& out, RenderedFrame& frame, istream& stream)
{
	uint32_t frameBufferSize = ReadValue(stream);
	frame.Width = ReadValue(stream);
	frame.Height = ReadValue(stream);
	frame.Scale = ReadValue(stream) / 100.0;
	uint32_t compressedSize = ReadValue(stream);
	if(compressedSize > 1024 * 1024 * 2) {
		return false;
	}
	vector<uint8_t> compressedData(compressedSize, 0);
	stream.read((char*)compressedData.data(), compressedSize);
	out = vector<uint8_t>(frameBufferSize, 0);
	unsigned long decompSize = frameBufferSize;
	if(uncompress(out.data(), &decompSize, compressedData.data(), (unsigned long)compressedData.size()) == MZ_OK) {
		return true;
	}
	return false;
}
bool SaveStateManager::LoadState(istream &stream)
{
	if(!_emu->IsRunning()) {
		return false;
	} else if(_emu->GetGameClient()->Connected()) {
		MessageManager::DisplayMessage("Netplay", "NetplayNotAllowed");
		return false;
	}
	char header[3];
	stream.read(header, 3);
	if(memcmp(header, "MSS", 3) == 0) {
		uint32_t emuVersion = ReadValue(stream);
		if(emuVersion > _emu->GetSettings()->GetVersion()) {
			MessageManager::DisplayMessage("SaveStates", "SaveStateNewerVersion");
			return false;
		}
		uint32_t fileFormatVersion = ReadValue(stream);
		if(fileFormatVersion < SaveStateManager::MinimumSupportedVersion) {
			MessageManager::DisplayMessage("SaveStates", "SaveStateIncompatibleVersion");
			return false;
		}
		if(fileFormatVersion <= 3) {
			stream.seekg(40, ios::cur);
		}
		ConsoleType stateConsoleType = (ConsoleType)ReadValue(stream);
		RenderedFrame frame;
		vector<uint8_t> frameData;
		if(GetVideoData(frameData, frame, stream)) {
			frame.FrameBuffer = frameData.data();
		} else {
			MessageManager::DisplayMessage("SaveStates", "SaveStateInvalidFile");
			return false;
		}
		uint32_t nameLength = ReadValue(stream);
		vector<char> nameBuffer(nameLength);
		stream.read(nameBuffer.data(), nameBuffer.size());
		string romName(nameBuffer.data(), nameLength);
		DeserializeResult result = _emu->Deserialize(stream, fileFormatVersion, false, stateConsoleType);
		if(result == DeserializeResult::Success) {
			_emu->GetMovieManager()->Stop();
			if(_emu->IsPaused() && !_emu->GetVideoRenderer()->IsRecording()) {
				_emu->GetVideoDecoder()->UpdateFrame(frame, true, false);
			}
			return true;
		} else if(result == DeserializeResult::SpecificError) {
			return false;
		}
	}
	MessageManager::DisplayMessage("SaveStates", "SaveStateInvalidFile");
	return false;
}
bool SaveStateManager::LoadState(string filepath, bool showSuccessMessage)
{
	ifstream file(filepath, ios::in | ios::binary);
	bool result = false;
	if(file.good()) {
		{
			auto lock = _emu->AcquireLock();
			result = LoadState(file);
			if(result) {
				_emu->ProcessEvent(EventType::StateLoaded);
			}
		}
		file.close();
		if(result) {
			if(showSuccessMessage) {
				MessageManager::DisplayMessage("SaveStates", "SaveStateLoadedFile", filepath);
			}
		}
	} else {
		MessageManager::DisplayMessage("SaveStates", "SaveStateEmpty");
	}
	return result;
}
bool SaveStateManager::LoadState(int stateIndex)
{
	string filepath = SaveStateManager::GetStateFilepath(stateIndex);
	if(LoadState(filepath, false)) {
		MessageManager::DisplayMessage("SaveStates", "SaveStateLoaded", std::to_string(stateIndex));
		return true;
	}
	return false;
}
void SaveStateManager::SaveRecentGame(string romName, string romPath, string patchPath)
{
	if(_emu->GetSettings()->CheckFlag(EmulationFlags::ConsoleMode) || _emu->GetSettings()->CheckFlag(EmulationFlags::TestMode)) {
		return;
	}
	string filename = FolderUtilities::GetFilename(_emu->GetRomInfo().RomFile.GetFileName(), false) + ".rgd";
	ZipWriter writer;
	writer.Initialize(FolderUtilities::CombinePath(FolderUtilities::GetRecentGamesFolder(), filename));
	std::stringstream pngStream;
	_emu->GetVideoDecoder()->TakeScreenshot(pngStream);
	writer.AddFile(pngStream, "Screenshot.png");
	std::stringstream stateStream;
	SaveStateManager::SaveState(stateStream);
	writer.AddFile(stateStream, "Savestate.mss");
	std::stringstream romInfoStream;
	romInfoStream << romName << std::endl;
	romInfoStream << romPath << std::endl;
	romInfoStream << patchPath << std::endl;
	FrameInfo baseFrameSize = _emu->GetVideoDecoder()->GetBaseFrameInfo(true);
	double aspectRatio = _emu->GetSettings()->GetAspectRatio(_emu->GetRegion(), baseFrameSize);
	if(aspectRatio > 0) {
		romInfoStream << "aspectratio=" << aspectRatio << std::endl;
	}
	writer.AddFile(romInfoStream, "RomInfo.txt");
	writer.Save();
}
void SaveStateManager::LoadRecentGame(string filename, bool resetGame)
{
	VirtualFile file(filename);
	if(!file.IsValid()) {
		MessageManager::DisplayMessage("Error", "CouldNotLoadFile", file.GetFileName());
		return;
	}
	ZipReader reader;
	reader.LoadArchive(filename);
	stringstream romInfoStream, stateStream;
	reader.GetStream("RomInfo.txt", romInfoStream);
	reader.GetStream("Savestate.mss", stateStream);
	string romName, romPath, patchPath;
	std::getline(romInfoStream, romName);
	std::getline(romInfoStream, romPath);
	std::getline(romInfoStream, patchPath);
	try {
		if(_emu->LoadRom(romPath, patchPath)) {
			if(!resetGame) {
				auto lock = _emu->AcquireLock();
				SaveStateManager::LoadState(stateStream);
			}
		}
	} catch(std::exception&) {
		_emu->Stop(true);
	}
}
int32_t SaveStateManager::GetSaveStatePreview(string saveStatePath, uint8_t* pngData)
{
	ifstream stream(saveStatePath, ios::binary);
	if(!stream) {
		return -1;
	}
	char header[3];
	stream.read(header, 3);
	if(memcmp(header, "MSS", 3) == 0) {
		uint32_t emuVersion = ReadValue(stream);
		if(emuVersion > _emu->GetSettings()->GetVersion() || emuVersion <= 0x10000) {
			return -1;
		}
		uint32_t fileFormatVersion = ReadValue(stream);
		if(fileFormatVersion < SaveStateManager::MinimumSupportedVersion) {
			return -1;
		}
		stream.seekg(4, ios::cur);
		vector<uint8_t> frameData;
		RenderedFrame frame;
		if(GetVideoData(frameData, frame, stream)) {
			FrameInfo baseFrameInfo;
			baseFrameInfo.Width = frame.Width;
			baseFrameInfo.Height = frame.Height;
			unique_ptr<BaseVideoFilter> filter(_emu->GetVideoFilter(true));
			filter->SetBaseFrameInfo(baseFrameInfo);
			FrameInfo frameInfo = filter->SendFrame((uint16_t*)frameData.data(), 0, 0, nullptr);
			std::stringstream pngStream;
			PNGHelper::WritePNG(pngStream, filter->GetOutputBuffer(), frameInfo.Width, frameInfo.Height);
			string data = pngStream.str();
			memcpy(pngData, data.c_str(), data.size());
			return (int32_t)frameData.size();
		}
	}
	return -1;
}
void SaveStateManager::WriteValue(ostream& stream, uint32_t value)
{
	stream.put(value & 0xFF);
	stream.put((value >> 8) & 0xFF);
	stream.put((value >> 16) & 0xFF);
	stream.put((value >> 24) & 0xFF);
}
uint32_t SaveStateManager::ReadValue(istream& stream)
{
	char a = 0, b = 0, c = 0, d = 0;
	stream.get(a);
	stream.get(b);
	stream.get(c);
	stream.get(d);
	uint32_t result = (uint8_t)a | ((uint8_t)b << 8) | ((uint8_t)c << 16) | ((uint8_t)d << 24);
	return result;
}
```

## File: README.md
```markdown
# Mesen

Mesen is a multi-system emulator (NES, SNES, Game Boy, Game Boy Advance, PC Engine, SMS/Game Gear, WonderSwan) for Windows, Linux and macOS.  

## Releases

The latest stable version is available from the [releases on GitHub](https://github.com/SourMesen/Mesen2/releases).  

## Development Builds

[![Mesen](https://github.com/SourMesen/Mesen2/actions/workflows/build.yml/badge.svg)](https://github.com/SourMesen/Mesen2/actions/workflows/build.yml)

#### <ins>Native builds</ins> (recommended) ####

These builds don't require .NET to be installed.  

* [Windows 10 / 11](https://nightly.link/SourMesen/Mesen2/workflows/build/master/Mesen%20%28Windows%20-%20net8.0%20-%20AoT%29.zip)  
* [Linux x64](https://nightly.link/SourMesen/Mesen2/workflows/build/master/Mesen%20%28Linux%20-%20ubuntu-22.04%20-%20clang_aot%29.zip)  (requires **SDL2**)
* [macOS - Intel](https://nightly.link/SourMesen/Mesen2/workflows/build/master/Mesen%20%28macOS%20-%20macos-13%20-%20clang_aot%29.zip)  (requires **SDL2**)
* [macOS - Apple Silicon](https://nightly.link/SourMesen/Mesen2/workflows/build/master/Mesen%20%28macOS%20-%20macos-14%20-%20clang_aot%29.zip)  (requires **SDL2**)

#### <ins>.NET builds</ins> ####

These builds require **.NET 8** to be installed (except the Windows 7 build which requires .NET 6).  
For Linux and macOS, **SDL2** must also be installed.

* [Windows 7 / 8 (.NET 6)](https://nightly.link/SourMesen/Mesen2/workflows/build/master/Mesen%20%28Windows%20-%20net6.0%29.zip)  
* [Linux x64 - AppImage](https://nightly.link/SourMesen/Mesen2/workflows/build/master/Mesen%20(Linux%20x64%20-%20AppImage).zip)  
* [Linux ARM64](https://nightly.link/SourMesen/Mesen2/workflows/build/master/Mesen%20%28Linux%20-%20ubuntu-22.04-arm%20-%20clang%29.zip)  
* [Linux ARM64 - AppImage](https://nightly.link/SourMesen/Mesen2/workflows/build/master/Mesen%20(Linux%20ARM64%20-%20AppImage).zip)


#### <ins>Notes</ins> ####

Other builds are also available in the [Actions](https://github.com/SourMesen/Mesen2/actions) tab.

**SteamOS**: See [SteamOS.md](SteamOS.md)

## Compiling

See [COMPILING.md](COMPILING.md)

## License

Mesen is available under the GPL V3 license.  Full text here: <http://www.gnu.org/licenses/gpl-3.0.en.html>

Copyright (C) 2014-2025 Sour

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
```

## File: Core/Shared/Emulator.cpp
```cpp
#include "pch.h"
#include <assert.h>
#include "Shared/Emulator.h"
#include "Shared/NotificationManager.h"
#include "Shared/Audio/SoundMixer.h"
#include "Shared/Audio/AudioPlayerHud.h"
#include "Shared/Video/VideoDecoder.h"
#include "Shared/Video/VideoRenderer.h"
#include "Shared/Video/DebugHud.h"
#include "Shared/FrameLimiter.h"
#include "Shared/MessageManager.h"
#include "Shared/KeyManager.h"
#include "Shared/EmuSettings.h"
#include "Shared/SaveStateManager.h"
#include "Shared/Video/DebugStats.h"
#include "Shared/RewindManager.h"
#include "Shared/ShortcutKeyHandler.h"
#include "Shared/EmulatorLock.h"
#include "Shared/DebuggerRequest.h"
#include "Shared/Movies/MovieManager.h"
#include "Shared/BatteryManager.h"
#include "Shared/CheatManager.h"
#include "Shared/SystemActionManager.h"
#include "Shared/TimingInfo.h"
#include "Shared/HistoryViewer.h"
#include "Netplay/GameServer.h"
#include "Netplay/GameClient.h"
#include "Shared/McpServer.h"
#include "Shared/Interfaces/IConsole.h"
#include "Shared/Interfaces/IBarcodeReader.h"
#include "Shared/Interfaces/ITapeRecorder.h"
#include "Shared/BaseControlManager.h"
#include "SNES/SnesConsole.h"
#include "SNES/SnesDefaultVideoFilter.h"
#include "NES/NesConsole.h"
#include "Gameboy/Gameboy.h"
#include "PCE/PceConsole.h"
#include "SMS/SmsConsole.h"
#include "GBA/GbaConsole.h"
#include "WS/WsConsole.h"
#include "Debugger/Debugger.h"
#include "Debugger/BaseEventManager.h"
#include "Debugger/DebugTypes.h"
#include "Debugger/DebugUtilities.h"
#include "Utilities/Serializer.h"
#include "Utilities/Timer.h"
#include "Utilities/VirtualFile.h"
#include "Utilities/PlatformUtilities.h"
#include "Utilities/FolderUtilities.h"
#include "Shared/MemoryOperationType.h"
#include "Shared/EventType.h"
Emulator::Emulator() :
	_settings(new EmuSettings(this)),
	_debugHud(new DebugHud()),
	_scriptHud(new DebugHud()),
	_notificationManager(new NotificationManager()),
	_batteryManager(new BatteryManager()),
	_soundMixer(new SoundMixer(this)),
	_videoRenderer(new VideoRenderer(this)),
	_videoDecoder(new VideoDecoder(this)),
	_saveStateManager(new SaveStateManager(this)),
	_cheatManager(new CheatManager(this)),
	_movieManager(new MovieManager(this)),
	_historyViewer(new HistoryViewer(this)),
	_gameServer(new GameServer(this)),
	_gameClient(new GameClient(this)),
	_rewindManager(new RewindManager(this))
{
	_paused = false;
	_pauseOnNextFrame = false;
	_stopFlag = false;
	_isRunAheadFrame = false;
	_lockCounter = 0;
	_threadPaused = false;
	_debugRequestCount = 0;
	_blockDebuggerRequestCount = 0;
	_videoDecoder->Init();
}
Emulator::~Emulator()
{
}
void Emulator::Initialize(bool enableShortcuts)
{
	_systemActionManager.reset(new SystemActionManager(this));
	if(enableShortcuts) {
		_shortcutKeyHandler.reset(new ShortcutKeyHandler(this));
		_notificationManager->RegisterNotificationListener(_shortcutKeyHandler);
	}
	_videoDecoder->StartThread();
	_videoRenderer->StartThread();
	if(!_mcpServer) {
		_mcpServer.reset(new McpServer(this, 12345));
		_mcpServer->Start();
	}
}
void Emulator::Release()
{
	Stop(true);
	_gameClient->Disconnect();
	_gameServer->StopServer();
	if(_mcpServer) {
		_mcpServer->Stop();
		_mcpServer.reset();
	}
	_videoDecoder->StopThread();
	_videoRenderer->StopThread();
	_shortcutKeyHandler.reset();
}
void Emulator::Run()
{
	if(!_console) {
		return;
	}
	while(!_runLock.TryAcquire(50)) {
		if(_stopFlag) {
			return;
		}
	}
	_stopFlag = false;
	_isRunAheadFrame = false;
	PlatformUtilities::EnableHighResolutionTimer();
	PlatformUtilities::DisableScreensaver();
	_emulationThreadId = std::this_thread::get_id();
	_frameDelay = GetFrameDelay();
	_stats.reset(new DebugStats());
	_frameLimiter.reset(new FrameLimiter(_frameDelay));
	_lastFrameTimer.Reset();
	while(!_stopFlag) {
		if(_mcpServer) {
			_mcpServer->DrainCommandQueue();
		}
		if(_mcpServer && _mcpServer->IsExternalControlled()) {
			std::this_thread::sleep_for(std::chrono::duration<int, std::milli>(1));
		} else {
			bool useRunAhead = _settings->GetEmulationConfig().RunAheadFrames > 0 && !_debugger && !_audioPlayerHud && !_rewindManager->IsRewinding() && _settings->GetEmulationSpeed() > 0 && _settings->GetEmulationSpeed() <= 100;
			if(useRunAhead) {
				RunFrameWithRunAhead();
			} else {
				_console->RunFrame();
				_rewindManager->ProcessEndOfFrame();
				_historyViewer->ProcessEndOfFrame();
				ProcessSystemActions();
			}
			ProcessAutoSaveState();
		}
		WaitForLock();
		if(_pauseOnNextFrame) {
			_pauseOnNextFrame = false;
			_paused = true;
		}
		if(_paused && !_stopFlag && !_debugger) {
			WaitForPauseEnd();
		}
	}
	_emulationThreadId = thread::id();
	if(_runLock.IsLockedByCurrentThread()) {
		_runLock.Release();
	}
	PlatformUtilities::EnableScreensaver();
	PlatformUtilities::RestoreTimerResolution();
}
void Emulator::ProcessAutoSaveState()
{
	if(_autoSaveStateFrameCounter > 0) {
		_autoSaveStateFrameCounter--;
		if(_autoSaveStateFrameCounter == 0) {
			_saveStateManager->SaveState(SaveStateManager::AutoSaveStateIndex, false);
		}
	} else {
		uint32_t saveStateDelay = _settings->GetPreferences().AutoSaveStateDelay;
		if(saveStateDelay > 0) {
			_autoSaveStateFrameCounter = (uint32_t)(GetFps() * saveStateDelay * 60);
		}
	}
}
bool Emulator::ProcessSystemActions()
{
	if(_systemActionManager->IsResetPressed()) {
		Reset();
		shared_ptr<Debugger> debugger = _debugger.lock();
		if(debugger) {
			debugger->ResetSuspendCounter();
		}
		return true;
	} else if(_systemActionManager->IsPowerCyclePressed()) {
		PowerCycle();
		return true;
	}
	return false;
}
void Emulator::RunFrameWithRunAhead()
{
	stringstream runAheadState;
	uint32_t frameCount = _settings->GetEmulationConfig().RunAheadFrames;
	_isRunAheadFrame = true;
	_console->RunFrame();
	Serialize(runAheadState, false, 0);
	while(frameCount > 1) {
		frameCount--;
		_console->RunFrame();
	}
	_isRunAheadFrame = false;
	_console->RunFrame();
	_rewindManager->ProcessEndOfFrame();
	_historyViewer->ProcessEndOfFrame();
	bool wasReset = ProcessSystemActions();
	if(!wasReset) {
		_isRunAheadFrame = true;
		Deserialize(runAheadState, SaveStateManager::FileFormatVersion, false);
		_isRunAheadFrame = false;
	}
}
void Emulator::OnBeforeSendFrame()
{
	if(!_isRunAheadFrame) {
		if(_audioPlayerHud) {
			_audioPlayerHud->Draw(GetFrameCount(), GetFps());
		}
		if(_stats && _settings->GetPreferences().ShowDebugInfo) {
			double lastFrameTime = _lastFrameTimer.GetElapsedMS();
			_lastFrameTimer.Reset();
			_stats->DisplayStats(this, lastFrameTime);
		}
	}
}
void Emulator::ProcessEndOfFrame()
{
	if(!_isRunAheadFrame) {
		_frameLimiter->ProcessFrame();
		while(_frameLimiter->WaitForNextFrame()) {
			if(_stopFlag || _frameDelay != GetFrameDelay() || _paused || _pauseOnNextFrame || _lockCounter > 0) {
				break;
			}
		}
		double newFrameDelay = GetFrameDelay();
		if(newFrameDelay != _frameDelay) {
			_frameDelay = newFrameDelay;
			_frameLimiter->SetDelay(_frameDelay);
		}
		_console->GetControlManager()->ProcessEndOfFrame();
	}
	_frameRunning = false;
}
void Emulator::Stop(bool sendNotification, bool preventRecentGameSave, bool saveBattery)
{
	BlockDebuggerRequests();
	_stopFlag = true;
	_notificationManager->SendNotification(ConsoleNotificationType::BeforeGameUnload);
	ResetDebugger();
	if(_emuThread) {
		_emuThread->join();
		_emuThread.release();
	}
	if(_console && saveBattery) {
		_console->SaveBattery();
	}
	if(!preventRecentGameSave && _console && !_settings->GetPreferences().DisableGameSelectionScreen && !_audioPlayerHud) {
		RomInfo romInfo = GetRomInfo();
		_saveStateManager->SaveRecentGame(romInfo.RomFile.GetFileName(), romInfo.RomFile, romInfo.PatchFile);
	}
	if(sendNotification) {
		_notificationManager->SendNotification(ConsoleNotificationType::BeforeEmulationStop);
	}
	_movieManager->Stop();
	_videoDecoder->StopThread();
	_rewindManager->Reset();
	if(_console) {
		_console.reset();
	}
	OnBeforePause(true);
	if(sendNotification) {
		_notificationManager->SendNotification(ConsoleNotificationType::EmulationStopped);
	}
	_blockDebuggerRequestCount--;
}
void Emulator::Reset()
{
	Lock();
	_console->Reset();
	_systemActionManager->ResetState();
	_console->GetControlManager()->UpdateInputState();
	_console->GetControlManager()->ResetLagCounter();
	_videoRenderer->ClearFrame();
	_notificationManager->SendNotification(ConsoleNotificationType::GameReset);
	ProcessEvent(EventType::Reset);
	Unlock();
}
void Emulator::ReloadRom(bool forPowerCycle)
{
	RomInfo info = GetRomInfo();
	if(!LoadRom((string)info.RomFile, (string)info.PatchFile, !forPowerCycle, forPowerCycle)) {
		if(forPowerCycle) {
			_systemActionManager->ResetState();
			SuspendDebugger(true);
		}
	}
}
void Emulator::PowerCycle()
{
	ReloadRom(true);
}
bool Emulator::LoadRom(VirtualFile romFile, VirtualFile patchFile, bool stopRom, bool forPowerCycle)
{
	bool result = false;
	try {
		result = InternalLoadRom(romFile, patchFile, stopRom, forPowerCycle);
	} catch(std::exception& ex) {
		_videoDecoder->StartThread();
		_videoRenderer->StartThread();
		MessageManager::DisplayMessage("Error", "UnexpectedError", ex.what());
		Stop(false, true, false);
	}
	if(!result) {
		_notificationManager->SendNotification(ConsoleNotificationType::GameLoadFailed);
	}
	return result;
}
bool Emulator::InternalLoadRom(VirtualFile romFile, VirtualFile patchFile, bool stopRom, bool forPowerCycle)
{
	if(!romFile.IsValid()) {
		MessageManager::DisplayMessage("Error", "CouldNotLoadFile", romFile.GetFileName());
		return false;
	}
	if(IsEmulationThread()) {
		_threadPaused = true;
	}
	BlockDebuggerRequests();
	auto emuLock = AcquireLock();
	auto dbgLock = _debuggerLock.AcquireSafe();
	auto lock = _loadLock.AcquireSafe();
	_notificationManager->SendNotification(ConsoleNotificationType::BeforeGameLoad);
	bool wasPaused = IsPaused();
	shared_ptr<Debugger> debugger = _debugger.lock();
	bool debuggerActive = debugger != nullptr;
	ResetDebugger();
	if(patchFile.IsValid()) {
		if(romFile.ApplyPatch(patchFile)) {
			MessageManager::DisplayMessage("Patch", "ApplyingPatch", patchFile.GetFileName());
		} else {
			MessageManager::DisplayMessage("Patch", "PatchFailed", patchFile.GetFileName());
		}
	}
	if(_console) {
		_console->SaveBattery();
	}
	_soundMixer->StopAudio();
	if(!forPowerCycle) {
		_movieManager->Stop();
	}
	ConsoleMemoryInfo originalConsoleMemory[DebugUtilities::GetMemoryTypeCount()] = {};
	memcpy(originalConsoleMemory, _consoleMemory, sizeof(_consoleMemory));
	unique_ptr<IConsole> console;
	LoadRomResult result = LoadRomResult::UnknownType;
	TryLoadRom(romFile, result, console, false);
	TryLoadRom(romFile, result, console, true);
	if(result != LoadRomResult::Success) {
		MessageManager::DisplayMessage("Error", "CouldNotLoadFile", romFile.GetFileName());
		if(debugger) {
			_debugger.reset(debugger);
			debugger->ResetSuspendCounter();
		}
		_blockDebuggerRequestCount--;
		return false;
	}
	if(debugger) {
		debugger->Release();
		debugger.reset();
	}
	if(stopRom) {
		bool gameChanged = (string)_rom.RomFile != (string)romFile || (string)_rom.PatchFile != (string)patchFile;
		Stop(false, !gameChanged, false);
		memset(originalConsoleMemory, 0, sizeof(originalConsoleMemory));
	}
	_videoDecoder->StopThread();
	_videoRenderer->StopThread();
	_rom.RomFile = (string)romFile;
	_rom.PatchFile = (string)patchFile;
	_rom.Format = console->GetRomFormat();
	_rom.DipSwitches = console->GetDipSwitchInfo();
	if(_rom.Format == RomFormat::Spc || _rom.Format == RomFormat::Nsf || _rom.Format == RomFormat::Gbs || _rom.Format == RomFormat::PceHes) {
		_audioPlayerHud.reset(new AudioPlayerHud(this));
	} else {
		_audioPlayerHud.reset();
	}
	_cheatManager->ClearCheats(false);
	uint32_t pollCounter = 0;
	if(forPowerCycle && console->GetControlManager()) {
		pollCounter = console->GetControlManager()->GetPollCounter();
	}
	InitConsole(console, originalConsoleMemory, forPowerCycle);
	_console->GetControlManager()->SetPollCounter(pollCounter);
	_rewindManager->InitHistory();
	if(debuggerActive || _settings->CheckFlag(EmulationFlags::ConsoleMode)) {
		InitDebugger();
	}
	_notificationManager->RegisterNotificationListener(_rewindManager);
	_systemActionManager->ResetState();
	_console->GetControlManager()->UpdateControlDevices();
	_console->GetControlManager()->UpdateInputState();
	_autoSaveStateFrameCounter = 0;
	_blockDebuggerRequestCount--;
	dbgLock.Release();
	_threadPaused = true;
	bool needPause = wasPaused && _debugger;
	if(needPause) {
		_debugger->Step(GetCpuTypes()[0], 1, StepType::Step, BreakSource::Pause);
	}
	GameLoadedEventParams params = { needPause, forPowerCycle };
	_notificationManager->SendNotification(ConsoleNotificationType::GameLoaded, &params);
	_threadPaused = false;
	if(!forPowerCycle && !_audioPlayerHud) {
		ConsoleRegion region = _console->GetRegion();
		string modelName = region == ConsoleRegion::Pal ? "PAL" : (region == ConsoleRegion::Dendy ? "Dendy" : "NTSC");
		MessageManager::DisplayMessage(modelName, FolderUtilities::GetFilename(GetRomInfo().RomFile.GetFileName(), false));
	}
	_videoDecoder->StartThread();
	_videoRenderer->StartThread();
	if(stopRom) {
		_stopFlag = false;
		_emuThread.reset(new thread(&Emulator::Run, this));
	}
	return true;
}
void Emulator::InitConsole(unique_ptr<IConsole>& newConsole, ConsoleMemoryInfo originalConsoleMemory[], bool preserveRom)
{
	if(preserveRom && _console) {
		magic_enum::enum_for_each<MemoryType>([&](MemoryType memType) {
			if(DebugUtilities::IsRom(memType)) {
				uint32_t orgSize = originalConsoleMemory[(int)memType].Size;
				if(orgSize > 0 && GetMemory(memType).Size == orgSize) {
					memcpy(_consoleMemory[(int)memType].Memory, originalConsoleMemory[(int)memType].Memory, orgSize);
				}
			}
		});
	}
	_console.reset(newConsole);
	_consoleType = _console->GetConsoleType();
	_notificationManager->RegisterNotificationListener(_console.lock());
}
void Emulator::TryLoadRom(VirtualFile& romFile, LoadRomResult& result, unique_ptr<IConsole>& console, bool useFileSignature)
{
	TryLoadRom<NesConsole>(romFile, result, console, useFileSignature);
	TryLoadRom<SnesConsole>(romFile, result, console, useFileSignature);
	TryLoadRom<Gameboy>(romFile, result, console, useFileSignature);
	TryLoadRom<PceConsole>(romFile, result, console, useFileSignature);
	TryLoadRom<SmsConsole>(romFile, result, console, useFileSignature);
	TryLoadRom<GbaConsole>(romFile, result, console, useFileSignature);
	TryLoadRom<WsConsole>(romFile, result, console, useFileSignature);
}
template<typename T>
void Emulator::TryLoadRom(VirtualFile& romFile, LoadRomResult& result, unique_ptr<IConsole>& console, bool useFileSignature)
{
	if(result == LoadRomResult::UnknownType) {
		string romExt = romFile.GetFileExtension();
		vector<string> extensions = T::GetSupportedExtensions();
		if(std::find(extensions.begin(), extensions.end(), romExt) != extensions.end() || (useFileSignature && romFile.CheckFileSignature(T::GetSupportedSignatures()))) {
			ConsoleMemoryInfo consoleMemory[DebugUtilities::GetMemoryTypeCount()] = {};
			memcpy(consoleMemory, _consoleMemory, sizeof(_consoleMemory));
			memset(_consoleMemory, 0, sizeof(_consoleMemory));
			bool hasBattery = _batteryManager->HasBattery();
			_batteryManager->Initialize(FolderUtilities::GetFilename(romFile.GetFileName(), false));
			console.reset(new T(this));
			result = console->LoadRom(romFile);
			if(result != LoadRomResult::Success) {
				memcpy(_consoleMemory, consoleMemory, sizeof(_consoleMemory));
				_batteryManager->Initialize(FolderUtilities::GetFilename(_rom.RomFile.GetFileName(), false), hasBattery);
			}
		}
	}
}
string Emulator::GetHash(HashType type)
{
	shared_ptr<IConsole> console = _console.lock();
	string hash = console->GetHash(type);
	if(hash.size()) {
		return hash;
	} else if(type == HashType::Sha1) {
		return _rom.RomFile.GetSha1Hash();
	} else if(type == HashType::Sha1Cheat) {
		return _rom.RomFile.GetSha1Hash();
	}
	return "";
}
uint32_t Emulator::GetCrc32()
{
	return _rom.RomFile.GetCrc32();
}
PpuFrameInfo Emulator::GetPpuFrame()
{
	shared_ptr<IConsole> console = GetConsole();
	return console ? console->GetPpuFrame() : PpuFrameInfo {};
}
ConsoleRegion Emulator::GetRegion()
{
	shared_ptr<IConsole> console = GetConsole();
	return console ? console->GetRegion() : ConsoleRegion::Ntsc;
}
shared_ptr<IConsole> Emulator::GetConsole()
{
	return _console.lock();
}
IConsole* Emulator::GetConsoleUnsafe()
{
#ifdef _DEBUG
	if(!IsEmulationThread()) {
		throw std::runtime_error("GetConsoleUnsafe should only be called from the emulation thread");
	}
#endif
	return _console.get();
}
ConsoleType Emulator::GetConsoleType()
{
	return _consoleType;
}
vector<CpuType> Emulator::GetCpuTypes()
{
	shared_ptr<IConsole> console = GetConsole();
	return console ? console->GetCpuTypes() : vector<CpuType>{};
}
TimingInfo Emulator::GetTimingInfo(CpuType cpuType)
{
	shared_ptr<IConsole> console = GetConsole();
	return console ? console->GetTimingInfo(cpuType) : TimingInfo {};
}
uint64_t Emulator::GetMasterClock()
{
#if DEBUG
	if(!IsEmulationThread()) {
		throw std::runtime_error("called on wrong thread");
	}
#endif
	return _console->GetMasterClock();
}
uint32_t Emulator::GetMasterClockRate()
{
#if DEBUG
	if(!IsEmulationThread()) {
		throw std::runtime_error("called on wrong thread");
	}
#endif
	return _console->GetMasterClockRate();
}
uint32_t Emulator::GetFrameCount()
{
	return GetPpuFrame().FrameCount;
}
uint32_t Emulator::GetLagCounter()
{
	shared_ptr<IConsole> console = GetConsole();
	return console ? console->GetControlManager()->GetLagCounter() : 0;
}
void Emulator::ResetLagCounter()
{
	shared_ptr<IConsole> console = GetConsole();
	if(console) {
		console->GetControlManager()->ResetLagCounter();
	}
}
bool Emulator::HasControlDevice(ControllerType type)
{
	shared_ptr<IConsole> console = GetConsole();
	return console ? console->GetControlManager()->HasControlDevice(type) : false;
}
void Emulator::RegisterInputRecorder(IInputRecorder* recorder)
{
	shared_ptr<IConsole> console = GetConsole();
	if(console) {
		console->GetControlManager()->RegisterInputRecorder(recorder);
	}
}
void Emulator::UnregisterInputRecorder(IInputRecorder* recorder)
{
	shared_ptr<IConsole> console = GetConsole();
	if(console) {
		console->GetControlManager()->UnregisterInputRecorder(recorder);
	}
}
void Emulator::RegisterInputProvider(IInputProvider* provider)
{
	shared_ptr<IConsole> console = GetConsole();
	if(console) {
		console->GetControlManager()->RegisterInputProvider(provider);
	}
}
void Emulator::UnregisterInputProvider(IInputProvider* provider)
{
	shared_ptr<IConsole> console = GetConsole();
	if(console) {
		console->GetControlManager()->UnregisterInputProvider(provider);
	}
}
double Emulator::GetFps()
{
	shared_ptr<IConsole> console = GetConsole();
	double fps = console ? console->GetFps() : 60.0;
	if(_settings->GetVideoConfig().IntegerFpsMode) {
		fps = std::round(fps);
	}
	return fps;
}
double Emulator::GetFrameDelay()
{
	uint32_t emulationSpeed = _settings->GetEmulationSpeed();
	double frameDelay;
	if(emulationSpeed == 0) {
		frameDelay = 0;
	} else {
		frameDelay = 1000 / GetFps();
		frameDelay /= (emulationSpeed / 100.0);
	}
	return frameDelay;
}
void Emulator::PauseOnNextFrame()
{
	shared_ptr<Debugger> debugger = _debugger.lock();
	if(debugger) {
		debugger->PauseOnNextFrame();
	} else {
		_pauseOnNextFrame = true;
		_paused = false;
	}
}
void Emulator::Pause()
{
	shared_ptr<Debugger> debugger = _debugger.lock();
	if(debugger) {
		debugger->Step(GetCpuTypes()[0], 1, StepType::Step, BreakSource::Pause);
	} else {
		_paused = true;
	}
}
void Emulator::Resume()
{
	shared_ptr<Debugger> debugger = _debugger.lock();
	if(debugger) {
		debugger->Run();
	} else {
		_paused = false;
	}
}
bool Emulator::IsPaused()
{
	shared_ptr<Debugger> debugger = _debugger.lock();
	if(debugger) {
		return debugger->IsPaused();
	} else {
		return _paused;
	}
}
void Emulator::OnBeforePause(bool clearAudioBuffer)
{
	_soundMixer->StopAudio(clearAudioBuffer);
	KeyManager::SetForceFeedback(0);
}
void Emulator::WaitForPauseEnd()
{
	_notificationManager->SendNotification(ConsoleNotificationType::GamePaused);
	OnBeforePause(false);
	_runLock.Release();
	PlatformUtilities::EnableScreensaver();
	PlatformUtilities::RestoreTimerResolution();
	while(_paused && !_rewindManager->IsRewinding() && !_stopFlag && !_debugger) {
		std::this_thread::sleep_for(std::chrono::duration<int, std::milli>(30));
		if(_systemActionManager->IsResetPending()) {
			break;
		}
	}
	PlatformUtilities::DisableScreensaver();
	PlatformUtilities::EnableHighResolutionTimer();
	while(!_stopFlag && !_runLock.TryAcquire(50)) { }
	if(!_stopFlag) {
		_notificationManager->SendNotification(ConsoleNotificationType::GameResumed);
	}
}
EmulatorLock Emulator::AcquireLock(bool allowDebuggerLock)
{
	return EmulatorLock(this, allowDebuggerLock);
}
void Emulator::Lock()
{
	SuspendDebugger(false);
	_lockCounter++;
	_runLock.Acquire();
}
void Emulator::Unlock()
{
	SuspendDebugger(true);
	_runLock.Release();
	_lockCounter--;
}
bool Emulator::IsThreadPaused()
{
	return !_emuThread || _threadPaused;
}
void Emulator::SuspendDebugger(bool release)
{
	shared_ptr<Debugger> debugger = _debugger.lock();
	if(debugger) {
		debugger->SuspendDebugger(release);
	}
}
void Emulator::WaitForLock()
{
	if(_lockCounter > 0) {
		_runLock.Release();
		_threadPaused = true;
		while(_lockCounter > 0 && !_stopFlag) {}
		shared_ptr<Debugger> debugger = _debugger.lock();
		if(debugger) {
			while(debugger->HasBreakRequest() && !_stopFlag) {}
		}
		if(!_stopFlag) {
			_threadPaused = false;
			_runLock.Acquire();
		}
	}
}
void Emulator::Serialize(ostream& out, bool includeSettings, int compressionLevel)
{
	Serializer s(SaveStateManager::FileFormatVersion, true);
	if(includeSettings) {
		SV(_settings);
	}
	s.Stream(_console, "");
	s.SaveTo(out, compressionLevel);
}
DeserializeResult Emulator::Deserialize(istream& in, uint32_t fileFormatVersion, bool includeSettings, optional<ConsoleType> srcConsoleType, bool sendNotification)
{
	Serializer s(fileFormatVersion, false);
	if(!s.LoadFrom(in)) {
		return DeserializeResult::InvalidFile;
	}
	if(includeSettings) {
		SV(_settings);
	}
	if(srcConsoleType.has_value() && srcConsoleType.value() != _console->GetConsoleType()) {
		//Used to allow save states taken on GB/GBC/SGB to be loaded on any of the 3 systems
		SaveStateCompatInfo compatInfo = _console->ValidateSaveStateCompatibility(srcConsoleType.value());
		if(!compatInfo.IsCompatible) {
			MessageManager::DisplayMessage("SaveStates", "SaveStateWrongSystem");
			return DeserializeResult::SpecificError;
		}
		s.RemoveKeys(compatInfo.FieldsToRemove);
		if(!compatInfo.PrefixToAdd.empty()) {
			s.AddKeyPrefix(compatInfo.PrefixToAdd);
		} else if(!compatInfo.PrefixToRemove.empty()) {
			s.RemoveKeyPrefix(compatInfo.PrefixToRemove);
		}
		if(!s.IsValid()) {
			MessageManager::DisplayMessage("SaveStates", "SaveStateWrongSystem");
			return DeserializeResult::SpecificError;
		}
	}
	s.Stream(_console, "");
	if(s.HasError()) {
		return DeserializeResult::SpecificError;
	}
	if(sendNotification) {
		_notificationManager->SendNotification(ConsoleNotificationType::StateLoaded);
	}
	return DeserializeResult::Success;
}
BaseVideoFilter* Emulator::GetVideoFilter(bool getDefaultFilter)
{
	shared_ptr<IConsole> console = GetConsole();
	return console ? console->GetVideoFilter(getDefaultFilter) : new SnesDefaultVideoFilter(this);
}
void Emulator::GetScreenRotationOverride(uint32_t& rotation)
{
	shared_ptr<IConsole> console = GetConsole();
	if(console) {
		console->GetScreenRotationOverride(rotation);
	}
}
void Emulator::InputBarcode(uint64_t barcode, uint32_t digitCount)
{
	shared_ptr<IConsole> console = GetConsole();
	if(console) {
		shared_ptr<IBarcodeReader> reader = console->GetControlManager()->GetControlDevice<IBarcodeReader>();
		if(reader) {
			auto lock = AcquireLock();
			reader->InputBarcode(barcode, digitCount);
		}
	}
}
void Emulator::ProcessTapeRecorderAction(TapeRecorderAction action, string filename)
{
	shared_ptr<IConsole> console = GetConsole();
	if(console) {
		shared_ptr<ITapeRecorder> recorder = console->GetControlManager()->GetControlDevice<ITapeRecorder>();
		if(recorder) {
			auto lock = AcquireLock();
			recorder->ProcessTapeRecorderAction(action, filename);
		}
	}
}
ShortcutState Emulator::IsShortcutAllowed(EmulatorShortcut shortcut, uint32_t shortcutParam)
{
	shared_ptr<IConsole> console = GetConsole();
	return console ? console->IsShortcutAllowed(shortcut, shortcutParam) : ShortcutState::Default;
}
bool Emulator::IsKeyboardConnected()
{
	shared_ptr<IConsole> console = GetConsole();
	return console ? console->GetControlManager()->IsKeyboardConnected() : false;
}
void Emulator::BlockDebuggerRequests()
{
	auto lock = _debuggerLock.AcquireSafe();
	_blockDebuggerRequestCount++;
	if(_debugger) {
		_debugger->ResetSuspendCounter();
	}
	while(_debugRequestCount > 0) {
		std::this_thread::sleep_for(std::chrono::duration<int, std::milli>(10));
	}
}
DebuggerRequest Emulator::GetDebugger(bool autoInit)
{
	if(IsRunning() && _blockDebuggerRequestCount == 0) {
		auto lock = _debuggerLock.AcquireSafe();
		if(IsRunning() && _blockDebuggerRequestCount == 0) {
			if(!_debugger && autoInit) {
				InitDebugger();
			}
			return DebuggerRequest(this);
		}
	}
	return DebuggerRequest(nullptr);
}
void Emulator::ResetDebugger(bool startDebugger)
{
	shared_ptr<Debugger> currentDbg = _debugger.lock();
	if(currentDbg) {
		currentDbg->SuspendDebugger(false);
	}
	if(_emulationThreadId == std::this_thread::get_id()) {
		_debugger.reset(startDebugger ? new Debugger(this, _console.get()) : nullptr);
	} else {
		auto emuLock = AcquireLock();
		_debugger.reset(startDebugger ? new Debugger(this, _console.get()) : nullptr);
	}
}
void Emulator::InitDebugger()
{
	if(!_debugger) {
		auto lock = _debuggerLock.AcquireSafe();
		if(!_debugger) {
			BlockDebuggerRequests();
			ResetDebugger(true);
			_blockDebuggerRequestCount--;
			_paused = false;
		}
	}
}
void Emulator::StopDebugger()
{
	_paused = IsPaused();
	if(_debugger) {
		auto lock = _debuggerLock.AcquireSafe();
		if(_debugger) {
			BlockDebuggerRequests();
			ResetDebugger();
			_blockDebuggerRequestCount--;
		}
	}
}
bool Emulator::IsEmulationThread()
{
	return _emulationThreadId == _currentThreadId;
}
void Emulator::SetStopCode(int32_t stopCode)
{
	if(_stopCode != 0) {
		return;
	}
	_stopCode = stopCode;
	if(!_stopFlag && !_stopRequested) {
		_stopRequested = true;
		thread stopEmuTask([this]() {
			Stop(true);
		});
		stopEmuTask.detach();
	}
}
void Emulator::RegisterMemory(MemoryType type, void* memory, uint32_t size)
{
	_consoleMemory[(int)type] = { memory, size };
}
ConsoleMemoryInfo Emulator::GetMemory(MemoryType type)
{
	return _consoleMemory[(int)type];
}
AudioTrackInfo Emulator::GetAudioTrackInfo()
{
	shared_ptr<IConsole> console = GetConsole();
	if(!console) {
		return {};
	}
	AudioTrackInfo track = console->GetAudioTrackInfo();
	AudioConfig audioCfg = _settings->GetAudioConfig();
	if(track.Length <= 0 && audioCfg.AudioPlayerEnableTrackLength) {
		track.Length = audioCfg.AudioPlayerTrackLength;
		track.FadeLength = 1;
	}
	return track;
}
void Emulator::ProcessAudioPlayerAction(AudioPlayerActionParams p)
{
	shared_ptr<IConsole> console = GetConsole();
	if(console) {
		console->ProcessAudioPlayerAction(p);
	}
}
void Emulator::ProcessEvent(EventType type, std::optional<CpuType> cpuType)
{
	if(_debugger) {
		_debugger->ProcessEvent(type, cpuType);
	}
}
template<CpuType cpuType>
void Emulator::AddDebugEvent(DebugEventType evtType)
{
	if(_debugger) {
		_debugger->GetEventManager(cpuType)->AddEvent(evtType);
	}
}
void Emulator::BreakIfDebugging(CpuType sourceCpu, BreakSource source)
{
	if(_debugger) {
		_debugger->BreakImmediately(sourceCpu, source);
	}
}
template void Emulator::AddDebugEvent<CpuType::Snes>(DebugEventType evtType);
template void Emulator::AddDebugEvent<CpuType::Gameboy>(DebugEventType evtType);
template void Emulator::AddDebugEvent<CpuType::Nes>(DebugEventType evtType);
template void Emulator::AddDebugEvent<CpuType::Pce>(DebugEventType evtType);
thread_local std::thread::id Emulator::_currentThreadId = std::this_thread::get_id();
```

## File: Core/Shared/MessageManager.cpp
```cpp
#include "pch.h"
#include "Shared/MessageManager.h"
std::unordered_map<string, string> MessageManager::_enResources = {
	{ "Cheats", u8"Cheats" },
	{ "Debug", u8"Debug" },
	{ "EmulationSpeed", u8"Emulation Speed" },
	{ "ClockRate", u8"Clock Rate" },
	{ "Error", u8"Error" },
	{ "GameInfo", u8"Game Info" },
	{ "GameLoaded", u8"Game loaded" },
	{ "Input", u8"Input" },
	{ "Patch", u8"Patch" },
	{ "Movies", u8"Movies" },
	{ "NetPlay", u8"Net Play" },
	{ "Overclock", u8"Overclock" },
	{ "Region", u8"Region" },
	{ "SaveStates", u8"Save States" },
	{ "ScreenshotSaved", u8"Screenshot Saved" },
	{ "SoundRecorder", u8"Sound Recorder" },
	{ "Test", u8"Test" },
	{ "VideoRecorder", u8"Video Recorder" },
	{ "ApplyingPatch", u8"Applying patch: %1" },
	{ "PatchFailed", u8"Failed to apply patch: %1" },
	{ "CheatApplied", u8"1 cheat applied." },
	{ "CheatsApplied", u8"%1 cheats applied." },
	{ "CheatsDisabled", u8"All cheats disabled." },
	{ "CoinInsertedSlot", u8"Coin inserted (slot %1)" },
	{ "ConnectedToServer", u8"Connected to server." },
	{ "ConnectionLost", u8"Connection to server lost." },
	{ "CouldNotConnect", u8"Could not connect to the server." },
	{ "CouldNotInitializeAudioSystem", u8"Could not initialize audio system" },
	{ "CouldNotFindRom", u8"Could not find matching game ROM. (%1)" },
	{ "CouldNotWriteToFile", u8"Could not write to file: %1" },
	{ "CouldNotLoadFile", u8"Could not load file: %1" },
	{ "EmulationMaximumSpeed", u8"Maximum speed" },
	{ "EmulationSpeedPercent", u8"%1%" },
	{ "FdsDiskInserted", u8"Disk %1 Side %2 inserted." },
	{ "Frame", u8"Frame" },
	{ "GameCrash", u8"Game has crashed (%1)" },
	{ "KeyboardModeDisabled", u8"Keyboard mode disabled." },
	{ "KeyboardModeEnabled", u8"Keyboard connected - shortcut keys disabled." },
	{ "Lag", u8"Lag" },
	{ "Mapper", u8"Mapper: %1, SubMapper: %2" },
	{ "MovieEnded", u8"Movie ended." },
	{ "MovieStopped", u8"Movie stopped." },
	{ "MovieInvalid", u8"Invalid movie file." },
	{ "MovieMissingRom", u8"Missing ROM required (%1) to play movie." },
	{ "MovieNewerVersion", u8"Cannot load movies created by a more recent version of Mesen. Please download the latest version." },
	{ "MovieIncompatibleVersion", u8"This movie is incompatible with this version of Mesen." },
	{ "MovieIncorrectConsole", u8"This movie was recorded on another console (%1) and can't be loaded." },
	{ "MoviePlaying", u8"Playing movie: %1" },
	{ "MovieRecordingTo", u8"Recording to: %1" },
	{ "MovieSaved", u8"Movie saved to file: %1" },
	{ "NetplayVersionMismatch", u8"Netplay client is not running the same version of Mesen and has been disconnected." },
	{ "NetplayNotAllowed", u8"This action is not allowed while connected to a server." },
	{ "OverclockEnabled", u8"Overclocking enabled." },
	{ "OverclockDisabled", u8"Overclocking disabled." },
	{ "PrgSizeWarning", u8"PRG size is smaller than 32kb" },
	{ "SaveStateEmpty", u8"Slot is empty." },
	{ "SaveStateIncompatibleVersion", u8"Save state is incompatible with this version of Mesen." },
	{ "SaveStateInvalidFile", u8"Invalid save state file." },
	{ "SaveStateWrongSystem", u8"Error: State cannot be loaded (wrong console type)" },
	{ "SaveStateLoaded", u8"State #%1 loaded." },
	{ "SaveStateLoadedFile", u8"State loaded: %1" },
	{ "SaveStateSavedFile", u8"State saved: %1" },
	{ "SaveStateMissingRom", u8"Missing ROM required (%1) to load save state." },
	{ "SaveStateNewerVersion", u8"Cannot load save states created by a more recent version of Mesen. Please download the latest version." },
	{ "SaveStateSaved", u8"State #%1 saved." },
	{ "SaveStateSlotSelected", u8"Slot #%1 selected." },
	{ "ScanlineTimingWarning", u8"PPU timing has been changed." },
	{ "ServerStarted", u8"Server started (Port: %1)" },
	{ "ServerStopped", u8"Server stopped" },
	{ "SoundRecorderStarted", u8"Recording to: %1" },
	{ "SoundRecorderStopped", u8"Recording saved to: %1" },
	{ "TestFileSavedTo", u8"Test file saved to: %1" },
	{ "UnexpectedError", u8"Unexpected error: %1" },
	{ "UnsupportedMapper", u8"Unsupported mapper (%1), cannot load game." },
	{ "VideoRecorderStarted", u8"Recording to: %1" },
	{ "VideoRecorderStopped", u8"Recording saved to: %1" },
};
std::list<string> MessageManager::_log;
SimpleLock MessageManager::_logLock;
SimpleLock MessageManager::_messageLock;
bool MessageManager::_osdEnabled = true;
bool MessageManager::_outputToStdout = false;
IMessageManager* MessageManager::_messageManager = nullptr;
void MessageManager::RegisterMessageManager(IMessageManager* messageManager)
{
	auto lock = _messageLock.AcquireSafe();
	if(MessageManager::_messageManager == nullptr) {
		MessageManager::_messageManager = messageManager;
	}
}
void MessageManager::UnregisterMessageManager(IMessageManager* messageManager)
{
	auto lock = _messageLock.AcquireSafe();
	if(MessageManager::_messageManager == messageManager) {
		MessageManager::_messageManager = nullptr;
	}
}
void MessageManager::SetOptions(bool osdEnabled, bool outputToStdout)
{
	_osdEnabled = osdEnabled;
	_outputToStdout = outputToStdout;
}
string MessageManager::Localize(string key)
{
	std::unordered_map<string, string> *resources = &_enResources;
	if(resources) {
		if(resources->find(key) != resources->end()) {
			return (*resources)[key];
		}
	}
	return key;
}
void MessageManager::DisplayMessage(string title, string message, string param1, string param2)
{
	if(MessageManager::_messageManager) {
		auto lock = _messageLock.AcquireSafe();
		if(!MessageManager::_messageManager) {
			return;
		}
		title = Localize(title);
		message = Localize(message);
		size_t startPos = message.find(u8"%1");
		if(startPos != std::string::npos) {
			message.replace(startPos, 2, param1);
		}
		startPos = message.find(u8"%2");
		if(startPos != std::string::npos) {
			message.replace(startPos, 2, param2);
		}
		if(_osdEnabled) {
			MessageManager::_messageManager->DisplayMessage(title, message);
		} else {
			MessageManager::Log("[" + title + "] " + message);
		}
	}
}
void MessageManager::Log(string message)
{
	auto lock = _logLock.AcquireSafe();
	if(message.empty()) {
		message = "------------------------------------------------------";
	}
	if(_log.size() >= 1000) {
		_log.pop_front();
	}
	_log.push_back(message);
	if(_outputToStdout) {
		std::cout << message << std::endl;
	}
}
void MessageManager::ClearLog()
{
	auto lock = _logLock.AcquireSafe();
	_log.clear();
}
string MessageManager::GetLog()
{
	auto lock = _logLock.AcquireSafe();
	stringstream ss;
	for(string &msg : _log) {
		ss << msg << "\n";
	}
	return ss.str();
}
```

## File: Core/Shared/SettingTypes.h
```
#pragma once
#include "pch.h"
#include <algorithm>
enum class EmulationFlags
{
	Turbo = 0x01,
	Rewind = 0x02,
	TurboOrRewind = 0x03,
	MaximumSpeed = 0x04,
	InBackground = 0x08,
	ConsoleMode = 0x10,
	TestMode = 0x20,
	OutputToStdout = 0x40,
};
enum class ScaleFilterType
{
	xBRZ = 0,
	HQX = 1,
	Scale2x = 2,
	_2xSai = 3,
	Super2xSai = 4,
	SuperEagle = 5,
	Prescale = 6,
	LcdGrid = 7,
};
enum class VideoFilterType
{
	None = 0,
	NtscBlargg,
	NtscBisqwit,
	LcdGrid,
	xBRZ2x,
	xBRZ3x,
	xBRZ4x,
	xBRZ5x,
	xBRZ6x,
	HQ2x,
	HQ3x,
	HQ4x,
	Scale2x,
	Scale3x,
	Scale4x,
	_2xSai,
	Super2xSai,
	SuperEagle,
	Prescale2x,
	Prescale3x,
	Prescale4x,
	Prescale6x,
	Prescale8x,
	Prescale10x
};
enum class VideoResizeFilter
{
	NearestNeighbor = 0,
	Bilinear = 1
};
enum class VideoAspectRatio
{
	NoStretching = 0,
	Auto = 1,
	NTSC = 2,
	PAL = 3,
	Standard = 4,
	Widescreen = 5,
	Custom = 6
};
enum class NtscBisqwitFilterScale
{
	_2x,
	_4x,
	_8x,
};
struct VideoConfig
{
	double CustomAspectRatio = 1.0;
	VideoFilterType VideoFilter = VideoFilterType::None;
	VideoAspectRatio AspectRatio = VideoAspectRatio::NoStretching;
	bool UseBilinearInterpolation = false;
	bool UseSrgbTextureFormat = false;
	bool VerticalSync = false;
	bool IntegerFpsMode = false;
	double Brightness = 0;
	double Contrast = 0;
	double Hue = 0;
	double Saturation = 0;
	double ScanlineIntensity = 0;
	double LcdGridTopLeftBrightness = 1.0;
	double LcdGridTopRightBrightness = 1.0;
	double LcdGridBottomLeftBrightness = 1.0;
	double LcdGridBottomRightBrightness = 1.0;
	double NtscArtifacts = 0;
	double NtscBleed = 0;
	double NtscFringing = 0;
	double NtscGamma = 0;
	double NtscResolution = 0;
	double NtscSharpness = 0;
	bool NtscMergeFields = false;
	NtscBisqwitFilterScale NtscScale = NtscBisqwitFilterScale::_2x;
	double NtscYFilterLength = 1.0;
	double NtscIFilterLength = 1.0;
	double NtscQFilterLength = 1.0;
	bool FullscreenForceIntegerScale = false;
	bool UseExclusiveFullscreen = false;
	uint32_t ExclusiveFullscreenRefreshRateNtsc = 60;
	uint32_t ExclusiveFullscreenRefreshRatePal = 50;
	uint32_t FullscreenResWidth = 0;
	uint32_t FullscreenResHeight = 0;
	uint32_t ScreenRotation = 0;
};
struct AudioConfig
{
	const char* AudioDevice = nullptr;
	bool EnableAudio = true;
	bool DisableDynamicSampleRate = false;
	uint32_t MasterVolume = 100;
	uint32_t SampleRate = 48000;
	uint32_t AudioLatency = 60;
	bool MuteSoundInBackground = false;
	bool ReduceSoundInBackground = true;
	bool ReduceSoundInFastForward = false;
	uint32_t VolumeReduction = 75;
	bool ReverbEnabled = false;
	uint32_t ReverbStrength = 0;
	uint32_t ReverbDelay = 0;
	bool CrossFeedEnabled = false;
	uint32_t CrossFeedRatio = 0;
	bool EnableEqualizer = false;
	double Band1Gain = 0;
	double Band2Gain = 0;
	double Band3Gain = 0;
	double Band4Gain = 0;
	double Band5Gain = 0;
	double Band6Gain = 0;
	double Band7Gain = 0;
	double Band8Gain = 0;
	double Band9Gain = 0;
	double Band10Gain = 0;
	double Band11Gain = 0;
	double Band12Gain = 0;
	double Band13Gain = 0;
	double Band14Gain = 0;
	double Band15Gain = 0;
	double Band16Gain = 0;
	double Band17Gain = 0;
	double Band18Gain = 0;
	double Band19Gain = 0;
	double Band20Gain = 0;
	bool AudioPlayerEnableTrackLength = true;
	uint32_t AudioPlayerTrackLength = 120;
	bool AudioPlayerAutoDetectSilence = true;
	uint32_t AudioPlayerSilenceDelay = 3;
};
enum class ControllerType
{
	None,
	SnesController,
	SnesMouse,
	SuperScope,
	Multitap,
	SnesRumbleController,
	NesController,
	FamicomController,
	FamicomControllerP2,
	NesZapper,
	NesArkanoidController,
	PowerPadSideA,
	PowerPadSideB,
	SuborMouse,
	VirtualBoyController,
	FourScore,
	FamicomZapper,
	TwoPlayerAdapter,
	FourPlayerAdapter,
	FamicomArkanoidController,
	OekaKidsTablet,
	FamilyTrainerMatSideA,
	FamilyTrainerMatSideB,
	KonamiHyperShot,
	FamilyBasicKeyboard,
	PartyTap,
	Pachinko,
	ExcitingBoxing,
	JissenMahjong,
	SuborKeyboard,
	BarcodeBattler,
	HoriTrack,
	BandaiHyperShot,
	AsciiTurboFile,
	BattleBox,
	BandaiMicrophone,
	DatachBarcodeReader,
	GameboyController,
	GameboyAccelerometer,
	PceController,
	PceTurboTap,
	PceAvenuePad6,
	SmsController,
	SmsLightPhaser,
	ColecoVisionController,
	GbaController,
	WsController,
	WsControllerVertical
};
struct KeyMapping
{
	uint16_t A = 0;
	uint16_t B = 0;
	uint16_t X = 0;
	uint16_t Y = 0;
	uint16_t L = 0;
	uint16_t R = 0;
	uint16_t Up = 0;
	uint16_t Down = 0;
	uint16_t Left = 0;
	uint16_t Right = 0;
	uint16_t Start = 0;
	uint16_t Select = 0;
	uint16_t U = 0;
	uint16_t D = 0;
	uint16_t TurboA = 0;
	uint16_t TurboB = 0;
	uint16_t TurboX = 0;
	uint16_t TurboY = 0;
	uint16_t TurboL = 0;
	uint16_t TurboR = 0;
	uint16_t TurboSelect = 0;
	uint16_t TurboStart = 0;
	uint16_t GenericKey1 = 0;
	uint16_t CustomKeys[100] = {};
	bool HasKeySet()
	{
		if(A || B || X || Y || L || R || U || D || Up || Down || Left || Right || Start || Select || TurboA || TurboB || TurboX || TurboY || TurboL || TurboR || TurboStart || TurboSelect || GenericKey1) {
			return true;
		}
		for(uint32_t i = 0; i < 100; i++) {
			if(CustomKeys[i] != 0) {
				return true;
			}
		}
		return false;
	}
};
struct KeyMappingSet
{
	KeyMapping Mapping1;
	KeyMapping Mapping2;
	KeyMapping Mapping3;
	KeyMapping Mapping4;
	uint32_t TurboSpeed = 0;
	vector<KeyMapping> GetKeyMappingArray()
	{
		vector<KeyMapping> keyMappings;
		if(Mapping1.HasKeySet()) {
			keyMappings.push_back(Mapping1);
		}
		if(Mapping2.HasKeySet()) {
			keyMappings.push_back(Mapping2);
		}
		if(Mapping3.HasKeySet()) {
			keyMappings.push_back(Mapping3);
		}
		if(Mapping4.HasKeySet()) {
			keyMappings.push_back(Mapping4);
		}
		return keyMappings;
	}
};
struct ControllerConfig
{
	KeyMappingSet Keys;
	ControllerType Type = ControllerType::None;
};
enum class InputDisplayPosition
{
	TopLeft = 0,
	TopRight = 1,
	BottomLeft = 2,
	BottomRight = 3
};
struct InputConfig
{
	uint32_t ControllerDeadzoneSize = 2;
	uint32_t MouseSensitivity = 1;
	InputDisplayPosition DisplayInputPosition = InputDisplayPosition::TopLeft;
	bool DisplayInputPort[8] = { };
	bool DisplayInputHorizontally = true;
	double ForceFeedbackIntensity = 1.0;
};
enum class RamState
{
	Random = 0,
	AllZeros = 1,
	AllOnes = 2,
};
enum class ConsoleRegion
{
	Auto = 0,
	Ntsc = 1,
	Pal = 2,
	Dendy = 3,
	NtscJapan = 4
};
enum class ConsoleType
{
	Snes = 0,
	Gameboy = 1,
	Nes = 2,
	PcEngine = 3,
	Sms = 4,
	Gba = 5,
	Ws = 6
};
enum class GameboyModel
{
	AutoFavorGbc,
	AutoFavorSgb,
	AutoFavorGb,
	Gameboy,
	GameboyColor,
	SuperGameboy
};
struct EmulationConfig
{
	uint32_t EmulationSpeed = 100;
	uint32_t TurboSpeed = 300;
	uint32_t RewindSpeed = 100;
	uint32_t RunAheadFrames = 0;
};
struct OverscanDimensions
{
	uint32_t Left = 0;
	uint32_t Right = 0;
	uint32_t Top = 0;
	uint32_t Bottom = 0;
};
struct GameConfig
{
	uint32_t DipSwitches = 0;
	bool OverrideOverscan = false;
	OverscanDimensions Overscan = {};
};
struct GameboyConfig
{
	ControllerConfig Controller;
	GameboyModel Model = GameboyModel::AutoFavorGbc;
	bool UseSgb2 = true;
	bool BlendFrames = true;
	bool GbcAdjustColors = true;
	bool DisableBackground = false;
	bool DisableSprites = false;
	bool HideSgbBorders = false;
	RamState RamPowerOnState = RamState::Random;
	bool AllowInvalidInput = false;
	uint32_t BgColors[4] = { 0xFFFFFF, 0xB0B0B0, 0x686868, 0x000000 };
	uint32_t Obj0Colors[4] = { 0xFFFFFF, 0xB0B0B0, 0x686868, 0x000000 };
	uint32_t Obj1Colors[4] = { 0xFFFFFF, 0xB0B0B0, 0x686868, 0x000000 };
	uint32_t Square1Vol = 100;
	uint32_t Square2Vol = 100;
	uint32_t NoiseVol = 100;
	uint32_t WaveVol = 100;
};
enum class GbaSaveType
{
	AutoDetect,
	None,
	Sram,
	EepromUnknown,
	Eeprom512,
	Eeprom8192,
	Flash64,
	Flash128
};
enum class GbaRtcType
{
	AutoDetect = 0,
	Enabled = 1,
	Disabled = 2,
};
enum class GbaCartridgeType
{
	Default,
	TiltSensor
};
struct GbaConfig
{
	ControllerConfig Controller;
	bool SkipBootScreen = false;
	bool DisableFrameSkipping = false;
	bool BlendFrames = true;
	bool GbaAdjustColors = true;
	bool HideBgLayers[4] = {};
	bool DisableSprites = false;
	uint32_t OverclockScanlineCount = 0;
	RamState RamPowerOnState = RamState::AllZeros;
	GbaSaveType SaveType = GbaSaveType::AutoDetect;
	GbaRtcType RtcType = GbaRtcType::AutoDetect;
	bool AllowInvalidInput = false;
	bool EnableMgbaLogApi = false;
	uint32_t ChannelAVol = 100;
	uint32_t ChannelBVol = 100;
	uint32_t Square1Vol = 100;
	uint32_t Square2Vol = 100;
	uint32_t NoiseVol = 100;
	uint32_t WaveVol = 100;
};
enum class PceConsoleType
{
	Auto,
	PcEngine,
	SuperGrafx,
	TurboGrafx
};
enum class PceCdRomType
{
	CdRom,
	SuperCdRom,
	Arcade
};
struct PcEngineConfig
{
	ControllerConfig Port1;
	ControllerConfig Port1SubPorts[5];
	bool AllowInvalidInput = false;
	bool PreventSelectRunReset = false;
	PceConsoleType ConsoleType = PceConsoleType::Auto;
	PceCdRomType CdRomType = PceCdRomType::Arcade;
	bool EnableCdRomForHuCardGames = false;
	bool DisableCdRomSaveRamForHuCardGames = false;
	RamState RamPowerOnState = RamState::Random;
	bool EnableRandomPowerOnState = false;
	uint32_t ChannelVol[6] = { 100, 100, 100, 100, 100, 100 };
	uint32_t CdAudioVolume = 100;
	uint32_t AdpcmVolume = 100;
	bool UseHuC6280aAudio = true;
	bool RemoveSpriteLimit = false;
	bool DisableSprites = false;
	bool DisableSpritesVdc2 = false;
	bool DisableBackground = false;
	bool DisableBackgroundVdc2 = false;
	bool DisableFrameSkipping = false;
	bool ForceFixedResolution = false;
	OverscanDimensions Overscan = {};
	uint32_t Palette[512] = { };
};
enum class DspInterpolationType
{
	Gauss,
	Cubic,
	Sinc,
	None
};
struct SnesConfig
{
	ControllerConfig Port1;
	ControllerConfig Port2;
	ControllerConfig Port1SubPorts[4];
	ControllerConfig Port2SubPorts[4];
	ConsoleRegion Region = ConsoleRegion::Auto;
	bool AllowInvalidInput = false;
	bool BlendHighResolutionModes = false;
	bool HideBgLayer1 = false;
	bool HideBgLayer2 = false;
	bool HideBgLayer3 = false;
	bool HideBgLayer4 = false;
	bool HideSprites = false;
	bool DisableFrameSkipping = false;
	bool ForceFixedResolution = false;
	OverscanDimensions Overscan = {};
	DspInterpolationType InterpolationType = DspInterpolationType::Gauss;
	uint32_t ChannelVolumes[8] = { 100, 100, 100, 100, 100, 100, 100, 100 };
	bool EnableRandomPowerOnState = false;
	bool EnableStrictBoardMappings = false;
	RamState RamPowerOnState = RamState::Random;
	int32_t SpcClockSpeedAdjustment = 0;
	uint32_t PpuExtraScanlinesBeforeNmi = 0;
	uint32_t PpuExtraScanlinesAfterNmi = 0;
	uint32_t GsuClockSpeed = 100;
	int64_t BsxCustomDate = -1;
};
enum class StereoFilterType
{
	None = 0,
	Delay = 1,
	Panning = 2,
	CombFilter = 3,
};
enum class VsDualOutputOption
{
	Both = 0,
	MainSystemOnly = 1,
	SubSystemOnly = 2
};
enum class NesConsoleType
{
	Nes001,
	Nes101,
	Hvc001,
	Hvc101
};
struct NesConfig
{
	ControllerConfig Port1;
	ControllerConfig Port2;
	ControllerConfig ExpPort;
	ControllerConfig Port1SubPorts[4];
	ControllerConfig ExpPortSubPorts[4];
	ControllerConfig MapperInput;
	uint32_t LightDetectionRadius = 0;
	bool AutoConfigureInput = true;
	ConsoleRegion Region = ConsoleRegion::Auto;
	bool EnableHdPacks = true;
	bool DisableGameDatabase = false;
	bool FdsAutoLoadDisk = true;
	bool FdsFastForwardOnLoad = false;
	bool FdsAutoInsertDisk = false;
	VsDualOutputOption VsDualVideoOutput = VsDualOutputOption::Both;
	VsDualOutputOption VsDualAudioOutput = VsDualOutputOption::Both;
	bool SpritesEnabled = true;
	bool BackgroundEnabled = true;
	bool ForceBackgroundFirstColumn = false;
	bool ForceSpritesFirstColumn = false;
	bool RemoveSpriteLimit = false;
	bool AdaptiveSpriteLimit = false;
	bool EnablePalBorders = false;
	bool UseCustomVsPalette = false;
	OverscanDimensions NtscOverscan = {};
	OverscanDimensions PalOverscan = {};
	NesConsoleType ConsoleType = NesConsoleType::Nes001;
	bool DisablePpuReset = false;
	bool AllowInvalidInput = false;
	bool DisableGameGenieBusConflicts = false;
	bool DisableFlashSaves = false;
	bool OverwriteOriginalRom = false;
	bool EnableOamDecay = false;
	bool EnablePpuOamRowCorruption = false;
	bool EnablePpuSpriteEvalBug = false;
	bool DisableOamAddrBug = false;
	bool DisablePaletteRead = false;
	bool DisablePpu2004Reads = false;
	bool EnablePpu2000ScrollGlitch = false;
	bool EnablePpu2006ScrollGlitch = false;
	bool RestrictPpuAccessOnFirstFrame = false;
	bool EnableDmcSampleDuplicationGlitch = false;
	bool EnableCpuTestMode = false;
	bool RandomizeMapperPowerOnState = false;
	bool RandomizeCpuPpuAlignment = false;
	RamState RamPowerOnState = RamState::Random;
	uint32_t PpuExtraScanlinesBeforeNmi = 0;
	uint32_t PpuExtraScanlinesAfterNmi = 0;
	bool DisableNoiseModeFlag = false;
	bool ReduceDmcPopping = false;
	bool SilenceTriangleHighFreq = false;
	bool SwapDutyCycles = false;
	bool ReverseDpcmBitOrder = false;
	bool BreakOnCrash = false;
	int32_t InputScanline = 241;
	bool IsFullColorPalette = false;
	uint32_t UserPalette[512] = { };
	uint32_t ChannelVolumes[11] = {};
	uint32_t EpsmVolume = 100;
	uint32_t ChannelPanning[11] = {};
	StereoFilterType StereoFilter = StereoFilterType::None;
	int32_t StereoDelay = 0;
	int32_t StereoPanningAngle = 0;
	int32_t StereoCombFilterDelay = 0;
	int32_t StereoCombFilterStrength = 0;
};
enum class SmsRevision
{
	Compatibility,
	Sms1,
	Sms2
};
struct SmsConfig
{
	ControllerConfig Port1;
	ControllerConfig Port2;
	ConsoleRegion Region = ConsoleRegion::Auto;
	ConsoleRegion GameGearRegion = ConsoleRegion::Auto;
	RamState RamPowerOnState = RamState::Random;
	SmsRevision Revision = SmsRevision::Compatibility;
	bool AllowInvalidInput = false;
	bool UseSgPalette = false;
	bool GgBlendFrames = true;
	bool RemoveSpriteLimit = false;
	bool DisableSprites = false;
	bool DisableBackground = false;
	uint32_t ChannelVolumes[4] = {};
	uint32_t FmAudioVolume = 100;
	bool EnableFmAudio = true;
	OverscanDimensions NtscOverscan = {};
	OverscanDimensions PalOverscan = {};
	OverscanDimensions GameGearOverscan = {};
};
struct CvConfig
{
	ControllerConfig Port1;
	ControllerConfig Port2;
	ConsoleRegion Region = ConsoleRegion::Auto;
	RamState RamPowerOnState = RamState::Random;
	bool RemoveSpriteLimit = false;
	bool DisableSprites = false;
	bool DisableBackground = false;
	uint32_t ChannelVolumes[4] = {};
};
enum class WsModel : uint8_t
{
	Auto,
	Monochrome,
	Color,
	SwanCrystal
};
enum class WsAudioMode : uint8_t
{
	Headphones,
	Speakers
};
struct WsConfig
{
	ControllerConfig ControllerHorizontal;
	ControllerConfig ControllerVertical;
	WsModel Model = WsModel::Auto;
	bool UseBootRom = false;
	bool AutoRotate = false;
	bool BlendFrames = false;
	bool LcdAdjustColors = false;
	bool LcdShowIcons = false;
	bool HideBgLayers[2] = {};
	bool DisableSprites = false;
	WsAudioMode AudioMode = WsAudioMode::Headphones;
	uint32_t Channel1Vol = 100;
	uint32_t Channel2Vol = 100;
	uint32_t Channel3Vol = 100;
	uint32_t Channel4Vol = 100;
	uint32_t Channel5Vol = 100;
};
struct AudioPlayerConfig
{
	uint32_t Volume = 100;
	bool Repeat = false;
	bool Shuffle = false;
};
enum class GbaDisassemblyMode : uint8_t
{
	Default,
	Arm,
	Thumb
};
struct DebugConfig
{
	bool BreakOnUninitRead = false;
	bool ShowJumpLabels = false;
	bool DrawPartialFrame = false;
	bool ShowVerifiedData = false;
	bool DisassembleVerifiedData = false;
	bool ShowUnidentifiedData = false;
	bool DisassembleUnidentifiedData = false;
	bool UseLowerCaseDisassembly = false;
	bool ShowMemoryValues = false;
	bool AutoResetCdl = false;
	bool UsePredictiveBreakpoints = false;
	bool SingleBreakpointPerInstruction = false;
	bool SnesBreakOnBrk = false;
	bool SnesBreakOnCop = false;
	bool SnesBreakOnWdm = false;
	bool SnesBreakOnStp = false;
	bool SnesBreakOnInvalidPpuAccess = false;
	bool SnesBreakOnReadDuringAutoJoy = false;
	bool SnesUseAltSpcOpNames = false;
	bool SnesIgnoreDspReadWrites = false;
	bool SpcBreakOnBrk = false;
	bool SpcBreakOnStpSleep = false;
	bool GbBreakOnInvalidOamAccess = false;
	bool GbBreakOnInvalidVramAccess = false;
	bool GbBreakOnDisableLcdOutsideVblank = false;
	bool GbBreakOnInvalidOpCode = false;
	bool GbBreakOnNopLoad = false;
	bool GbBreakOnOamCorruption = false;
	bool NesBreakOnBrk = false;
	bool NesBreakOnUnofficialOpCode = false;
	bool NesBreakOnUnstableOpCode = false;
	bool NesBreakOnCpuCrash = false;
	bool NesBreakOnBusConflict = false;
	bool NesBreakOnDecayedOamRead = false;
	bool NesBreakOnPpuScrollGlitch = false;
	bool NesBreakOnExtOutputMode = false;
	bool NesBreakOnInvalidVramAccess = false;
	bool NesBreakOnInvalidOamWrite = false;
	bool NesBreakOnDmaInputRead = false;
	bool PceBreakOnBrk = false;
	bool PceBreakOnUnofficialOpCode = false;
	bool PceBreakOnInvalidVramAddress = false;
	bool SmsBreakOnNopLoad = false;
	bool GbaBreakOnNopLoad = false;
	bool GbaBreakOnInvalidOpCode = false;
	bool GbaBreakOnUnalignedMemAccess = false;
	GbaDisassemblyMode GbaDisMode;
	bool WsBreakOnInvalidOpCode = false;
	bool ScriptAllowIoOsAccess = false;
	bool ScriptAllowNetworkAccess = false;
	uint32_t ScriptTimeout = 1;
};
enum class HudDisplaySize
{
	Fixed,
	Scaled,
};
struct PreferencesConfig
{
	bool ShowFps = false;
	bool ShowFrameCounter = false;
	bool ShowGameTimer = false;
	bool ShowLagCounter = false;
	bool ShowDebugInfo = false;
	bool DisableOsd = false;
	bool AllowBackgroundInput = false;
	bool PauseOnMovieEnd = false;
	bool ShowMovieIcons = false;
	bool ShowTurboRewindIcons = false;
	bool DisableGameSelectionScreen = false;
	HudDisplaySize HudSize = HudDisplaySize::Fixed;
	uint32_t AutoSaveStateDelay = 5;
	uint32_t RewindBufferSize = 300;
	const char* SaveFolderOverride = nullptr;
	const char* SaveStateFolderOverride = nullptr;
	const char* ScreenshotFolderOverride = nullptr;
};
struct FrameInfo
{
	uint32_t Width;
	uint32_t Height;
};
struct HudScaleFactors
{
	double X;
	double Y;
};
enum class EmulatorShortcut
{
	FastForward,
	Rewind,
	RewindTenSecs,
	RewindOneMin,
	SelectSaveSlot1,
	SelectSaveSlot2,
	SelectSaveSlot3,
	SelectSaveSlot4,
	SelectSaveSlot5,
	SelectSaveSlot6,
	SelectSaveSlot7,
	SelectSaveSlot8,
	SelectSaveSlot9,
	SelectSaveSlot10,
	MoveToNextStateSlot,
	MoveToPreviousStateSlot,
	SaveState,
	LoadState,
	ToggleCheats,
	ToggleFastForward,
	ToggleRewind,
	RunSingleFrame,
	TakeScreenshot,
	ToggleRecordVideo,
	ToggleRecordAudio,
	ToggleRecordMovie,
	IncreaseSpeed,
	DecreaseSpeed,
	MaxSpeed,
	Pause,
	Reset,
	PowerCycle,
	ReloadRom,
	PowerOff,
	Exit,
	ExecReset,
	ExecPowerCycle,
	ExecReloadRom,
	ExecPowerOff,
	SetScale1x,
	SetScale2x,
	SetScale3x,
	SetScale4x,
	SetScale5x,
	SetScale6x,
	SetScale7x,
	SetScale8x,
	SetScale9x,
	SetScale10x,
	ToggleFullscreen,
	ToggleFps,
	ToggleGameTimer,
	ToggleFrameCounter,
	ToggleLagCounter,
	ToggleOsd,
	ToggleAlwaysOnTop,
	ToggleDebugInfo,
	ToggleAudio,
	IncreaseVolume,
	DecreaseVolume,
	PreviousTrack,
	NextTrack,
	ToggleBgLayer1,
	ToggleBgLayer2,
	ToggleBgLayer3,
	ToggleBgLayer4,
	ToggleSprites1,
	ToggleSprites2,
	EnableAllLayers,
	ResetLagCounter,
	SaveStateSlot1,
	SaveStateSlot2,
	SaveStateSlot3,
	SaveStateSlot4,
	SaveStateSlot5,
	SaveStateSlot6,
	SaveStateSlot7,
	SaveStateSlot8,
	SaveStateSlot9,
	SaveStateSlot10,
	SaveStateToFile,
	SaveStateDialog,
	LoadStateSlot1,
	LoadStateSlot2,
	LoadStateSlot3,
	LoadStateSlot4,
	LoadStateSlot5,
	LoadStateSlot6,
	LoadStateSlot7,
	LoadStateSlot8,
	LoadStateSlot9,
	LoadStateSlot10,
	LoadStateSlotAuto,
	LoadStateFromFile,
	LoadStateDialog,
	LoadLastSession,
	OpenFile,
	InputBarcode,
	LoadTape,
	RecordTape,
	StopRecordTape,
	FdsSwitchDiskSide,
	FdsEjectDisk,
	FdsInsertDiskNumber,
	FdsInsertNextDisk,
	VsServiceButton,
	VsServiceButton2,
	VsInsertCoin1,
	VsInsertCoin2,
	VsInsertCoin3,
	VsInsertCoin4,
	StartRecordHdPack,
	StopRecordHdPack,
	ShortcutCount,
};
struct KeyCombination
{
	uint32_t Key1 = 0;
	uint32_t Key2 = 0;
	uint32_t Key3 = 0;
	vector<uint32_t> GetKeys()
	{
		vector<uint32_t> result;
		if(Key1) {
			result.push_back(Key1);
		}
		if(Key2) {
			result.push_back(Key2);
		}
		if(Key3) {
			result.push_back(Key3);
		}
		return result;
	}
	bool IsSubsetOf(KeyCombination keyCombination)
	{
		vector<uint32_t> myKeys = GetKeys();
		vector<uint32_t> otherKeys = keyCombination.GetKeys();
		if(otherKeys.size() > myKeys.size()) {
			for(size_t i = 0; i < myKeys.size(); i++) {
				if(std::find(otherKeys.begin(), otherKeys.end(), myKeys[i]) == otherKeys.end()) {
					return false;
				}
			}
			return true;
		}
		return false;
	}
};
struct ShortcutKeyInfo
{
	EmulatorShortcut Shortcut;
	KeyCombination Keys;
};
enum class DebuggerFlags
{
	SnesDebuggerEnabled = (1 << 0),
	SpcDebuggerEnabled = (1 << 1),
	Sa1DebuggerEnabled = (1 << 2),
	GsuDebuggerEnabled = (1 << 3),
	NecDspDebuggerEnabled = (1 << 4),
	Cx4DebuggerEnabled = (1 << 5),
	St018DebuggerEnabled = (1 << 6),
	GbDebuggerEnabled = (1 << 7),
	NesDebuggerEnabled = (1 << 8),
	PceDebuggerEnabled = (1 << 9),
	SmsDebuggerEnabled = (1 << 10),
	GbaDebuggerEnabled = (1 << 11),
	WsDebuggerEnabled = (1 << 12),
};
```

## File: Core/Core.vcxproj
```
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="PGO Optimize|x64">
      <Configuration>PGO Optimize</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="PGO Profile|x64">
      <Configuration>PGO Profile</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="GBA\GbaCpuMultiply.h" />
    <ClInclude Include="GBA\GbaWaitStates.h" />
    <ClInclude Include="NES\Epsm.h" />
    <ClInclude Include="NES\Mappers\Homebrew\Rainbow.h" />
    <ClInclude Include="NES\Mappers\Homebrew\RainbowAudio.h" />
    <ClInclude Include="NES\Debugger\IExtModeMapperDebug.h" />
    <ClInclude Include="NES\Mappers\Homebrew\FlashS29.h" />
    <ClInclude Include="NES\Mappers\Nintendo\CnromProtect.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Mapper487.h" />
    <ClInclude Include="NES\OpnInterface.h" />
    <ClInclude Include="SMS\Input\ColecoVisionController.h" />
    <ClInclude Include="Debugger\AddressInfo.h" />
    <ClInclude Include="Debugger\Base6502Assembler.h" />
    <ClInclude Include="Debugger\CdlManager.h" />
    <ClInclude Include="Debugger\DisassemblySearch.h" />
    <ClInclude Include="Debugger\FrozenAddressManager.h" />
    <ClInclude Include="Debugger\StepBackManager.h" />
    <ClInclude Include="Gameboy\APU\GbChannelDac.h" />
    <ClInclude Include="Gameboy\APU\GbEnvelope.h" />
    <ClInclude Include="Gameboy\Carts\Eeprom93Lc56.h" />
    <ClInclude Include="Gameboy\Carts\GbHuc1.h" />
    <ClInclude Include="Gameboy\Carts\GbM161.h" />
    <ClInclude Include="Gameboy\Carts\GbMbc3Rtc.h" />
    <ClInclude Include="Gameboy\Carts\GbMbc6.h" />
    <ClInclude Include="Gameboy\Carts\GbMbc7.h" />
    <ClInclude Include="Gameboy\Carts\GbMbc7Accelerometer.h" />
    <ClInclude Include="Gameboy\Carts\GbMmm01.h" />
    <ClInclude Include="Gameboy\Carts\GbWisdomTree.h" />
    <ClInclude Include="Gameboy\GbxFooter.h" />
    <ClInclude Include="GBA\Cart\GbaGpio.h" />
    <ClInclude Include="GBA\Cart\GbaRtc.h" />
    <ClInclude Include="GBA\Cart\GbaTiltSensor.h" />
    <ClInclude Include="GBA\APU\GbaApu.h" />
    <ClInclude Include="GBA\APU\GbaApuFifo.h" />
    <ClInclude Include="GBA\APU\GbaEnvelope.h" />
    <ClInclude Include="GBA\APU\GbaNoiseChannel.h" />
    <ClInclude Include="GBA\APU\GbaSquareChannel.h" />
    <ClInclude Include="GBA\APU\GbaWaveChannel.h" />
    <ClInclude Include="GBA\Cart\GbaEeprom.h" />
    <ClInclude Include="GBA\Cart\GbaFlash.h" />
    <ClInclude Include="GBA\Debugger\DummyGbaCpu.h" />
    <ClInclude Include="GBA\Debugger\GbaAssembler.h" />
    <ClInclude Include="GBA\Debugger\GbaCodeDataLogger.h" />
    <ClInclude Include="GBA\Debugger\GbaDebugger.h" />
    <ClInclude Include="GBA\Debugger\GbaDisUtils.h" />
    <ClInclude Include="GBA\Debugger\GbaEventManager.h" />
    <ClInclude Include="GBA\Debugger\GbaPpuTools.h" />
    <ClInclude Include="GBA\Debugger\GbaTraceLogger.h" />
    <ClInclude Include="GBA\Cart\GbaCart.h" />
    <ClInclude Include="GBA\GbaConsole.h" />
    <ClInclude Include="GBA\GbaControlManager.h" />
    <ClInclude Include="GBA\GbaCpu.h" />
    <ClInclude Include="GBA\GbaDefaultVideoFilter.h" />
    <ClInclude Include="GBA\GbaDmaController.h" />
    <ClInclude Include="GBA\GbaPpu.h" />
    <ClInclude Include="GBA\GbaMemoryManager.h" />
    <ClInclude Include="GBA\GbaRomPrefetch.h" />
    <ClInclude Include="GBA\GbaSerial.h" />
    <ClInclude Include="GBA\GbaTimer.h" />
    <ClInclude Include="GBA\GbaTypes.h" />
    <ClInclude Include="GBA\Input\GbaController.h" />
    <ClInclude Include="GBA\Debugger\MgbaLogHandler.h" />
    <ClInclude Include="NES\HdPacks\HdBuilderPpu.h" />
    <ClInclude Include="NES\HdPacks\HdPackBuilder.h" />
    <ClInclude Include="PCE\CdRom\PceCdSeekDelay.h" />
    <ClInclude Include="Shared\ColorUtilities.h" />
    <ClInclude Include="Shared\Utilities\emu2413.h" />
    <ClInclude Include="NES\Mappers\Nintendo\FnsMmc1.h" />
    <ClInclude Include="Shared\SaveStateCompatInfo.h" />
    <ClInclude Include="Shared\Utilities\Emu2413Serializer.h" />
    <ClInclude Include="Shared\Video\GenericNtscFilter.h" />
    <ClInclude Include="Shared\Video\SoftwareRenderer.h" />
    <ClInclude Include="SMS\Carts\SmsCodemasterCart.h" />
    <ClInclude Include="SMS\Carts\SmsNemesisCart.h" />
    <ClInclude Include="SMS\Carts\SmsKoreanCart.h" />
    <ClInclude Include="SMS\Carts\SmsMsxCart.h" />
    <ClInclude Include="SMS\Carts\SmsSegaCart.h" />
    <ClInclude Include="SMS\Carts\SmsCart.h" />
    <ClInclude Include="SMS\Debugger\DummySmsCpu.h" />
    <ClInclude Include="SMS\Debugger\SmsAssembler.h" />
    <ClInclude Include="SMS\Debugger\SmsDebugger.h" />
    <ClInclude Include="SMS\Debugger\SmsDisUtils.h" />
    <ClInclude Include="SMS\Debugger\SmsEventManager.h" />
    <ClInclude Include="SMS\Debugger\SmsTraceLogger.h" />
    <ClInclude Include="SMS\Debugger\SmsVdpTools.h" />
    <ClInclude Include="SMS\Input\SmsController.h" />
    <ClInclude Include="SMS\Input\SmsLightPhaser.h" />
    <ClInclude Include="SMS\SmsBiosMapper.h" />
    <ClInclude Include="SMS\SmsConsole.h" />
    <ClInclude Include="SMS\SmsControlManager.h" />
    <ClInclude Include="SMS\SmsCpu.h" />
    <ClInclude Include="SMS\SmsDefaultVideoFilter.h" />
    <ClInclude Include="SMS\SmsFmAudio.h" />
    <ClInclude Include="SMS\SmsMemoryManager.h" />
    <ClInclude Include="SMS\SmsNtscFilter.h" />
    <ClInclude Include="SMS\SmsPsg.h" />
    <ClInclude Include="SMS\SmsTypes.h" />
    <ClInclude Include="SMS\SmsVdp.h" />
    <ClInclude Include="Shared\ArmEnums.h" />
    <ClInclude Include="SNES\Coprocessors\ST018\ArmV3Cpu.h" />
    <ClInclude Include="SNES\Coprocessors\ST018\ArmV3Types.h" />
    <ClInclude Include="SNES\Coprocessors\ST018\St018.h" />
    <ClInclude Include="SNES\Coprocessors\ST018\St018Types.h" />
    <ClInclude Include="SNES\Coprocessors\SufamiTurbo\SufamiTurbo.h" />
    <ClInclude Include="SNES\Debugger\DummyArmV3Cpu.h" />
    <ClInclude Include="SNES\Debugger\St018Debugger.h" />
    <ClInclude Include="SNES\Debugger\St018DisUtils.h" />
    <ClInclude Include="SNES\Debugger\TraceLogger\St018TraceLogger.h" />
    <ClInclude Include="SNES\DSP\DspInterpolation.h" />
    <ClInclude Include="SNES\DSP\Dsp.h" />
    <ClInclude Include="NES\Debugger\NesCodeDataLogger.h" />
    <ClInclude Include="NES\Input\BandaiMicrophone.h" />
    <ClInclude Include="NES\Input\DatachBarcodeReader.h" />
    <ClInclude Include="NES\Loaders\StudyBoxLoader.h" />
    <ClInclude Include="NES\Loaders\UnifBoards.h" />
    <ClInclude Include="NES\Loaders\UnifLoader.h" />
    <ClInclude Include="NES\Mappers\Bandai\Bandai74161_7432.h" />
    <ClInclude Include="NES\Mappers\Bandai\BandaiFcg.h" />
    <ClInclude Include="NES\Mappers\Bandai\BandaiKaraoke.h" />
    <ClInclude Include="NES\Mappers\Bandai\BaseEeprom24C0X.h" />
    <ClInclude Include="NES\Mappers\Bandai\Eeprom24C01.h" />
    <ClInclude Include="NES\Mappers\Bandai\Eeprom24C02.h" />
    <ClInclude Include="NES\Mappers\Codemasters\BF9096.h" />
    <ClInclude Include="NES\Mappers\Codemasters\BF909x.h" />
    <ClInclude Include="NES\Mappers\Codemasters\GoldenFive.h" />
    <ClInclude Include="NES\Mappers\Homebrew\Action53.h" />
    <ClInclude Include="NES\Mappers\Nintendo\CpRom.h" />
    <ClInclude Include="NES\Mappers\Homebrew\Cheapocabra.h" />
    <ClInclude Include="NES\Mappers\Homebrew\FaridSlrom.h" />
    <ClInclude Include="NES\Mappers\Homebrew\FaridUnrom.h" />
    <ClInclude Include="NES\Mappers\Homebrew\FlashSST39SF040.h" />
    <ClInclude Include="NES\Mappers\Homebrew\MagicFloor218.h" />
    <ClInclude Include="NES\Mappers\Homebrew\SealieComputing.h" />
    <ClInclude Include="NES\Mappers\Homebrew\UnRom512.h" />
    <ClInclude Include="NES\Mappers\Irem\BnRom.h" />
    <ClInclude Include="NES\Mappers\Irem\IremG101.h" />
    <ClInclude Include="NES\Mappers\Irem\IremH3001.h" />
    <ClInclude Include="NES\Mappers\Irem\IremLrog017.h" />
    <ClInclude Include="NES\Mappers\Irem\IremTamS1.h" />
    <ClInclude Include="NES\Mappers\Jaleco\JalecoJf11_14.h" />
    <ClInclude Include="NES\Mappers\Jaleco\JalecoJf13.h" />
    <ClInclude Include="NES\Mappers\Jaleco\JalecoJf16.h" />
    <ClInclude Include="NES\Mappers\Jaleco\JalecoJf17_19.h" />
    <ClInclude Include="NES\Mappers\Jaleco\JalecoJfxx.h" />
    <ClInclude Include="NES\Mappers\Jaleco\JalecoSs88006.h" />
    <ClInclude Include="NES\Mappers\JyCompany\JyCompany.h" />
    <ClInclude Include="NES\Mappers\JyCompany\Mapper35.h" />
    <ClInclude Include="NES\Mappers\JyCompany\Mapper91.h" />
    <ClInclude Include="NES\Mappers\Kaiser\Kaiser202.h" />
    <ClInclude Include="NES\Mappers\Kaiser\Kaiser7012.h" />
    <ClInclude Include="NES\Mappers\Kaiser\Kaiser7013B.h" />
    <ClInclude Include="NES\Mappers\Kaiser\Kaiser7016.h" />
    <ClInclude Include="NES\Mappers\Kaiser\Kaiser7017.h" />
    <ClInclude Include="NES\Mappers\Kaiser\Kaiser7022.h" />
    <ClInclude Include="NES\Mappers\Kaiser\Kaiser7031.h" />
    <ClInclude Include="NES\Mappers\Kaiser\Kaiser7037.h" />
    <ClInclude Include="NES\Mappers\Kaiser\Kaiser7057.h" />
    <ClInclude Include="NES\Mappers\Kaiser\Kaiser7058.h" />
    <ClInclude Include="NES\Mappers\Mmc3Variants\McAcc.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\A65AS.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Ac08.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\ActionEnterprises.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Ax5705.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Bb.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Bmc12in1.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Bmc190in1.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Bmc235.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Bmc255.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Bmc51.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Bmc60311C.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Bmc64in1NoRepeat.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Bmc70in1.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Bmc80013B.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Bmc810544CA1.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Bmc8157.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Bmc830425C4391T.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\BmcG146.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\BmcK3046.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Cc21.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\CityFighter.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\ColorDreams.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\ColorDreams46.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Dance2000.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\DaouInfosys.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\DreamTech01.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Edu2000.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Eh8813A.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\FrontFareast.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Ghostbusters63in1.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Gkcx1.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Gs2004.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Gs2013.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Henggedianzi177.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Henggedianzi179.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Hp898f.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\MagicKidGooGoo.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Malee.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Mapper103.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Mapper106.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Mapper107.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Mapper116.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Mapper117.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Mapper120.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Mapper15.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Mapper170.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Mapper183.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Mapper200.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Mapper202.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Mapper203.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Mapper204.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Mapper212.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Mapper213.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Mapper214.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Mapper216.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Mapper222.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Mapper225.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Mapper226.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Mapper227.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Mapper229.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Mapper230.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Mapper231.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Mapper233.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Mapper234.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Mapper240.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Mapper241.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Mapper244.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Mapper246.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Mapper39.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Mapper42.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Mapper43.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Mapper50.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Mapper57.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Mapper58.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Mapper60.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Mapper62.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Mapper83.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Nanjing.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Nina01.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Nina03_06.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\NovelDiamond.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Racermate.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Rt01.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Subor166.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Super40in1Ws.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Supervision.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\T230.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\T262.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Unl255in1.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\UnlD1038.h" />
    <ClInclude Include="NES\Mappers\Homebrew\UnlDripGame.h" />
    <ClInclude Include="NES\Mappers\Homebrew\UnlDripGameAudio.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\UnlPci556.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\UnlPuzzle.h" />
    <ClInclude Include="NES\Mappers\Unlicensed\Yoko.h" />
    <ClInclude Include="NES\Mappers\Mmc3Variants\Bmc830118C.h" />
    <ClInclude Include="NES\Mappers\Mmc3Variants\Bmc8in1.h" />
    <ClInclude Include="NES\Mappers\Mmc3Variants\BmcGn45.h" />
    <ClInclude Include="NES\Mappers\Mmc3Variants\BmcHpxx.h" />
    <ClInclude Include="NES\Mappers\Mmc3Variants\DragonFighter.h" />
    <ClInclude Include="NES\Mappers\Mmc3Variants\MMC3_114.h" />
    <ClInclude Include="NES\Mappers\Mmc3Variants\MMC3_115.h" />
    <ClInclude Include="NES\Mappers\Mmc3Variants\MMC3_12.h" />
    <ClInclude Include="NES\Mappers\Mmc3Variants\MMC3_121.h" />
    <ClInclude Include="NES\Mappers\Mmc3Variants\MMC3_123.h" />
    <ClInclude Include="NES\Mappers\Mmc3Variants\MMC3_126.h" />
    <ClInclude Include="NES\Mappers\Mmc3Variants\MMC3_134.h" />
    <ClInclude Include="NES\Mappers\Mmc3Variants\MMC3_14.h" />
    <ClInclude Include="NES\Mappers\Mmc3Variants\MMC3_165.h" />
    <ClInclude Include="NES\Mappers\Mmc3Variants\MMC3_182.h" />
    <ClInclude Include="NES\Mappers\Mmc3Variants\MMC3_187.h" />
    <ClInclude Include="NES\Mappers\Mmc3Variants\MMC3_196.h" />
    <ClInclude Include="NES\Mappers\Mmc3Variants\MMC3_197.h" />
    <ClInclude Include="NES\Mappers\Mmc3Variants\MMC3_198.h" />
    <ClInclude Include="NES\Mappers\Mmc3Variants\MMC3_199.h" />
    <ClInclude Include="NES\Mappers\Mmc3Variants\MMC3_205.h" />
    <ClInclude Include="NES\Mappers\Mmc3Variants\MMC3_208.h" />
    <ClInclude Include="NES\Mappers\Mmc3Variants\MMC3_215.h" />
    <ClInclude Include="NES\Mappers\Mmc3Variants\MMC3_217.h" />
    <ClInclude Include="NES\Mappers\Mmc3Variants\MMC3_219.h" />
    <ClInclude Include="NES\Mappers\Mmc3Variants\MMC3_224.h" />
    <ClInclude Include="NES\Mappers\Mmc3Variants\MMC3_238.h" />
    <ClInclude Include="NES\Mappers\Mmc3Variants\MMC3_245.h" />
    <ClInclude Include="NES\Mappers\Mmc3Variants\MMC3_249.h" />
    <ClInclude Include="NES\Mappers\Mmc3Variants\MMC3_250.h" />
    <ClInclude Include="NES\Mappers\Mmc3Variants\MMC3_254.h" />
    <ClInclude Include="NES\Mappers\Mmc3Variants\MMC3_37.h" />
    <ClInclude Include="NES\Mappers\Mmc3Variants\MMC3_44.h" />
    <ClInclude Include="NES\Mappers\Mmc3Variants\MMC3_45.h" />
    <ClInclude Include="NES\Mappers\Mmc3Variants\MMC3_47.h" />
    <ClInclude Include="NES\Mappers\Mmc3Variants\MMC3_49.h" />
    <ClInclude Include="NES\Mappers\Mmc3Variants\MMC3_52.h" />
    <ClInclude Include="NES\Mappers\Mmc3Variants\MMC3_Bmc411120C.h" />
    <ClInclude Include="NES\Mappers\Mmc3Variants\MMC3_BmcF15.h" />
    <ClInclude Include="NES\Mappers\Mmc3Variants\MMC3_ChrRam.h" />
    <ClInclude Include="NES\Mappers\Mmc3Variants\MMC3_Coolboy.h" />
    <ClInclude Include="NES\Mappers\Mmc3Variants\MMC3_Kof97.h" />
    <ClInclude Include="NES\Mappers\Mmc3Variants\MMC3_MaliSB.h" />
    <ClInclude Include="NES\Mappers\Mmc3Variants\MMC3_StreetHeroes.h" />
    <ClInclude Include="NES\Mappers\Mmc3Variants\ResetTxrom.h" />
    <ClInclude Include="NES\Mappers\Mmc3Variants\Sachen9602.h" />
    <ClInclude Include="NES\Mappers\Mmc3Variants\Unl158B.h" />
    <ClInclude Include="NES\Mappers\Mmc3Variants\Unl8237A.h" />
    <ClInclude Include="NES\Mappers\Homebrew\NsfCart31.h" />
    <ClInclude Include="NES\Mappers\Namco\Namco108.h" />
    <ClInclude Include="NES\Mappers\Namco\Namco108_154.h" />
    <ClInclude Include="NES\Mappers\Namco\Namco108_76.h" />
    <ClInclude Include="NES\Mappers\Namco\Namco108_88.h" />
    <ClInclude Include="NES\Mappers\Namco\Namco108_95.h" />
    <ClInclude Include="NES\Mappers\Namco\Namco163.h" />
    <ClInclude Include="NES\Mappers\Nintendo\CNROM.h" />
    <ClInclude Include="NES\Mappers\Nintendo\FamicomBox.h" />
    <ClInclude Include="NES\Mappers\Nintendo\GxRom.h" />
    <ClInclude Include="NES\Mappers\Nintendo\MMC1.h" />
    <ClInclude Include="NES\Mappers\Nintendo\MMC1_105.h" />
    <ClInclude Include="NES\Mappers\Nintendo\MMC1_155.h" />
    <ClInclude Include="NES\Mappers\Nintendo\MMC2.h" />
    <ClInclude Include="NES\Mappers\Nintendo\MMC3.h" />
    <ClInclude Include="NES\Mappers\Nintendo\MMC3_37.h" />
    <ClInclude Include="NES\Mappers\Nintendo\MMC3_47.h" />
    <ClInclude Include="NES\Mappers\Nintendo\MMC4.h" />
    <ClInclude Include="NES\Mappers\Nintendo\MMC5.h" />
    <ClInclude Include="NES\Mappers\Nintendo\Mmc5MemoryHandler.h" />
    <ClInclude Include="NES\Mappers\Nintendo\NROM.h" />
    <ClInclude Include="NES\Mappers\Nintendo\TxSRom.h" />
    <ClInclude Include="NES\Mappers\Nintendo\UNROM.h" />
    <ClInclude Include="NES\Mappers\Nintendo\UnRom_180.h" />
    <ClInclude Include="NES\Mappers\Nintendo\UnRom_94.h" />
    <ClInclude Include="NES\Mappers\Ntdec\Bmc63.h" />
    <ClInclude Include="NES\Mappers\Ntdec\BmcNtd03.h" />
    <ClInclude Include="NES\Mappers\Ntdec\Caltron41.h" />
    <ClInclude Include="NES\Mappers\Ntdec\Mapper112.h" />
    <ClInclude Include="NES\Mappers\Ntdec\Mapper174.h" />
    <ClInclude Include="NES\Mappers\Ntdec\Mapper221.h" />
    <ClInclude Include="NES\Mappers\Ntdec\NtdecTc112.h" />
    <ClInclude Include="NES\Mappers\Ntdec\Tf1201.h" />
    <ClInclude Include="NES\Mappers\Sachen\Sachen74LS374N.h" />
    <ClInclude Include="NES\Mappers\Sachen\Sachen8259.h" />
    <ClInclude Include="NES\Mappers\Sachen\Sachen9602.h" />
    <ClInclude Include="NES\Mappers\Sachen\Sachen_133.h" />
    <ClInclude Include="NES\Mappers\Sachen\Sachen_136.h" />
    <ClInclude Include="NES\Mappers\Sachen\Sachen_143.h" />
    <ClInclude Include="NES\Mappers\Sachen\Sachen_145.h" />
    <ClInclude Include="NES\Mappers\Sachen\Sachen_147.h" />
    <ClInclude Include="NES\Mappers\Sachen\Sachen_148.h" />
    <ClInclude Include="NES\Mappers\Sachen\Sachen_149.h" />
    <ClInclude Include="NES\Mappers\StudyBox.h" />
    <ClInclude Include="NES\Mappers\Sunsoft\Sunsoft184.h" />
    <ClInclude Include="NES\Mappers\Sunsoft\Sunsoft3.h" />
    <ClInclude Include="NES\Mappers\Sunsoft\Sunsoft4.h" />
    <ClInclude Include="NES\Mappers\Sunsoft\Sunsoft89.h" />
    <ClInclude Include="NES\Mappers\Sunsoft\Sunsoft93.h" />
    <ClInclude Include="NES\Mappers\Sunsoft\SunsoftFme7.h" />
    <ClInclude Include="NES\Mappers\Taito\TaitoTc0190.h" />
    <ClInclude Include="NES\Mappers\Taito\TaitoTc0690.h" />
    <ClInclude Include="NES\Mappers\Taito\TaitoX1005.h" />
    <ClInclude Include="NES\Mappers\Taito\TaitoX1017.h" />
    <ClInclude Include="NES\Mappers\Tengen\Rambo1.h" />
    <ClInclude Include="NES\Mappers\Tengen\Rambo1_158.h" />
    <ClInclude Include="NES\Mappers\Txc\Bmc11160.h" />
    <ClInclude Include="NES\Mappers\Txc\Mapper61.h" />
    <ClInclude Include="NES\Mappers\Txc\MMC3_189.h" />
    <ClInclude Include="NES\Mappers\Txc\Txc22000.h" />
    <ClInclude Include="NES\Mappers\Txc\Txc22211A.h" />
    <ClInclude Include="NES\Mappers\Txc\Txc22211B.h" />
    <ClInclude Include="NES\Mappers\Txc\Txc22211C.h" />
    <ClInclude Include="NES\Mappers\Txc\TxcChip.h" />
    <ClInclude Include="NES\Mappers\Konami\VRC1.h" />
    <ClInclude Include="NES\Mappers\Konami\VRC2_4.h" />
    <ClInclude Include="NES\Mappers\Konami\VRC3.h" />
    <ClInclude Include="NES\Mappers\Konami\VRC6.h" />
    <ClInclude Include="NES\Mappers\Konami\VRC7.h" />
    <ClInclude Include="NES\Mappers\Konami\VrcIrq.h" />
    <ClInclude Include="NES\Mappers\Waixing\Bs5.h" />
    <ClInclude Include="NES\Mappers\Waixing\Fk23C.h" />
    <ClInclude Include="NES\Mappers\Waixing\Mapper242.h" />
    <ClInclude Include="NES\Mappers\Waixing\Mapper253.h" />
    <ClInclude Include="NES\Mappers\Waixing\Waixing162.h" />
    <ClInclude Include="NES\Mappers\Waixing\Waixing164.h" />
    <ClInclude Include="NES\Mappers\Waixing\Waixing178.h" />
    <ClInclude Include="NES\Mappers\Waixing\Waixing252.h" />
    <ClInclude Include="NES\Mappers\Whirlwind\Lh10.h" />
    <ClInclude Include="NES\Mappers\Whirlwind\Lh32.h" />
    <ClInclude Include="NES\Mappers\Whirlwind\Lh51.h" />
    <ClInclude Include="NES\Mappers\Whirlwind\Mapper40.h" />
    <ClInclude Include="NES\Mappers\Whirlwind\Smb2j.h" />
    <ClInclude Include="Netplay\NetplayTypes.h" />
    <ClInclude Include="PCE\Debugger\PceAssembler.h" />
    <ClInclude Include="PCE\HesFileData.h" />
    <ClInclude Include="PCE\IPceMapper.h" />
    <ClInclude Include="PCE\CdRom\PceArcadeCard.h" />
    <ClInclude Include="PCE\CdRom\PceAudioFader.h" />
    <ClInclude Include="PCE\PceVpc.h" />
    <ClInclude Include="PCE\Input\PceAvenuePad6.h" />
    <ClInclude Include="PCE\Input\PceTurboTap.h" />
    <ClInclude Include="PCE\Debugger\DummyPceCpu.h" />
    <ClInclude Include="PCE\Debugger\PceEventManager.h" />
    <ClInclude Include="PCE\Input\PceController.h" />
    <ClInclude Include="PCE\CdRom\PceAdpcm.h" />
    <ClInclude Include="PCE\CdRom\PceCdAudioPlayer.h" />
    <ClInclude Include="PCE\CdRom\PceCdRom.h" />
    <ClInclude Include="PCE\PceConstants.h" />
    <ClInclude Include="PCE\PceNtscFilter.h" />
    <ClInclude Include="PCE\PceVdc.h" />
    <ClInclude Include="PCE\Debugger\PceDebugger.h" />
    <ClInclude Include="PCE\Debugger\PceDisUtils.h" />
    <ClInclude Include="PCE\Debugger\PceVdcTools.h" />
    <ClInclude Include="PCE\Debugger\PceTraceLogger.h" />
    <ClInclude Include="PCE\PceConsole.h" />
    <ClInclude Include="PCE\PceControlManager.h" />
    <ClInclude Include="PCE\PceCpu.h" />
    <ClInclude Include="PCE\PceDefaultVideoFilter.h" />
    <ClInclude Include="PCE\PceMemoryManager.h" />
    <ClInclude Include="PCE\PcePsg.h" />
    <ClInclude Include="PCE\PcePsgChannel.h" />
    <ClInclude Include="PCE\CdRom\PceScsiBus.h" />
    <ClInclude Include="PCE\PceSf2RomMapper.h" />
    <ClInclude Include="PCE\PceTimer.h" />
    <ClInclude Include="PCE\PceTypes.h" />
    <ClInclude Include="PCE\PceVce.h" />
    <ClInclude Include="Shared\CdReader.h" />
    <ClInclude Include="Shared\CpuType.h" />
    <ClInclude Include="Debugger\BaseTraceLogger.h" />
    <ClInclude Include="Debugger\DebuggerFeatures.h" />
    <ClInclude Include="Debugger\ITraceLogger.h" />
    <ClInclude Include="Debugger\TraceLogFileSaver.h" />
    <ClInclude Include="Gameboy\Carts\GbsCart.h" />
    <ClInclude Include="Gameboy\Debugger\DummyGbCpu.h" />
    <ClInclude Include="Gameboy\Debugger\GbTraceLogger.h" />
    <ClInclude Include="Gameboy\Debugger\GbPpuTools.h" />
    <ClInclude Include="Gameboy\GbConstants.h" />
    <ClInclude Include="Gameboy\GbDefaultVideoFilter.h" />
    <ClInclude Include="Gameboy\GbsHeader.h" />
    <ClInclude Include="Gameboy\Input\GbController.h" />
    <ClInclude Include="NES\BaseNesPpu.h" />
    <ClInclude Include="NES\BisqwitNtscFilter.h" />
    <ClInclude Include="NES\Debugger\DummyNesCpu.h" />
    <ClInclude Include="NES\Debugger\NesPpuTools.h" />
    <ClInclude Include="NES\Debugger\NesAssembler.h" />
    <ClInclude Include="NES\Debugger\NesEventManager.h" />
    <ClInclude Include="NES\Debugger\NesTraceLogger.h" />
    <ClInclude Include="NES\DefaultNesPpu.h" />
    <ClInclude Include="NES\HdPacks\HdAudioDevice.h" />
    <ClInclude Include="NES\HdPacks\HdData.h" />
    <ClInclude Include="NES\HdPacks\HdNesPack.h" />
    <ClInclude Include="NES\HdPacks\HdNesPpu.h" />
    <ClInclude Include="NES\HdPacks\HdPackConditions.h" />
    <ClInclude Include="NES\HdPacks\HdPackLoader.h" />
    <ClInclude Include="NES\HdPacks\HdVideoFilter.h" />
    <ClInclude Include="NES\HdPacks\OggMixer.h" />
    <ClInclude Include="NES\HdPacks\OggReader.h" />
    <ClInclude Include="NES\Input\ArkanoidController.h" />
    <ClInclude Include="NES\Input\AsciiTurboFile.h" />
    <ClInclude Include="NES\Input\BandaiHyperShot.h" />
    <ClInclude Include="NES\Input\BarcodeBattlerReader.h" />
    <ClInclude Include="NES\Input\BattleBox.h" />
    <ClInclude Include="NES\Input\ExcitingBoxingController.h" />
    <ClInclude Include="NES\Input\FamilyBasicDataRecorder.h" />
    <ClInclude Include="NES\Input\FamilyBasicKeyboard.h" />
    <ClInclude Include="NES\Input\FamilyMatTrainer.h" />
    <ClInclude Include="NES\Input\FourScore.h" />
    <ClInclude Include="NES\Input\HoriTrack.h" />
    <ClInclude Include="Shared\DebuggerRequest.h" />
    <ClInclude Include="Shared\HistoryViewer.h" />
    <ClInclude Include="Shared\IControllerHub.h" />
    <ClInclude Include="Shared\Interfaces\IBarcodeReader.h" />
    <ClInclude Include="NES\Input\JissenMahjongController.h" />
    <ClInclude Include="NES\Input\KonamiHyperShot.h" />
    <ClInclude Include="NES\Input\OekaKidsTablet.h" />
    <ClInclude Include="NES\Input\PachinkoController.h" />
    <ClInclude Include="NES\Input\PartyTap.h" />
    <ClInclude Include="NES\Input\PowerPad.h" />
    <ClInclude Include="NES\Input\SuborKeyboard.h" />
    <ClInclude Include="NES\Input\SuborMouse.h" />
    <ClInclude Include="NES\Input\TwoPlayerAdapter.h" />
    <ClInclude Include="NES\Input\VirtualBoyController.h" />
    <ClInclude Include="NES\Input\VsZapper.h" />
    <ClInclude Include="NES\Input\Zapper.h" />
    <ClInclude Include="NES\Loaders\BaseLoader.h" />
    <ClInclude Include="NES\Loaders\FdsLoader.h" />
    <ClInclude Include="NES\Loaders\iNesLoader.h" />
    <ClInclude Include="NES\Loaders\NsfeLoader.h" />
    <ClInclude Include="NES\Loaders\NsfLoader.h" />
    <ClInclude Include="NES\Loaders\RomLoader.h" />
    <ClInclude Include="NES\APU\BaseExpansionAudio.h" />
    <ClInclude Include="NES\Mappers\A12Watcher.h" />
    <ClInclude Include="NES\Mappers\Audio\Mmc5Audio.h" />
    <ClInclude Include="NES\Mappers\Audio\Namco163Audio.h" />
    <ClInclude Include="NES\Mappers\Audio\Sunsoft5bAudio.h" />
    <ClInclude Include="NES\Mappers\Audio\Vrc6Audio.h" />
    <ClInclude Include="NES\Mappers\Audio\Vrc6Pulse.h" />
    <ClInclude Include="NES\Mappers\Audio\Vrc6Saw.h" />
    <ClInclude Include="NES\Mappers\Audio\Vrc7Audio.h" />
    <ClInclude Include="NES\Mappers\Nintendo\AXROM.h" />
    <ClInclude Include="NES\Mappers\FDS\BaseFdsChannel.h" />
    <ClInclude Include="NES\Mappers\FDS\Fds.h" />
    <ClInclude Include="NES\Mappers\FDS\FdsAudio.h" />
    <ClInclude Include="NES\Mappers\FDS\FdsInputButtons.h" />
    <ClInclude Include="NES\Mappers\FDS\ModChannel.h" />
    <ClInclude Include="NES\Mappers\NSF\NsfMapper.h" />
    <ClInclude Include="NES\Mappers\Bandai\OekaKids.h" />
    <ClInclude Include="NES\Mappers\VsSystem\VsControlManager.h" />
    <ClInclude Include="NES\Mappers\VsSystem\VsSystem.h" />
    <ClInclude Include="NES\Mappers\VsSystem\VsInputButtons.h" />
    <ClInclude Include="NES\NesConstants.h" />
    <ClInclude Include="NES\NesNtscFilter.h" />
    <ClInclude Include="NES\NsfPpu.h" />
    <ClInclude Include="Shared\Audio\AudioPlayerTypes.h" />
    <ClInclude Include="Shared\BaseControlManager.h" />
    <ClInclude Include="Shared\BaseState.h" />
    <ClInclude Include="Gameboy\GbControlManager.h" />
    <ClInclude Include="Shared\ControllerHub.h" />
    <ClInclude Include="Shared\Interfaces\IAudioProvider.h" />
    <ClInclude Include="Shared\Interfaces\IBattery.h" />
    <ClInclude Include="Shared\MemoryOperationType.h" />
    <ClInclude Include="Shared\Interfaces\ITapeRecorder.h" />
    <ClInclude Include="Shared\KeyDefinitions.h" />
    <ClInclude Include="Shared\RenderedFrame.h" />
    <ClInclude Include="Shared\RomInfo.h" />
    <ClInclude Include="NES\NesDefaultVideoFilter.h" />
    <ClInclude Include="NES\APU\ApuEnvelope.h" />
    <ClInclude Include="NES\APU\ApuFrameCounter.h" />
    <ClInclude Include="NES\APU\ApuLengthCounter.h" />
    <ClInclude Include="NES\APU\ApuTimer.h" />
    <ClInclude Include="NES\BaseMapper.h" />
    <ClInclude Include="NES\NesControlManager.h" />
    <ClInclude Include="NES\APU\DeltaModulationChannel.h" />
    <ClInclude Include="NES\GameDatabase.h" />
    <ClInclude Include="NES\INesMemoryHandler.h" />
    <ClInclude Include="NES\InternalRamHandler.h" />
    <ClInclude Include="NES\MapperFactory.h" />
    <ClInclude Include="NES\APU\NesApu.h" />
    <ClInclude Include="NES\NesConsole.h" />
    <ClInclude Include="NES\NesCpu.h" />
    <ClInclude Include="NES\Debugger\NesDisUtils.h" />
    <ClInclude Include="NES\Debugger\NesDebugger.h" />
    <ClInclude Include="NES\NesHeader.h" />
    <ClInclude Include="NES\NesMemoryManager.h" />
    <ClInclude Include="NES\NesPpu.h" />
    <ClInclude Include="NES\NesSoundMixer.h" />
    <ClInclude Include="NES\NesTypes.h" />
    <ClInclude Include="NES\APU\NoiseChannel.h" />
    <ClInclude Include="NES\OpenBusHandler.h" />
    <ClInclude Include="NES\RomData.h" />
    <ClInclude Include="NES\APU\SquareChannel.h" />
    <ClInclude Include="NES\Input\NesController.h" />
    <ClInclude Include="NES\APU\TriangleChannel.h" />
    <ClInclude Include="Shared\TimingInfo.h" />
    <ClInclude Include="Shared\Video\RotateFilter.h" />
    <ClInclude Include="Shared\Video\ScanlineFilter.h" />
    <ClInclude Include="Shared\Video\SystemHud.h" />
    <ClInclude Include="SNES\Debugger\SnesCodeDataLogger.h" />
    <ClInclude Include="SNES\AluMulDiv.h" />
    <ClInclude Include="SNES\Debugger\SnesPpuTools.h" />
    <ClInclude Include="SNES\Debugger\SnesAssembler.h" />
    <ClInclude Include="SNES\BaseCartridge.h" />
    <ClInclude Include="Shared\BaseControlDevice.h" />
    <ClInclude Include="SNES\Coprocessors\BaseCoprocessor.h" />
    <ClInclude Include="Debugger\BaseEventManager.h" />
    <ClInclude Include="Shared\BatteryManager.h" />
    <ClInclude Include="SNES\Coprocessors\BSX\BsxCart.h" />
    <ClInclude Include="SNES\Coprocessors\BSX\BsxMemoryPack.h" />
    <ClInclude Include="SNES\Coprocessors\BSX\BsxSatellaview.h" />
    <ClInclude Include="SNES\Coprocessors\BSX\BsxStream.h" />
    <ClInclude Include="Shared\CheatManager.h" />
    <ClInclude Include="Netplay\ClientConnectionData.h" />
    <ClInclude Include="SNES\DSP\DspTypes.h" />
    <ClInclude Include="SNES\DSP\DspVoice.h" />
    <ClInclude Include="SNES\Input\SnesRumbleController.h" />
    <ClInclude Include="SNES\SnesCpu.Shared.h" />
    <ClInclude Include="SNES\Coprocessors\SA1\CpuBwRamHandler.h" />
    <ClInclude Include="SNES\Debugger\SnesDebugger.h" />
    <ClInclude Include="SNES\Coprocessors\CX4\Cx4.h" />
    <ClInclude Include="SNES\Debugger\Cx4Debugger.h" />
    <ClInclude Include="SNES\Debugger\Cx4DisUtils.h" />
    <ClInclude Include="SNES\Coprocessors\CX4\Cx4Types.h" />
    <ClInclude Include="Debugger\DebugUtilities.h" />
    <ClInclude Include="SNES\Debugger\TraceLogger\Cx4TraceLogger.h" />
    <ClInclude Include="SNES\Debugger\TraceLogger\NecDspTraceLogger.h" />
    <ClInclude Include="SNES\Debugger\TraceLogger\GsuTraceLogger.h" />
    <ClInclude Include="SNES\Debugger\TraceLogger\SpcTraceLogger.h" />
    <ClInclude Include="SNES\Debugger\TraceLogger\SnesCpuTraceLogger.h" />
    <ClInclude Include="SNES\DmaControllerTypes.h" />
    <ClInclude Include="Shared\Emulator.h" />
    <ClInclude Include="Shared\McpServer.h" />
    <ClInclude Include="Gameboy\Gameboy.h" />
    <ClInclude Include="Gameboy\Debugger\GameboyDisUtils.h" />
    <ClInclude Include="Gameboy\GameboyHeader.h" />
    <ClInclude Include="Gameboy\APU\GbApu.h" />
    <ClInclude Include="Gameboy\Debugger\GbAssembler.h" />
    <ClInclude Include="Gameboy\GbBootRom.h" />
    <ClInclude Include="Gameboy\Carts\GbCart.h" />
    <ClInclude Include="Gameboy\GbCartFactory.h" />
    <ClInclude Include="Gameboy\GbCpu.h" />
    <ClInclude Include="Gameboy\Debugger\GbDebugger.h" />
    <ClInclude Include="Gameboy\GbDmaController.h" />
    <ClInclude Include="Gameboy\Debugger\GbEventManager.h" />
    <ClInclude Include="Gameboy\Carts\GbMbc1.h" />
    <ClInclude Include="Gameboy\Carts\GbMbc2.h" />
    <ClInclude Include="Gameboy\Carts\GbMbc3.h" />
    <ClInclude Include="Gameboy\Carts\GbMbc5.h" />
    <ClInclude Include="Gameboy\GbMemoryManager.h" />
    <ClInclude Include="Gameboy\APU\GbNoiseChannel.h" />
    <ClInclude Include="Gameboy\GbPpu.h" />
    <ClInclude Include="Gameboy\APU\GbSquareChannel.h" />
    <ClInclude Include="Gameboy\GbTimer.h" />
    <ClInclude Include="Gameboy\GbTypes.h" />
    <ClInclude Include="Gameboy\APU\GbWaveChannel.h" />
    <ClInclude Include="Debugger\IAssembler.h" />
    <ClInclude Include="Shared\Interfaces\IConsole.h" />
    <ClInclude Include="SNES\Debugger\NecDspDebugger.h" />
    <ClInclude Include="Netplay\ForceDisconnectMessage.h" />
    <ClInclude Include="Netplay\GameClient.h" />
    <ClInclude Include="Netplay\GameClientConnection.h" />
    <ClInclude Include="Netplay\GameConnection.h" />
    <ClInclude Include="Netplay\GameInformationMessage.h" />
    <ClInclude Include="Netplay\GameServer.h" />
    <ClInclude Include="Netplay\GameServerConnection.h" />
    <ClInclude Include="SNES\Coprocessors\GSU\Gsu.h" />
    <ClInclude Include="SNES\Debugger\GsuDebugger.h" />
    <ClInclude Include="SNES\Debugger\GsuDisUtils.h" />
    <ClInclude Include="SNES\Coprocessors\GSU\GsuRamHandler.h" />
    <ClInclude Include="SNES\Coprocessors\GSU\GsuRomHandler.h" />
    <ClInclude Include="SNES\Coprocessors\GSU\GsuTypes.h" />
    <ClInclude Include="Netplay\HandShakeMessage.h" />
    <ClInclude Include="Debugger\IDebugger.h" />
    <ClInclude Include="Netplay\InputDataMessage.h" />
    <ClInclude Include="Shared\InputHud.h" />
    <ClInclude Include="SNES\InternalRegisterTypes.h" />
    <ClInclude Include="SNES\MemoryMappings.h" />
    <ClInclude Include="Shared\Audio\BaseSoundManager.h" />
    <ClInclude Include="Shared\Video\BaseVideoFilter.h" />
    <ClInclude Include="Shared\FirmwareHelper.h" />
    <ClInclude Include="Debugger\Breakpoint.h" />
    <ClInclude Include="Debugger\BreakpointManager.h" />
    <ClInclude Include="Debugger\CallstackManager.h" />
    <ClInclude Include="SNES\CartTypes.h" />
    <ClInclude Include="Debugger\CodeDataLogger.h" />
    <ClInclude Include="SNES\SnesConsole.h" />
    <ClInclude Include="Shared\EmulatorLock.h" />
    <ClInclude Include="Shared\ControlDeviceState.h" />
    <ClInclude Include="SNES\SnesControlManager.h" />
    <ClInclude Include="SNES\SnesCpu.h" />
    <ClInclude Include="SNES\SnesCpu.Instructions.h" />
    <ClInclude Include="SNES\Debugger\SnesDisUtils.h" />
    <ClInclude Include="Debugger\DebugBreakHelper.h" />
    <ClInclude Include="Shared\Video\DebugStats.h" />
    <ClInclude Include="SNES\Debugger\DummySnesCpu.h" />
    <ClInclude Include="SNES\Debugger\DummySpc.h" />
    <ClInclude Include="Shared\EmuSettings.h" />
    <ClInclude Include="SNES\Debugger\SnesEventManager.h" />
    <ClInclude Include="Shared\EventType.h" />
    <ClInclude Include="Debugger\ExpressionEvaluator.h" />
    <ClInclude Include="Debugger\LabelManager.h" />
    <ClInclude Include="Debugger\LuaApi.h" />
    <ClInclude Include="Debugger\LuaCallHelper.h" />
    <ClInclude Include="Debugger\MemoryAccessCounter.h" />
    <ClInclude Include="Netplay\MessageType.h" />
    <ClInclude Include="Netplay\MovieDataMessage.h" />
    <ClInclude Include="Shared\Movies\MovieTypes.h" />
    <ClInclude Include="SNES\Coprocessors\MSU1\Msu1.h" />
    <ClInclude Include="SNES\Input\Multitap.h" />
    <ClInclude Include="Shared\Movies\MesenMovie.h" />
    <ClInclude Include="Shared\Movies\MovieManager.h" />
    <ClInclude Include="Shared\Movies\MovieRecorder.h" />
    <ClInclude Include="SNES\Coprocessors\DSP\NecDsp.h" />
    <ClInclude Include="SNES\Debugger\NecDspDisUtils.h" />
    <ClInclude Include="SNES\Coprocessors\DSP\NecDspTypes.h" />
    <ClInclude Include="Netplay\NetMessage.h" />
    <ClInclude Include="SNES\SnesNtscFilter.h" />
    <ClInclude Include="SNES\Coprocessors\OBC1\Obc1.h" />
    <ClInclude Include="Shared\Audio\PcmReader.h" />
    <ClInclude Include="Netplay\PlayerListMessage.h" />
    <ClInclude Include="Debugger\PpuTools.h" />
    <ClInclude Include="Debugger\Profiler.h" />
    <ClInclude Include="Shared\RecordedRomTest.h" />
    <ClInclude Include="SNES\RegisterHandlerB.h" />
    <ClInclude Include="SNES\SnesCpuTypes.h" />
    <ClInclude Include="Debugger\Debugger.h" />
    <ClInclude Include="Shared\Video\DebugHud.h" />
    <ClInclude Include="Debugger\DebugTypes.h" />
    <ClInclude Include="SNES\SnesDefaultVideoFilter.h" />
    <ClInclude Include="Debugger\Disassembler.h" />
    <ClInclude Include="Debugger\DisassemblyInfo.h" />
    <ClInclude Include="SNES\SnesDmaController.h" />
    <ClInclude Include="Shared\Video\DrawCommand.h" />
    <ClInclude Include="Shared\Video\DrawLineCommand.h" />
    <ClInclude Include="Shared\Video\DrawPixelCommand.h" />
    <ClInclude Include="Shared\Video\DrawRectangleCommand.h" />
    <ClInclude Include="Shared\Video\DrawScreenBufferCommand.h" />
    <ClInclude Include="Shared\Video\DrawStringCommand.h" />
    <ClInclude Include="Shared\FrameLimiter.h" />
    <ClInclude Include="Shared\Interfaces\IAudioDevice.h" />
    <ClInclude Include="Shared\Interfaces\IInputProvider.h" />
    <ClInclude Include="Shared\Interfaces\IInputRecorder.h" />
    <ClInclude Include="Shared\Interfaces\IKeyManager.h" />
    <ClInclude Include="SNES\IMemoryHandler.h" />
    <ClInclude Include="Shared\Interfaces\IMessageManager.h" />
    <ClInclude Include="Shared\Interfaces\INotificationListener.h" />
    <ClInclude Include="SNES\InternalRegisters.h" />
    <ClInclude Include="Shared\Interfaces\IRenderingDevice.h" />
    <ClInclude Include="Shared\KeyManager.h" />
    <ClInclude Include="Debugger\MemoryDumper.h" />
    <ClInclude Include="SNES\SnesMemoryManager.h" />
    <ClInclude Include="Shared\MessageManager.h" />
    <ClInclude Include="Shared\NotificationManager.h" />
    <ClInclude Include="SNES\SnesPpu.h" />
    <ClInclude Include="SNES\SnesPpuTypes.h" />
    <ClInclude Include="SNES\RamHandler.h" />
    <ClInclude Include="SNES\RegisterHandlerA.h" />
    <ClInclude Include="Shared\RewindData.h" />
    <ClInclude Include="Shared\RewindManager.h" />
    <ClInclude Include="Shared\RomFinder.h" />
    <ClInclude Include="SNES\RomHandler.h" />
    <ClInclude Include="SNES\Coprocessors\SPC7110\Rtc4513.h" />
    <ClInclude Include="SNES\Coprocessors\SA1\Sa1.h" />
    <ClInclude Include="SNES\Coprocessors\SA1\Sa1BwRamHandler.h" />
    <ClInclude Include="SNES\Coprocessors\SA1\Sa1Cpu.h" />
    <ClInclude Include="SNES\Coprocessors\SA1\Sa1IRamHandler.h" />
    <ClInclude Include="SNES\Coprocessors\SA1\Sa1Types.h" />
    <ClInclude Include="SNES\Coprocessors\SA1\Sa1VectorHandler.h" />
    <ClInclude Include="Shared\SaveStateManager.h" />
    <ClInclude Include="Netplay\SaveStateMessage.h" />
    <ClInclude Include="Shared\Video\ScaleFilter.h" />
    <ClInclude Include="Debugger\ScriptHost.h" />
    <ClInclude Include="Debugger\ScriptingContext.h" />
    <ClInclude Include="Debugger\ScriptManager.h" />
    <ClInclude Include="SNES\Coprocessors\SDD1\Sdd1.h" />
    <ClInclude Include="SNES\Coprocessors\SDD1\Sdd1Decomp.h" />
    <ClInclude Include="SNES\Coprocessors\SDD1\Sdd1Mmc.h" />
    <ClInclude Include="SNES\Coprocessors\SDD1\Sdd1Types.h" />
    <ClInclude Include="Netplay\SelectControllerMessage.h" />
    <ClInclude Include="Netplay\ServerInformationMessage.h" />
    <ClInclude Include="Shared\SettingTypes.h" />
    <ClInclude Include="Shared\ShortcutKeyHandler.h" />
    <ClInclude Include="SNES\Input\SnesController.h" />
    <ClInclude Include="Shared\MemoryType.h" />
    <ClInclude Include="SNES\Input\SnesMouse.h" />
    <ClInclude Include="Shared\Audio\SoundMixer.h" />
    <ClInclude Include="Shared\Audio\SoundResampler.h" />
    <ClInclude Include="SNES\SnesState.h" />
    <ClInclude Include="SNES\Spc.h" />
    <ClInclude Include="SNES\Coprocessors\SPC7110\Spc7110.h" />
    <ClInclude Include="SNES\Coprocessors\SPC7110\Spc7110Decomp.h" />
    <ClInclude Include="SNES\Debugger\SpcDebugger.h" />
    <ClInclude Include="SNES\Debugger\SpcDisUtils.h" />
    <ClInclude Include="Shared\Audio\AudioPlayerHud.h" />
    <ClInclude Include="SNES\SpcFileData.h" />
    <ClInclude Include="SNES\SpcTimer.h" />
    <ClInclude Include="SNES\SpcTypes.h" />
    <ClInclude Include="pch.h" />
    <ClInclude Include="SNES\Coprocessors\SGB\SuperGameboy.h" />
    <ClInclude Include="SNES\Input\SuperScope.h" />
    <ClInclude Include="Shared\SystemActionManager.h" />
    <ClInclude Include="Shared\Video\VideoDecoder.h" />
    <ClInclude Include="Shared\Video\VideoRenderer.h" />
    <ClInclude Include="Shared\Audio\WaveRecorder.h" />
    <ClInclude Include="Shared\Interfaces\IMouseManager.h" />
    <ClInclude Include="WS\APU\WsApuCh1.h" />
    <ClInclude Include="WS\APU\WsApuCh2.h" />
    <ClInclude Include="WS\APU\WsApuCh3.h" />
    <ClInclude Include="WS\APU\WsApuCh4.h" />
    <ClInclude Include="WS\APU\WsHyperVoice.h" />
    <ClInclude Include="WS\Carts\WsCart.h" />
    <ClInclude Include="WS\Debugger\DummyWsCpu.h" />
    <ClInclude Include="WS\Debugger\WsAssembler.h" />
    <ClInclude Include="WS\Debugger\WsDebugger.h" />
    <ClInclude Include="WS\Debugger\WsDisUtils.h" />
    <ClInclude Include="WS\Debugger\WsEventManager.h" />
    <ClInclude Include="WS\Debugger\WsPpuTools.h" />
    <ClInclude Include="WS\Debugger\WsTraceLogger.h" />
    <ClInclude Include="WS\APU\WsApu.h" />
    <ClInclude Include="WS\WsConsole.h" />
    <ClInclude Include="WS\WsController.h" />
    <ClInclude Include="WS\WsControlManager.h" />
    <ClInclude Include="WS\WsCpu.h" />
    <ClInclude Include="WS\WsCpuPrefetch.h" />
    <ClInclude Include="WS\WsDefaultVideoFilter.h" />
    <ClInclude Include="WS\WsDmaController.h" />
    <ClInclude Include="WS\WsEeprom.h" />
    <ClInclude Include="WS\WsMemoryManager.h" />
    <ClInclude Include="WS\WsPpu.h" />
    <ClInclude Include="WS\WsSerial.h" />
    <ClInclude Include="WS\WsTimer.h" />
    <ClInclude Include="WS\WsTypes.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Debugger\Base6502Assembler.cpp" />
    <ClCompile Include="Debugger\BaseEventManager.cpp" />
    <ClCompile Include="Debugger\CdlManager.cpp" />
    <ClCompile Include="Debugger\DisassemblySearch.cpp" />
    <ClCompile Include="Debugger\ExpressionEvaluator.St018.cpp" />
    <ClCompile Include="Debugger\ExpressionEvaluator.Ws.cpp" />
    <ClCompile Include="Debugger\ExpressionEvaluator.Cx4.cpp" />
    <ClCompile Include="Debugger\ExpressionEvaluator.Gameboy.cpp" />
    <ClCompile Include="Debugger\ExpressionEvaluator.Gba.cpp" />
    <ClCompile Include="Debugger\ExpressionEvaluator.Gsu.cpp" />
    <ClCompile Include="Debugger\ExpressionEvaluator.NecDsp.cpp" />
    <ClCompile Include="Debugger\ExpressionEvaluator.Nes.cpp" />
    <ClCompile Include="Debugger\ExpressionEvaluator.Pce.cpp" />
    <ClCompile Include="Debugger\ExpressionEvaluator.Sms.cpp" />
    <ClCompile Include="Debugger\ExpressionEvaluator.Snes.cpp" />
    <ClCompile Include="Debugger\ExpressionEvaluator.Spc.cpp" />
    <ClCompile Include="Debugger\StepBackManager.cpp" />
    <ClCompile Include="Gameboy\Debugger\DummyGbCpu.cpp" />
    <ClCompile Include="Gameboy\Debugger\GbTraceLogger.cpp" />
    <ClCompile Include="Gameboy\Debugger\GbPpuTools.cpp" />
    <ClCompile Include="Gameboy\GbControlManager.cpp" />
    <ClCompile Include="Gameboy\GbDefaultVideoFilter.cpp" />
    <ClCompile Include="GBA\APU\GbaApu.cpp" />
    <ClCompile Include="GBA\APU\GbaNoiseChannel.cpp" />
    <ClCompile Include="GBA\APU\GbaSquareChannel.cpp" />
    <ClCompile Include="GBA\APU\GbaWaveChannel.cpp" />
    <ClCompile Include="GBA\Cart\GbaCart.cpp" />
    <ClCompile Include="GBA\Cart\GbaGpio.cpp" />
    <ClCompile Include="GBA\Cart\GbaRtc.cpp" />
    <ClCompile Include="GBA\Debugger\DummyGbaCpu.cpp" />
    <ClCompile Include="GBA\Debugger\GbaDebugger.cpp" />
    <ClCompile Include="GBA\Debugger\GbaDisUtils.cpp" />
    <ClCompile Include="GBA\Debugger\GbaEventManager.cpp" />
    <ClCompile Include="GBA\Debugger\GbaPpuTools.cpp" />
    <ClCompile Include="GBA\Debugger\GbaTraceLogger.cpp" />
    <ClCompile Include="GBA\GbaConsole.cpp" />
    <ClCompile Include="GBA\GbaControlManager.cpp" />
    <ClCompile Include="GBA\GbaCpu.Arm.cpp" />
    <ClCompile Include="GBA\GbaCpu.cpp" />
    <ClCompile Include="GBA\GbaCpu.Thumb.cpp" />
    <ClCompile Include="GBA\GbaDefaultVideoFilter.cpp" />
    <ClCompile Include="GBA\GbaDmaController.cpp" />
    <ClCompile Include="GBA\GbaMemoryManager.cpp" />
    <ClCompile Include="GBA\GbaPpu.cpp" />
    <ClCompile Include="GBA\GbaTimer.cpp" />
    <ClCompile Include="NES\BaseNesPpu.cpp" />
    <ClCompile Include="NES\BisqwitNtscFilter.cpp" />
    <ClCompile Include="NES\Debugger\DummyNesCpu.cpp" />
    <ClCompile Include="NES\Debugger\NesPpuTools.cpp" />
    <ClCompile Include="NES\Debugger\NesAssembler.cpp" />
    <ClCompile Include="NES\Debugger\NesEventManager.cpp" />
    <ClCompile Include="NES\Debugger\NesTraceLogger.cpp" />
    <ClCompile Include="NES\Epsm.cpp" />
    <ClCompile Include="NES\HdPacks\HdAudioDevice.cpp" />
    <ClCompile Include="NES\HdPacks\HdNesPack.cpp" />
    <ClCompile Include="NES\HdPacks\HdNesPpu.cpp" />
    <ClCompile Include="NES\HdPacks\HdPackBuilder.cpp" />
    <ClCompile Include="NES\HdPacks\HdPackLoader.cpp" />
    <ClCompile Include="NES\HdPacks\HdVideoFilter.cpp" />
    <ClCompile Include="NES\HdPacks\OggMixer.cpp" />
    <ClCompile Include="NES\HdPacks\OggReader.cpp" />
    <ClCompile Include="NES\Loaders\FdsLoader.cpp" />
    <ClCompile Include="NES\Loaders\iNesLoader.cpp" />
    <ClCompile Include="NES\Loaders\NsfLoader.cpp" />
    <ClCompile Include="NES\Loaders\RomLoader.cpp" />
    <ClCompile Include="NES\APU\BaseExpansionAudio.cpp" />
    <ClCompile Include="NES\Loaders\StudyBoxLoader.cpp" />
    <ClCompile Include="NES\Loaders\UnifLoader.cpp" />
    <ClCompile Include="NES\Mappers\Homebrew\Rainbow.cpp" />
    <ClCompile Include="Shared\Utilities\emu2413.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='PGO Profile|x64'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='PGO Optimize|x64'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="NES\Mappers\FDS\Fds.cpp" />
    <ClCompile Include="NES\Mappers\FDS\FdsAudio.cpp" />
    <ClCompile Include="NES\Mappers\FDS\FdsInputButtons.cpp" />
    <ClCompile Include="NES\Mappers\NSF\NsfMapper.cpp" />
    <ClCompile Include="NES\Mappers\VsSystem\VsControlManager.cpp" />
    <ClCompile Include="NES\NesNtscFilter.cpp" />
    <ClCompile Include="PCE\Debugger\PceAssembler.cpp" />
    <ClCompile Include="PCE\Input\PceTurboTap.cpp" />
    <ClCompile Include="PCE\Debugger\DummyPceCpu.cpp" />
    <ClCompile Include="PCE\Debugger\PceDebugger.cpp" />
    <ClCompile Include="PCE\Debugger\PceDisUtils.cpp" />
    <ClCompile Include="PCE\Debugger\PceEventManager.cpp" />
    <ClCompile Include="PCE\Debugger\PceVdcTools.cpp" />
    <ClCompile Include="PCE\Debugger\PceTraceLogger.cpp" />
    <ClCompile Include="PCE\CdRom\PceAdpcm.cpp" />
    <ClCompile Include="PCE\CdRom\PceArcadeCard.cpp" />
    <ClCompile Include="PCE\CdRom\PceAudioFader.cpp" />
    <ClCompile Include="PCE\CdRom\PceCdAudioPlayer.cpp" />
    <ClCompile Include="PCE\CdRom\PceCdRom.cpp" />
    <ClCompile Include="PCE\PceConsole.cpp" />
    <ClCompile Include="PCE\PceControlManager.cpp" />
    <ClCompile Include="PCE\PceCpu.cpp" />
    <ClCompile Include="PCE\PceCpu.Instructions.cpp" />
    <ClCompile Include="PCE\PceMemoryManager.cpp" />
    <ClCompile Include="PCE\PceNtscFilter.cpp" />
    <ClCompile Include="PCE\PceVdc.cpp" />
    <ClCompile Include="PCE\PcePsg.cpp" />
    <ClCompile Include="PCE\PcePsgChannel.cpp" />
    <ClCompile Include="PCE\CdRom\PceScsiBus.cpp" />
    <ClCompile Include="PCE\PceSf2RomMapper.cpp" />
    <ClCompile Include="PCE\PceTimer.cpp" />
    <ClCompile Include="PCE\PceVce.cpp" />
    <ClCompile Include="PCE\PceVpc.cpp" />
    <ClCompile Include="Shared\BaseControlManager.cpp" />
    <ClCompile Include="NES\NesDefaultVideoFilter.cpp" />
    <ClCompile Include="NES\BaseMapper.cpp" />
    <ClCompile Include="NES\NesControlManager.cpp" />
    <ClCompile Include="NES\APU\DeltaModulationChannel.cpp" />
    <ClCompile Include="NES\GameDatabase.cpp" />
    <ClCompile Include="NES\MapperFactory.cpp" />
    <ClCompile Include="NES\APU\NesApu.cpp" />
    <ClCompile Include="NES\NesConsole.cpp" />
    <ClCompile Include="NES\NesCpu.cpp" />
    <ClCompile Include="NES\Debugger\NesDisUtils.cpp" />
    <ClCompile Include="NES\Debugger\NesDebugger.cpp" />
    <ClCompile Include="NES\NesHeader.cpp" />
    <ClCompile Include="NES\NesMemoryManager.cpp" />
    <ClCompile Include="NES\NesPpu.cpp" />
    <ClCompile Include="NES\NesSoundMixer.cpp" />
    <ClCompile Include="Shared\CdReader.cpp" />
    <ClCompile Include="Shared\DebuggerRequest.cpp" />
    <ClCompile Include="Shared\HistoryViewer.cpp" />
    <ClCompile Include="Shared\Video\DrawStringCommand.cpp" />
    <ClCompile Include="Shared\Video\RotateFilter.cpp" />
    <ClCompile Include="Shared\Video\SoftwareRenderer.cpp" />
    <ClCompile Include="Shared\Video\SystemHud.cpp" />
    <ClCompile Include="SMS\Carts\SmsCart.cpp" />
    <ClCompile Include="SMS\Debugger\DummySmsCpu.cpp" />
    <ClCompile Include="SMS\Debugger\SmsAssembler.cpp" />
    <ClCompile Include="SMS\Debugger\SmsDebugger.cpp" />
    <ClCompile Include="SMS\Debugger\SmsDisUtils.cpp" />
    <ClCompile Include="SMS\Debugger\SmsEventManager.cpp" />
    <ClCompile Include="SMS\Debugger\SmsTraceLogger.cpp" />
    <ClCompile Include="SMS\Debugger\SmsVdpTools.cpp" />
    <ClCompile Include="SMS\SmsBiosMapper.cpp" />
    <ClCompile Include="SMS\SmsConsole.cpp" />
    <ClCompile Include="SMS\SmsControlManager.cpp" />
    <ClCompile Include="SMS\SmsCpu.cpp" />
    <ClCompile Include="SMS\SmsFmAudio.cpp" />
    <ClCompile Include="SMS\SmsMemoryManager.cpp" />
    <ClCompile Include="SMS\SmsNtscFilter.cpp" />
    <ClCompile Include="SMS\SmsPsg.cpp" />
    <ClCompile Include="SMS\SmsVdp.cpp" />
    <ClCompile Include="SNES\AluMulDiv.cpp" />
    <ClCompile Include="SNES\Coprocessors\ST018\ArmV3Cpu.cpp" />
    <ClCompile Include="SNES\Coprocessors\ST018\St018.cpp" />
    <ClCompile Include="SNES\Debugger\DummyArmV3Cpu.cpp" />
    <ClCompile Include="SNES\Debugger\DummySnesCpu.cpp" />
    <ClCompile Include="SNES\Debugger\DummySpc.cpp" />
    <ClCompile Include="SNES\Debugger\SnesPpuTools.cpp" />
    <ClCompile Include="SNES\Debugger\SnesAssembler.cpp" />
    <ClCompile Include="SNES\BaseCartridge.cpp" />
    <ClCompile Include="Shared\BaseControlDevice.cpp" />
    <ClCompile Include="Shared\Audio\BaseSoundManager.cpp" />
    <ClCompile Include="Shared\Video\BaseVideoFilter.cpp" />
    <ClCompile Include="Shared\BatteryManager.cpp" />
    <ClCompile Include="Debugger\Breakpoint.cpp" />
    <ClCompile Include="Debugger\BreakpointManager.cpp" />
    <ClCompile Include="SNES\Coprocessors\BSX\BsxCart.cpp" />
    <ClCompile Include="SNES\Coprocessors\BSX\BsxMemoryPack.cpp" />
    <ClCompile Include="SNES\Coprocessors\BSX\BsxSatellaview.cpp" />
    <ClCompile Include="SNES\Coprocessors\BSX\BsxStream.cpp" />
    <ClCompile Include="Debugger\CallstackManager.cpp" />
    <ClCompile Include="Shared\CheatManager.cpp" />
    <ClCompile Include="Debugger\CodeDataLogger.cpp" />
    <ClCompile Include="SNES\Debugger\St018Debugger.cpp" />
    <ClCompile Include="SNES\Debugger\St018DisUtils.cpp" />
    <ClCompile Include="SNES\Debugger\TraceLogger\St018TraceLogger.cpp" />
    <ClCompile Include="SNES\DSP\Dsp.cpp" />
    <ClCompile Include="SNES\DSP\DspVoice.cpp" />
    <ClCompile Include="SNES\Input\SnesRumbleController.cpp" />
    <ClCompile Include="SNES\SnesConsole.cpp" />
    <ClCompile Include="Shared\EmulatorLock.cpp" />
    <ClCompile Include="SNES\SnesControlManager.cpp" />
    <ClCompile Include="SNES\SnesCpu.cpp" />
    <ClCompile Include="SNES\Debugger\SnesDebugger.cpp" />
    <ClCompile Include="SNES\Debugger\SnesDisUtils.cpp" />
    <ClCompile Include="SNES\Coprocessors\CX4\Cx4.cpp" />
    <ClCompile Include="SNES\Coprocessors\CX4\Cx4.Instructions.cpp" />
    <ClCompile Include="SNES\Debugger\Cx4Debugger.cpp" />
    <ClCompile Include="SNES\Debugger\Cx4DisUtils.cpp" />
    <ClCompile Include="Debugger\Debugger.cpp" />
    <ClCompile Include="Shared\Video\DebugHud.cpp" />
    <ClCompile Include="Shared\Video\DebugStats.cpp" />
    <ClCompile Include="SNES\Debugger\TraceLogger\Cx4TraceLogger.cpp" />
    <ClCompile Include="SNES\Debugger\TraceLogger\NecDspTraceLogger.cpp" />
    <ClCompile Include="SNES\Debugger\TraceLogger\GsuTraceLogger.cpp" />
    <ClCompile Include="SNES\Debugger\TraceLogger\SpcTraceLogger.cpp" />
    <ClCompile Include="SNES\Debugger\TraceLogger\SnesCpuTraceLogger.cpp" />
    <ClCompile Include="SNES\SnesDefaultVideoFilter.cpp" />
    <ClCompile Include="Debugger\Disassembler.cpp" />
    <ClCompile Include="Debugger\DisassemblyInfo.cpp" />
    <ClCompile Include="SNES\SnesDmaController.cpp" />
    <ClCompile Include="Shared\Emulator.cpp" />
    <ClCompile Include="Shared\McpServer.cpp" />
    <ClCompile Include="Gameboy\Gameboy.cpp" />
    <ClCompile Include="Gameboy\Debugger\GameboyDisUtils.cpp" />
    <ClCompile Include="Gameboy\APU\GbApu.cpp" />
    <ClCompile Include="Gameboy\Debugger\GbAssembler.cpp" />
    <ClCompile Include="Gameboy\GbCpu.cpp" />
    <ClCompile Include="Gameboy\Debugger\GbDebugger.cpp" />
    <ClCompile Include="Gameboy\GbDmaController.cpp" />
    <ClCompile Include="Gameboy\Debugger\GbEventManager.cpp" />
    <ClCompile Include="Gameboy\GbMemoryManager.cpp" />
    <ClCompile Include="Gameboy\APU\GbNoiseChannel.cpp" />
    <ClCompile Include="Gameboy\GbPpu.cpp" />
    <ClCompile Include="Gameboy\APU\GbSquareChannel.cpp" />
    <ClCompile Include="Gameboy\GbTimer.cpp" />
    <ClCompile Include="Gameboy\APU\GbWaveChannel.cpp" />
    <ClCompile Include="SNES\Debugger\NecDspDebugger.cpp" />
    <ClCompile Include="Shared\EmuSettings.cpp" />
    <ClCompile Include="SNES\Debugger\SnesEventManager.cpp" />
    <ClCompile Include="Debugger\ExpressionEvaluator.cpp" />
    <ClCompile Include="Netplay\GameClient.cpp" />
    <ClCompile Include="Netplay\GameClientConnection.cpp" />
    <ClCompile Include="Netplay\GameConnection.cpp" />
    <ClCompile Include="Netplay\GameServer.cpp" />
    <ClCompile Include="Netplay\GameServerConnection.cpp" />
    <ClCompile Include="SNES\Coprocessors\GSU\Gsu.cpp" />
    <ClCompile Include="SNES\Coprocessors\GSU\Gsu.Instructions.cpp" />
    <ClCompile Include="SNES\Debugger\GsuDebugger.cpp" />
    <ClCompile Include="SNES\Debugger\GsuDisUtils.cpp" />
    <ClCompile Include="Shared\InputHud.cpp" />
    <ClCompile Include="SNES\InternalRegisters.cpp" />
    <ClCompile Include="Shared\KeyManager.cpp" />
    <ClCompile Include="Debugger\LabelManager.cpp" />
    <ClCompile Include="Debugger\LuaApi.cpp" />
    <ClCompile Include="Debugger\LuaCallHelper.cpp" />
    <ClCompile Include="Debugger\MemoryAccessCounter.cpp" />
    <ClCompile Include="Debugger\MemoryDumper.cpp" />
    <ClCompile Include="SNES\SnesMemoryManager.cpp" />
    <ClCompile Include="SNES\MemoryMappings.cpp" />
    <ClCompile Include="Shared\Movies\MesenMovie.cpp" />
    <ClCompile Include="Shared\MessageManager.cpp" />
    <ClCompile Include="Shared\Movies\MovieManager.cpp" />
    <ClCompile Include="Shared\Movies\MovieRecorder.cpp" />
    <ClCompile Include="SNES\Coprocessors\MSU1\Msu1.cpp" />
    <ClCompile Include="SNES\Input\Multitap.cpp" />
    <ClCompile Include="SNES\Coprocessors\DSP\NecDsp.cpp" />
    <ClCompile Include="SNES\Debugger\NecDspDisUtils.cpp" />
    <ClCompile Include="Shared\NotificationManager.cpp" />
    <ClCompile Include="SNES\SnesNtscFilter.cpp" />
    <ClCompile Include="SNES\Coprocessors\OBC1\Obc1.cpp" />
    <ClCompile Include="Shared\Audio\PcmReader.cpp" />
    <ClCompile Include="SNES\SnesPpu.cpp" />
    <ClCompile Include="Debugger\PpuTools.cpp" />
    <ClCompile Include="Debugger\Profiler.cpp" />
    <ClCompile Include="Shared\RecordedRomTest.cpp" />
    <ClCompile Include="SNES\RegisterHandlerB.cpp" />
    <ClCompile Include="Shared\RewindData.cpp" />
    <ClCompile Include="Shared\RewindManager.cpp" />
    <ClCompile Include="SNES\Coprocessors\SPC7110\Rtc4513.cpp" />
    <ClCompile Include="SNES\Coprocessors\SA1\Sa1.cpp" />
    <ClCompile Include="SNES\Coprocessors\SA1\Sa1Cpu.cpp" />
    <ClCompile Include="Shared\SaveStateManager.cpp" />
    <ClCompile Include="Shared\Video\ScaleFilter.cpp" />
    <ClCompile Include="Debugger\ScriptHost.cpp" />
    <ClCompile Include="Debugger\ScriptingContext.cpp" />
    <ClCompile Include="Debugger\ScriptManager.cpp" />
    <ClCompile Include="SNES\Coprocessors\SDD1\Sdd1.cpp" />
    <ClCompile Include="SNES\Coprocessors\SDD1\Sdd1Decomp.cpp" />
    <ClCompile Include="SNES\Coprocessors\SDD1\Sdd1Mmc.cpp" />
    <ClCompile Include="Shared\ShortcutKeyHandler.cpp" />
    <ClCompile Include="SNES\Input\SnesController.cpp" />
    <ClCompile Include="Shared\Audio\SoundMixer.cpp" />
    <ClCompile Include="Shared\Audio\SoundResampler.cpp" />
    <ClCompile Include="SNES\Spc.cpp" />
    <ClCompile Include="SNES\Spc.Instructions.cpp" />
    <ClCompile Include="SNES\Coprocessors\SPC7110\Spc7110.cpp" />
    <ClCompile Include="SNES\Coprocessors\SPC7110\Spc7110Decomp.cpp" />
    <ClCompile Include="SNES\Debugger\SpcDebugger.cpp" />
    <ClCompile Include="SNES\Debugger\SpcDisUtils.cpp" />
    <ClCompile Include="Shared\Audio\AudioPlayerHud.cpp" />
    <ClCompile Include="pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='PGO Profile|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='PGO Optimize|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="SNES\Coprocessors\SGB\SuperGameboy.cpp" />
    <ClCompile Include="Shared\Video\VideoDecoder.cpp" />
    <ClCompile Include="Shared\Video\VideoRenderer.cpp" />
    <ClCompile Include="Shared\Audio\WaveRecorder.cpp" />
    <ClCompile Include="WS\APU\WsApu.cpp" />
    <ClCompile Include="WS\Carts\WsCart.cpp" />
    <ClCompile Include="WS\Debugger\DummyWsCpu.cpp" />
    <ClCompile Include="WS\Debugger\WsDebugger.cpp" />
    <ClCompile Include="WS\Debugger\WsDisUtils.cpp" />
    <ClCompile Include="WS\Debugger\WsEventManager.cpp" />
    <ClCompile Include="WS\Debugger\WsPpuTools.cpp" />
    <ClCompile Include="WS\Debugger\WsTraceLogger.cpp" />
    <ClCompile Include="WS\WsConsole.cpp" />
    <ClCompile Include="WS\WsControlManager.cpp" />
    <ClCompile Include="WS\WsCpu.cpp" />
    <ClCompile Include="WS\WsCpuPrefetch.cpp" />
    <ClCompile Include="WS\WsDefaultVideoFilter.cpp" />
    <ClCompile Include="WS\WsDmaController.cpp" />
    <ClCompile Include="WS\WsEeprom.cpp" />
    <ClCompile Include="WS\WsMemoryManager.cpp" />
    <ClCompile Include="WS\WsPpu.cpp" />
    <ClCompile Include="WS\WsSerial.cpp" />
    <ClCompile Include="WS\WsTimer.cpp" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Core.ruleset" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{78FEF1A1-6DF1-4CBB-A373-AE6FA7CE5CE0}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>Core</RootNamespace>
    <ProjectName>Core</ProjectName>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='PGO Profile|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='PGO Optimize|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='PGO Profile|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='PGO Optimize|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>$(SolutionDir);$(ProjectDir);$(IncludePath)</IncludePath>
    <LibraryPath>$(LibraryPath)</LibraryPath>
    <OutDir>$(SolutionDir)\bin\win-$(PlatformTarget)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
    <EnableMicrosoftCodeAnalysis>false</EnableMicrosoftCodeAnalysis>
    <CodeAnalysisRuleSet>Core.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)\bin\win-$(PlatformTarget)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
    <EnableMicrosoftCodeAnalysis>true</EnableMicrosoftCodeAnalysis>
    <IncludePath>$(SolutionDir);$(ProjectDir);$(IncludePath)</IncludePath>
    <CodeAnalysisRuleSet>Core.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='PGO Profile|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)\bin\win-$(PlatformTarget)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
    <EnableMicrosoftCodeAnalysis>false</EnableMicrosoftCodeAnalysis>
    <IncludePath>$(SolutionDir);$(ProjectDir);$(IncludePath)</IncludePath>
    <CodeAnalysisRuleSet>Core.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='PGO Optimize|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)\bin\win-$(PlatformTarget)\PGO Profile\</OutDir>
    <IntDir>obj\$(Platform)\PGO Profile\</IntDir>
    <EnableMicrosoftCodeAnalysis>false</EnableMicrosoftCodeAnalysis>
    <IncludePath>$(SolutionDir);$(ProjectDir);$(IncludePath)</IncludePath>
    <CodeAnalysisRuleSet>Core.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <InlineFunctionExpansion>
      </InlineFunctionExpansion>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
      <CallingConvention>Cdecl</CallingConvention>
      <AdditionalIncludeDirectories>
      </AdditionalIncludeDirectories>
      <StructMemberAlignment>Default</StructMemberAlignment>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <DisableLanguageExtensions>true</DisableLanguageExtensions>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <MinimalRebuild>false</MinimalRebuild>
      <ShowIncludes>
      </ShowIncludes>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <Profile>
      </Profile>
      <OptimizeReferences>
      </OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>Full</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>false</SDLCheck>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <OmitFramePointers>true</OmitFramePointers>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <AdditionalIncludeDirectories>
      </AdditionalIncludeDirectories>
      <StructMemberAlignment>Default</StructMemberAlignment>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <DisableLanguageExtensions>true</DisableLanguageExtensions>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <ShowIncludes>
      </ShowIncludes>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <RuntimeTypeInfo>
      </RuntimeTypeInfo>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='PGO Profile|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>Full</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>MESENOPTIMIZE;WIN32;NDEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>false</SDLCheck>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <OmitFramePointers>true</OmitFramePointers>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <AdditionalIncludeDirectories>
      </AdditionalIncludeDirectories>
      <StructMemberAlignment>Default</StructMemberAlignment>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <DisableLanguageExtensions>true</DisableLanguageExtensions>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <ShowIncludes>
      </ShowIncludes>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='PGO Optimize|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>Full</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>MESENOPTIMIZE;WIN32;NDEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>false</SDLCheck>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <OmitFramePointers>true</OmitFramePointers>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <AdditionalIncludeDirectories>
      </AdditionalIncludeDirectories>
      <StructMemberAlignment>Default</StructMemberAlignment>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <DisableLanguageExtensions>true</DisableLanguageExtensions>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <ShowIncludes>
      </ShowIncludes>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

## File: Core/Shared/EmuSettings.cpp
```cpp
#include "pch.h"
#include <random>
#include "Shared/EmuSettings.h"
#include "Shared/KeyManager.h"
#include "Shared/MessageManager.h"
#include "Shared/Emulator.h"
#include "Shared/DebuggerRequest.h"
#include "Shared/NotificationManager.h"
#include "Utilities/FolderUtilities.h"
#include "Utilities/Serializer.h"
EmuSettings::EmuSettings(Emulator* emu)
{
	_emu = emu;
	_flags = 0;
	_debuggerFlags = 0;
	std::random_device rd;
	_mt = std::mt19937(rd());
}
void EmuSettings::CopySettings(EmuSettings& src)
{
	SetVideoConfig(src._video);
	SetAudioConfig(src._audio);
	SetInputConfig(src._input);
	SetEmulationConfig(src._emulation);
	SetPreferences(src._preferences);
	SetAudioPlayerConfig(src._audioPlayer);
	SetDebugConfig(src._debug);
	SetGameConfig(src._game);
	SetSnesConfig(src._snes);
	SetGameboyConfig(src._gameboy);
	SetNesConfig(src._nes);
	SetPcEngineConfig(src._pce);
	SetSmsConfig(src._sms);
	SetGbaConfig(src._gba);
}
void EmuSettings::Serialize(Serializer& s)
{
	SV(_video.IntegerFpsMode);
	SV(_emulation.RunAheadFrames);
	SV(_game.DipSwitches);
	switch(_emu->GetConsoleType()) {
		case ConsoleType::Nes:
			SV(_nes.ConsoleType);
			SV(_nes.RamPowerOnState);
			SV(_nes.RandomizeMapperPowerOnState);
			SV(_nes.RandomizeCpuPpuAlignment);
			SV(_nes.DisableOamAddrBug); SV(_nes.DisablePaletteRead); SV(_nes.DisablePpu2004Reads);
			SV(_nes.DisableGameGenieBusConflicts); SV(_nes.DisablePpuReset); SV(_nes.EnableOamDecay);
			SV(_nes.EnablePpu2000ScrollGlitch); SV(_nes.EnablePpu2006ScrollGlitch); SV(_nes.EnablePpuOamRowCorruption);
			SV(_nes.RestrictPpuAccessOnFirstFrame);
			SV(_nes.EnableCpuTestMode);
			SV(_nes.EnableDmcSampleDuplicationGlitch);
			SV(_nes.EnablePpuSpriteEvalBug);
			SV(_nes.PpuExtraScanlinesAfterNmi); SV(_nes.PpuExtraScanlinesBeforeNmi);
			SV(_nes.Region);
			SV(_nes.LightDetectionRadius);
			SV(_nes.Port1.Type); SV(_nes.Port1SubPorts[0].Type); SV(_nes.Port1SubPorts[1].Type); SV(_nes.Port1SubPorts[2].Type); SV(_nes.Port1SubPorts[3].Type);
			SV(_nes.Port2.Type);
			SV(_nes.ExpPort.Type); SV(_nes.ExpPortSubPorts[0].Type); SV(_nes.ExpPortSubPorts[1].Type); SV(_nes.ExpPortSubPorts[2].Type); SV(_nes.ExpPortSubPorts[3].Type);
			break;
		case ConsoleType::Snes:
			SV(_snes.RamPowerOnState);
			SV(_snes.EnableRandomPowerOnState);
			SV(_snes.GsuClockSpeed);
			SV(_snes.PpuExtraScanlinesAfterNmi); SV(_snes.PpuExtraScanlinesBeforeNmi);
			SV(_snes.Region);
			SV(_snes.Port1.Type); SV(_snes.Port1SubPorts[0].Type); SV(_snes.Port1SubPorts[1].Type); SV(_snes.Port1SubPorts[2].Type); SV(_snes.Port1SubPorts[3].Type);
			SV(_snes.Port2.Type); SV(_snes.Port2SubPorts[0].Type); SV(_snes.Port2SubPorts[1].Type); SV(_snes.Port2SubPorts[2].Type); SV(_snes.Port2SubPorts[3].Type);
			SV(_snes.BsxCustomDate);
			SV(_snes.SpcClockSpeedAdjustment);
			if(_emu->GetRomInfo().Format == RomFormat::Gb) {
				SV(_gameboy.RamPowerOnState);
				SV(_gameboy.Controller.Type);
				SV(_gameboy.Model);
				SV(_gameboy.UseSgb2);
			}
			break;
		case ConsoleType::Gameboy:
			SV(_gameboy.RamPowerOnState);
			SV(_gameboy.Controller.Type);
			SV(_gameboy.Model);
			SV(_gameboy.UseSgb2);
			break;
		case ConsoleType::PcEngine:
			SV(_pce.RamPowerOnState);
			SV(_pce.EnableRandomPowerOnState);
			SV(_pce.CdRomType);
			SV(_pce.ConsoleType);
			SV(_pce.DisableCdRomSaveRamForHuCardGames);
			SV(_pce.EnableCdRomForHuCardGames);
			SV(_pce.Port1.Type);
			SV(_pce.Port1SubPorts[0].Type);
			SV(_pce.Port1SubPorts[1].Type);
			SV(_pce.Port1SubPorts[2].Type);
			SV(_pce.Port1SubPorts[3].Type);
			SV(_pce.Port1SubPorts[4].Type);
			break;
		case ConsoleType::Sms:
			SV(_sms.RamPowerOnState);
			SV(_sms.Port1.Type);
			SV(_sms.Port2.Type);
			SV(_sms.Region);
			SV(_sms.Revision);
			SV(_sms.EnableFmAudio);
			break;
		case ConsoleType::Gba:
			SV(_gba.RamPowerOnState);
			SV(_gba.OverclockScanlineCount);
			SV(_gba.Controller.Type);
			break;
		case ConsoleType::Ws:
			break;
		default:
			throw std::runtime_error("unsupported console type");
	}
}
uint32_t EmuSettings::GetVersion()
{
	uint16_t major = 2;
	uint8_t minor = 1;
	uint8_t revision = 1;
	return (major << 16) | (minor << 8) | revision;
}
string EmuSettings::GetVersionString()
{
	uint32_t version = GetVersion();
	return std::to_string(version >> 16) + "." + std::to_string((version >> 8) & 0xFF) + "." + std::to_string(version & 0xFF);
}
void EmuSettings::ProcessString(string & str, const char ** strPointer)
{
	if(*strPointer) {
		str = *strPointer;
	} else {
		str.clear();
	}
	*strPointer = str.c_str();
}
void EmuSettings::SetVideoConfig(VideoConfig& config)
{
	_video = config;
}
VideoConfig& EmuSettings::GetVideoConfig()
{
	return _video;
}
void EmuSettings::SetAudioConfig(AudioConfig& config)
{
	_audio = config;
	ProcessString(_audioDevice, &_audio.AudioDevice);
}
AudioConfig& EmuSettings::GetAudioConfig()
{
	return _audio;
}
void EmuSettings::SetInputConfig(InputConfig& config)
{
	_input = config;
}
InputConfig& EmuSettings::GetInputConfig()
{
	return _input;
}
void EmuSettings::SetEmulationConfig(EmulationConfig& config)
{
	_emulation = config;
}
EmulationConfig& EmuSettings::GetEmulationConfig()
{
	return _emulation;
}
void EmuSettings::SetSnesConfig(SnesConfig& config)
{
	_snes = config;
}
SnesConfig& EmuSettings::GetSnesConfig()
{
	return _snes;
}
void EmuSettings::SetNesConfig(NesConfig& config)
{
	_nes = config;
}
NesConfig& EmuSettings::GetNesConfig()
{
	return _nes;
}
void EmuSettings::SetGameboyConfig(GameboyConfig& config)
{
	_gameboy = config;
}
GameboyConfig& EmuSettings::GetGameboyConfig()
{
	return _gameboy;
}
void EmuSettings::SetGbaConfig(GbaConfig& config)
{
	_gba = config;
}
GbaConfig& EmuSettings::GetGbaConfig()
{
	return _gba;
}
void EmuSettings::SetPcEngineConfig(PcEngineConfig& config)
{
	_pce = config;
}
PcEngineConfig& EmuSettings::GetPcEngineConfig()
{
	return _pce;
}
void EmuSettings::SetSmsConfig(SmsConfig& config)
{
	_sms = config;
}
SmsConfig& EmuSettings::GetSmsConfig()
{
	return _sms;
}
void EmuSettings::SetCvConfig(CvConfig& config)
{
	_cv = config;
}
CvConfig& EmuSettings::GetCvConfig()
{
	return _cv;
}
void EmuSettings::SetWsConfig(WsConfig& config)
{
	_ws = config;
}
WsConfig& EmuSettings::GetWsConfig()
{
	return _ws;
}
void EmuSettings::SetGameConfig(GameConfig& config)
{
	_game = config;
}
GameConfig& EmuSettings::GetGameConfig()
{
	return _game;
}
void EmuSettings::SetPreferences(PreferencesConfig& config)
{
	MessageManager::SetOptions(!config.DisableOsd, CheckFlag(EmulationFlags::OutputToStdout));
	_preferences = config;
	ProcessString(_saveFolder, &_preferences.SaveFolderOverride);
	ProcessString(_saveStateFolder, &_preferences.SaveStateFolderOverride);
	ProcessString(_screenshotFolder, &_preferences.ScreenshotFolderOverride);
	FolderUtilities::SetFolderOverrides(
		_saveFolder,
		_saveStateFolder,
		_screenshotFolder,
		""
	);
}
PreferencesConfig& EmuSettings::GetPreferences()
{
	return _preferences;
}
void EmuSettings::SetAudioPlayerConfig(AudioPlayerConfig& config)
{
	_audioPlayer = config;
}
AudioPlayerConfig& EmuSettings::GetAudioPlayerConfig()
{
	return _audioPlayer;
}
void EmuSettings::SetDebugConfig(DebugConfig& config)
{
	_debug = config;
	DebuggerRequest req = _emu->GetDebugger(false);
	Debugger* dbg = req.GetDebugger();
	if(dbg) {
		dbg->ProcessConfigChange();
	}
}
DebugConfig& EmuSettings::GetDebugConfig()
{
	return _debug;
}
void EmuSettings::ClearShortcutKeys()
{
	_emulatorKeys[0].clear();
	_emulatorKeys[1].clear();
	_emulatorKeys[2].clear();
	_shortcutSupersets[0].clear();
	_shortcutSupersets[1].clear();
	_shortcutSupersets[2].clear();
	//Add Alt-F4 as a fake shortcut to prevent Alt-F4 from triggering Alt or F4 key bindings. (e.g load save state 4)
	KeyCombination keyComb;
	keyComb.Key1 = KeyManager::GetKeyCode("Left Alt");
	keyComb.Key2 = KeyManager::GetKeyCode("F4");
	SetShortcutKey(EmulatorShortcut::Exit, keyComb, 2);
}
void EmuSettings::SetShortcutKey(EmulatorShortcut shortcut, KeyCombination keyCombination, int keySetIndex)
{
	_emulatorKeys[keySetIndex][(uint32_t)shortcut] = keyCombination;
	for(int i = 0; i < 3; i++) {
		for(std::pair<const uint32_t, KeyCombination> &kvp : _emulatorKeys[i]) {
			if(keyCombination.IsSubsetOf(kvp.second)) {
				_shortcutSupersets[keySetIndex][(uint32_t)shortcut].push_back(kvp.second);
			} else if(kvp.second.IsSubsetOf(keyCombination)) {
				_shortcutSupersets[i][kvp.first].push_back(keyCombination);
			}
		}
	}
}
void EmuSettings::SetShortcutKeys(vector<ShortcutKeyInfo> shortcuts)
{
	auto lock = _updateShortcutsLock.AcquireSafe();
	ClearShortcutKeys();
	for(ShortcutKeyInfo &shortcut : shortcuts) {
		if(_emulatorKeys[0][(uint32_t)shortcut.Shortcut].GetKeys().empty()) {
			SetShortcutKey(shortcut.Shortcut, shortcut.Keys, 0);
		} else {
			SetShortcutKey(shortcut.Shortcut, shortcut.Keys, 1);
		}
	}
}
KeyCombination EmuSettings::GetShortcutKey(EmulatorShortcut shortcut, int keySetIndex)
{
	auto lock = _updateShortcutsLock.AcquireSafe();
	auto result = _emulatorKeys[keySetIndex].find((int)shortcut);
	if(result != _emulatorKeys[keySetIndex].end()) {
		return result->second;
	}
	return {};
}
vector<KeyCombination> EmuSettings::GetShortcutSupersets(EmulatorShortcut shortcut, int keySetIndex)
{
	auto lock = _updateShortcutsLock.AcquireSafe();
	return _shortcutSupersets[keySetIndex][(uint32_t)shortcut];
}
OverscanDimensions EmuSettings::GetOverscan()
{
	RomFormat romFormat = _emu->GetRomInfo().Format;
	switch(romFormat) {
		case RomFormat::Spc:
		case RomFormat::Gbs:
		case RomFormat::Nsf:
		case RomFormat::PceHes:
			return OverscanDimensions {};
		case RomFormat::Gb:
			if(_emu->GetConsoleType() == ConsoleType::Snes && _emu->GetSettings()->GetGameboyConfig().HideSgbBorders) {
				OverscanDimensions overscan = {};
				overscan.Top =  46;
				overscan.Bottom = 49;
				overscan.Left = 48;
				overscan.Right = 48;
				return overscan;
			}
	}
	if(_game.OverrideOverscan) {
		return _game.Overscan;
	}
	switch(_emu->GetConsoleType()) {
		case ConsoleType::Snes: return _snes.Overscan;
		case ConsoleType::Nes: return _emu->GetRegion() == ConsoleRegion::Ntsc ? _nes.NtscOverscan : _nes.PalOverscan;
		case ConsoleType::PcEngine: return _pce.Overscan;
		case ConsoleType::Sms:
			if(romFormat == RomFormat::ColecoVision) {
				return { 0, 0, 24, 24 };
			} else if(romFormat == RomFormat::GameGear) {
				return _sms.GameGearOverscan;
			} else {
				return  _emu->GetRegion() == ConsoleRegion::Ntsc ? _sms.NtscOverscan : _sms.PalOverscan;
			}
		case ConsoleType::Gameboy:
		case ConsoleType::Gba:
		case ConsoleType::Ws:
			break;
	}
	return OverscanDimensions {};
}
uint32_t EmuSettings::GetEmulationSpeed()
{
	if(CheckFlag(EmulationFlags::MaximumSpeed)) {
		return 0;
	} else if(CheckFlag(EmulationFlags::Turbo)) {
		return _emulation.TurboSpeed;
	} else if(CheckFlag(EmulationFlags::Rewind)) {
		return _emulation.RewindSpeed;
	} else {
		return _emulation.EmulationSpeed;
	}
}
double EmuSettings::GetAspectRatio(ConsoleRegion region, FrameInfo baseFrameSize)
{
	double screenAspectRatio = (double)baseFrameSize.Width / baseFrameSize.Height;
	switch(_video.AspectRatio) {
		case VideoAspectRatio::NoStretching: return screenAspectRatio;
		case VideoAspectRatio::Auto:
			if(_emu->GetConsoleType() == ConsoleType::Gameboy || _emu->GetConsoleType() == ConsoleType::Gba || _emu->GetConsoleType() == ConsoleType::Ws) {
				return screenAspectRatio;
			} else if(_emu->GetRomInfo().Format == RomFormat::GameGear) {
				return screenAspectRatio * (6.0 / 5.0);
			}
			return screenAspectRatio * ((region == ConsoleRegion::Pal || region == ConsoleRegion::Dendy) ? (11.0 / 8.0) : (8.0 / 7.0));
		case VideoAspectRatio::NTSC: return screenAspectRatio * 8.0 / 7.0;
		case VideoAspectRatio::PAL: return screenAspectRatio * 11.0 / 8.0;
		case VideoAspectRatio::Standard: return 4.0 / 3.0;
		case VideoAspectRatio::Widescreen: return 16.0 / 9.0;
		case VideoAspectRatio::Custom: return _video.CustomAspectRatio;
	}
	return 0.0;
}
void EmuSettings::SetFlag(EmulationFlags flag)
{
	if((_flags & (int)flag) == 0) {
		_flags |= (int)flag;
	}
}
void EmuSettings::SetFlagState(EmulationFlags flag, bool enabled)
{
	if(enabled) {
		SetFlag(flag);
	} else {
		ClearFlag(flag);
	}
}
void EmuSettings::ClearFlag(EmulationFlags flag)
{
	if((_flags & (int)flag) != 0) {
		_flags &= ~(int)flag;
	}
}
bool EmuSettings::CheckFlag(EmulationFlags flag)
{
	return (_flags & (int)flag) != 0;
}
void EmuSettings::SetDebuggerFlag(DebuggerFlags flag, bool enabled)
{
	if(enabled) {
		if((_debuggerFlags & (uint64_t)flag) == 0) {
			_debuggerFlags |= (uint64_t)flag;
		}
	} else {
		if((_debuggerFlags & (uint64_t)flag) != 0) {
			_debuggerFlags &= ~(uint64_t)flag;
		}
	}
	DebuggerRequest req = _emu->GetDebugger(false);
	Debugger* dbg = req.GetDebugger();
	if(dbg) {
		dbg->ProcessConfigChange();
	}
}
bool EmuSettings::CheckDebuggerFlag(DebuggerFlags flag)
{
	return (_debuggerFlags & (uint64_t)flag) != 0;
}
bool EmuSettings::HasRandomPowerOnState(ConsoleType consoleType)
{
	switch(consoleType) {
		case ConsoleType::Snes: return _snes.RamPowerOnState == RamState::Random || _snes.EnableRandomPowerOnState;
		case ConsoleType::Gameboy: return _gameboy.RamPowerOnState == RamState::Random;
		case ConsoleType::Nes: return _nes.RamPowerOnState == RamState::Random || _nes.RandomizeCpuPpuAlignment || _nes.RandomizeMapperPowerOnState;
		case ConsoleType::PcEngine: return _pce.RamPowerOnState == RamState::Random || _pce.EnableRandomPowerOnState;
		case ConsoleType::Sms: return _sms.RamPowerOnState == RamState::Random;
		case ConsoleType::Gba: return _gba.RamPowerOnState == RamState::Random;
	}
	return false;
}
void EmuSettings::InitializeRam(RamState state, void* data, uint32_t length)
{
	switch(state) {
		default:
		case RamState::AllZeros: memset(data, 0, length); break;
		case RamState::AllOnes: memset(data, 0xFF, length); break;
		case RamState::Random:
			std::uniform_int_distribution<uint64_t> dist(0, std::numeric_limits<uint64_t>::max());
			uint32_t i = 0;
			while(i < length) {
				uint64_t randomData = dist(_mt);
				for(int j = 0; j < 8 && i < length; j++) {
					((uint8_t*)data)[i] = (uint8_t)(randomData >> (8*j));
					i++;
				}
			}
			break;
	}
}
int EmuSettings::GetRandomValue(int maxValue)
{
	std::uniform_int_distribution<> dist(0, maxValue);
	return dist(_mt);
}
bool EmuSettings::GetRandomBool()
{
	return GetRandomValue(1) == 1;
}
bool EmuSettings::IsInputEnabled()
{
	return !CheckFlag(EmulationFlags::InBackground) || _preferences.AllowBackgroundInput;
}
double EmuSettings::GetControllerDeadzoneRatio()
{
	switch(_input.ControllerDeadzoneSize) {
		case 0: return 0.5;
		case 1: return 0.75;
		case 2: return 1;
		case 3: return 1.25;
		case 4: return 1.5;
	}
	return 1;
}
```

## File: Core/Debugger/Debugger.cpp
```cpp
#include "pch.h"
#include "Debugger/Debugger.h"
#include "Debugger/DebugTypes.h"
#include "Debugger/DisassemblyInfo.h"
#include "Debugger/MemoryDumper.h"
#include "Debugger/MemoryAccessCounter.h"
#include "Debugger/CodeDataLogger.h"
#include "Debugger/Disassembler.h"
#include "Debugger/DisassemblySearch.h"
#include "Debugger/BreakpointManager.h"
#include "Debugger/PpuTools.h"
#include "Debugger/DebugBreakHelper.h"
#include "Debugger/LabelManager.h"
#include "Debugger/ScriptManager.h"
#include "Debugger/ScriptHost.h"
#include "Debugger/CallstackManager.h"
#include "Debugger/ExpressionEvaluator.h"
#include "Debugger/BaseEventManager.h"
#include "Debugger/TraceLogFileSaver.h"
#include "Debugger/CdlManager.h"
#include "Debugger/ITraceLogger.h"
#include "SNES/SnesCpuTypes.h"
#include "SNES/SpcTypes.h"
#include "SNES/Coprocessors/SA1/Sa1Types.h"
#include "SNES/Coprocessors/GSU/GsuTypes.h"
#include "SNES/Coprocessors/CX4/Cx4Types.h"
#include "SNES/Coprocessors/DSP/NecDspTypes.h"
#include "SNES/Coprocessors/ST018/ArmV3Types.h"
#include "SNES/Debugger/SnesDebugger.h"
#include "SNES/Debugger/SpcDebugger.h"
#include "SNES/Debugger/GsuDebugger.h"
#include "SNES/Debugger/St018Debugger.h"
#include "SNES/Debugger/NecDspDebugger.h"
#include "SNES/Debugger/Cx4Debugger.h"
#include "NES/Debugger/NesDebugger.h"
#include "NES/NesTypes.h"
#include "Gameboy/Debugger/GbDebugger.h"
#include "Gameboy/GbTypes.h"
#include "PCE/Debugger/PceDebugger.h"
#include "PCE/PceTypes.h"
#include "SMS/Debugger/SmsDebugger.h"
#include "SMS/SmsTypes.h"
#include "GBA/Debugger/GbaDebugger.h"
#include "GBA/GbaTypes.h"
#include "WS/Debugger/WsDebugger.h"
#include "WS/WsTypes.h"
#include "Shared/BaseControlManager.h"
#include "Shared/EmuSettings.h"
#include "Shared/Audio/SoundMixer.h"
#include "Shared/NotificationManager.h"
#include "Shared/BaseState.h"
#include "Shared/Emulator.h"
#include "Shared/Interfaces/IConsole.h"
#include "Shared/MemoryOperationType.h"
#include "Shared/EventType.h"
#include "Utilities/HexUtilities.h"
#include "Utilities/FolderUtilities.h"
#include "Utilities/Patches/IpsPatcher.h"
#include "Utilities/PlatformUtilities.h"
uint64_t ITraceLogger::NextRowId = 0;
Debugger::Debugger(Emulator* emu, IConsole* console)
{
	_executionStopped = true;
	_emu = emu;
	_console = console;
	_settings = _emu->GetSettings();
	_consoleType = _emu->GetConsoleType();
	vector<CpuType> cpuTypes = _emu->GetCpuTypes();
	_cpuTypes = unordered_set<CpuType>(cpuTypes.begin(), cpuTypes.end());
	_mainCpuType = cpuTypes[0];
	_labelManager.reset(new LabelManager(this));
	_memoryDumper.reset(new MemoryDumper(this));
	_disassembler.reset(new Disassembler(console, this));
	_disassemblySearch.reset(new DisassemblySearch(_disassembler.get(), _labelManager.get()));
	_memoryAccessCounter.reset(new MemoryAccessCounter(this));
	_scriptManager.reset(new ScriptManager(this));
	_traceLogSaver.reset(new TraceLogFileSaver());
	_cdlManager.reset(new CdlManager(this, _disassembler.get()));
	for(CpuType type : cpuTypes) {
		unique_ptr<IDebugger> &debugger = _debuggers[(int)type].Debugger;
		switch(type) {
			case CpuType::Snes: debugger.reset(new SnesDebugger(this, CpuType::Snes)); break;
			case CpuType::Spc: debugger.reset(new SpcDebugger(this)); break;
			case CpuType::NecDsp: debugger.reset(new NecDspDebugger(this)); break;
			case CpuType::Sa1: debugger.reset(new SnesDebugger(this, CpuType::Sa1)); break;
			case CpuType::Gsu: debugger.reset(new GsuDebugger(this)); break;
			case CpuType::Cx4: debugger.reset(new Cx4Debugger(this)); break;
			case CpuType::St018: debugger.reset(new St018Debugger(this)); break;
			case CpuType::Gameboy: debugger.reset(new GbDebugger(this)); break;
			case CpuType::Nes: debugger.reset(new NesDebugger(this)); break;
			case CpuType::Pce: debugger.reset(new PceDebugger(this)); break;
			case CpuType::Sms: debugger.reset(new SmsDebugger(this)); break;
			case CpuType::Gba: debugger.reset(new GbaDebugger(this)); break;
			case CpuType::Ws: debugger.reset(new WsDebugger(this)); break;
			default: throw std::runtime_error("Unsupported CPU type");
		}
		_debuggers[(int)type].Evaluator.reset(new ExpressionEvaluator(this, _debuggers[(int)type].Debugger.get(), type));
	}
	for(CpuType type : _cpuTypes) {
		_debuggers[(int)type].Debugger->Init();
		_debuggers[(int)type].Debugger->ProcessConfigChange();
	}
	_breakRequestCount = 0;
	_suspendRequestCount = 0;
	_cdlManager->RefreshCodeCache(false);
	if(_emu->IsPaused()) {
		Step(_mainCpuType, 1, StepType::Step, BreakSource::Pause);
	}
	_executionStopped = false;
#ifdef _DEBUG
	if(_mainCpuType == CpuType::Snes) {
		ExpressionEvaluator eval(this, _debuggers[(int)CpuType::Snes].Debugger.get(), CpuType::Snes);
		eval.RunTests();
	}
#endif
}
Debugger::~Debugger()
{
	Release();
}
void Debugger::Release()
{
	while(_executionStopped) {
		Run();
	}
}
void Debugger::Reset()
{
	_memoryAccessCounter->ResetCounts();
	for(int i = 0; i <= (int)DebugUtilities::GetLastCpuType(); i++) {
		if(_debuggers[i].Debugger) {
			_debuggers[i].Debugger->Reset();
		}
		BaseEventManager* evtMgr = GetEventManager((CpuType)i);
		if(evtMgr) {
			evtMgr->ClearFrameEvents();
			evtMgr->ClearFrameEvents();
		}
	}
}
template<CpuType type, typename DebuggerType>
DebuggerType* Debugger::GetDebugger()
{
	return (DebuggerType*)_debuggers[(int)type].Debugger.get();
}
IDebugger* Debugger::GetMainDebugger()
{
	return _debuggers[(int)_mainCpuType].Debugger.get();
}
template<CpuType type>
uint64_t Debugger::GetCpuCycleCount()
{
	switch(type) {
		case CpuType::Snes: return GetDebugger<type, SnesDebugger>()->GetCpuCycleCount();
		case CpuType::Spc: return GetDebugger<type, SpcDebugger>()->GetCpuCycleCount();
		case CpuType::NecDsp: return GetDebugger<type, NecDspDebugger>()->GetCpuCycleCount();
		case CpuType::Sa1: return GetDebugger<type, SnesDebugger>()->GetCpuCycleCount();
		case CpuType::Gsu: return GetDebugger<type, GsuDebugger>()->GetCpuCycleCount();
		case CpuType::Cx4: return GetDebugger<type, Cx4Debugger>()->GetCpuCycleCount();
		case CpuType::St018: return GetDebugger<type, St018Debugger>()->GetCpuCycleCount();
		case CpuType::Gameboy: return GetDebugger<type, GbDebugger>()->GetCpuCycleCount();
		case CpuType::Nes: return GetDebugger<type, NesDebugger>()->GetCpuCycleCount();
		case CpuType::Pce: return GetDebugger<type, PceDebugger>()->GetCpuCycleCount();
		case CpuType::Sms: return GetDebugger<type, SmsDebugger>()->GetCpuCycleCount();
		case CpuType::Gba: return GetDebugger<type, GbaDebugger>()->GetCpuCycleCount();
		case CpuType::Ws: return GetDebugger<type, WsDebugger>()->GetCpuCycleCount();
		default: return 0; break;
	}
}
bool Debugger::ProcessStepBack(IDebugger* debugger)
{
	if(debugger->CheckStepBack()) {
		debugger->GetStepRequest()->Break(BreakSource::CpuStep);
		debugger->ResetPrevOpCode();
		return false;
	} else {
		return true;
	}
}
template<CpuType type>
void Debugger::ProcessInstruction()
{
	IDebugger* debugger = _debuggers[(int)type].Debugger.get();
	if(debugger->IsStepBack() && ProcessStepBack(debugger)) {
		debugger->AllowChangeProgramCounter = true;
		SleepOnBreakRequest<type>();
		debugger->AllowChangeProgramCounter = false;
		return;
	}
	debugger->IgnoreBreakpoints = false;
	debugger->AllowChangeProgramCounter = true;
	switch(type) {
		case CpuType::Snes: GetDebugger<type, SnesDebugger>()->ProcessInstruction(); break;
		case CpuType::Spc: GetDebugger<type, SpcDebugger>()->ProcessInstruction(); break;
		case CpuType::NecDsp: GetDebugger<type, NecDspDebugger>()->ProcessInstruction(); break;
		case CpuType::Sa1: GetDebugger<type, SnesDebugger>()->ProcessInstruction(); break;
		case CpuType::Gsu: GetDebugger<type, GsuDebugger>()->ProcessInstruction(); break;
		case CpuType::Cx4: GetDebugger<type, Cx4Debugger>()->ProcessInstruction(); break;
		case CpuType::St018: GetDebugger<type, St018Debugger>()->ProcessInstruction(); break;
		case CpuType::Gameboy: GetDebugger<type, GbDebugger>()->ProcessInstruction(); break;
		case CpuType::Nes: GetDebugger<type, NesDebugger>()->ProcessInstruction(); break;
		case CpuType::Pce: GetDebugger<type, PceDebugger>()->ProcessInstruction(); break;
		case CpuType::Sms: GetDebugger<type, SmsDebugger>()->ProcessInstruction(); break;
		case CpuType::Gba: GetDebugger<type, GbaDebugger>()->ProcessInstruction(); break;
		case CpuType::Ws: GetDebugger<type, WsDebugger>()->ProcessInstruction(); break;
	}
	debugger->AllowChangeProgramCounter = false;
	if(_scriptManager->HasCpuMemoryCallbacks()) {
		MemoryOperationInfo memOp = debugger->InstructionProgress.LastMemOperation;
		AddressInfo relAddr = { (int32_t)memOp.Address, memOp.MemType };
		uint8_t value = (uint8_t)memOp.Value;
		_scriptManager->ProcessMemoryOperation(relAddr, value, MemoryOperationType::ExecOpCode, type, true);
	}
}
template<CpuType type, uint8_t accessWidth, MemoryAccessFlags flags, typename T>
void Debugger::ProcessMemoryRead(uint32_t addr, T& value, MemoryOperationType opType)
{
	if(_debuggers[(int)type].Debugger->IsStepBack()) {
		SleepOnBreakRequest<type>();
		return;
	}
	switch(type) {
		case CpuType::Snes: GetDebugger<CpuType::Snes, SnesDebugger>()->ProcessRead(addr, value, opType); break;
		case CpuType::Spc: GetDebugger<CpuType::Spc, SpcDebugger>()->ProcessRead<flags>(addr, value, opType); break;
		case CpuType::NecDsp: GetDebugger<CpuType::NecDsp, NecDspDebugger>()->ProcessRead(addr, value, opType); break;
		case CpuType::Sa1: GetDebugger<CpuType::Sa1, SnesDebugger>()->ProcessRead(addr, value, opType); break;
		case CpuType::Gsu: GetDebugger<CpuType::Gsu, GsuDebugger>()->ProcessRead(addr, value, opType); break;
		case CpuType::Cx4: GetDebugger<CpuType::Cx4, Cx4Debugger>()->ProcessRead(addr, value, opType); break;
		case CpuType::St018: GetDebugger<CpuType::St018, St018Debugger>()->ProcessRead<accessWidth>(addr, value, opType); break;
		case CpuType::Gameboy: GetDebugger<CpuType::Gameboy, GbDebugger>()->ProcessRead(addr, value, opType); break;
		case CpuType::Nes: GetDebugger<CpuType::Nes, NesDebugger>()->ProcessRead(addr, value, opType); break;
		case CpuType::Pce: GetDebugger<CpuType::Pce, PceDebugger>()->ProcessRead(addr, value, opType); break;
		case CpuType::Sms: GetDebugger<CpuType::Sms, SmsDebugger>()->ProcessRead(addr, value, opType); break;
		case CpuType::Gba: GetDebugger<CpuType::Gba, GbaDebugger>()->ProcessRead<accessWidth>(addr, value, opType); break;
		case CpuType::Ws:
			if constexpr(accessWidth <= 2) {
				GetDebugger<CpuType::Ws, WsDebugger>()->ProcessRead<accessWidth>(addr, value, opType);
			}
			break;
	}
	if(_scriptManager->HasCpuMemoryCallbacks()) {
		ProcessScripts<type>(addr, value, opType);
	}
}
template<CpuType type, uint8_t accessWidth, MemoryAccessFlags flags, typename T>
bool Debugger::ProcessMemoryWrite(uint32_t addr, T& value, MemoryOperationType opType)
{
	if(_debuggers[(int)type].Debugger->IsStepBack()) {
		SleepOnBreakRequest<type>();
		return !_debuggers[(int)type].Debugger->GetFrozenAddressManager().IsFrozenAddress(addr);
	}
	switch(type) {
		case CpuType::Snes: GetDebugger<CpuType::Snes, SnesDebugger>()->ProcessWrite(addr, value, opType); break;
		case CpuType::Spc: GetDebugger<CpuType::Spc, SpcDebugger>()->ProcessWrite<flags>(addr, value, opType); break;
		case CpuType::NecDsp: GetDebugger<CpuType::NecDsp, NecDspDebugger>()->ProcessWrite(addr, value, opType); break;
		case CpuType::Sa1: GetDebugger<CpuType::Sa1, SnesDebugger>()->ProcessWrite(addr, value, opType); break;
		case CpuType::Gsu: GetDebugger<CpuType::Gsu, GsuDebugger>()->ProcessWrite(addr, value, opType); break;
		case CpuType::Cx4: GetDebugger<CpuType::Cx4, Cx4Debugger>()->ProcessWrite(addr, value, opType); break;
		case CpuType::St018: GetDebugger<CpuType::St018, St018Debugger>()->ProcessWrite<accessWidth>(addr, value, opType); break;
		case CpuType::Gameboy: GetDebugger<CpuType::Gameboy, GbDebugger>()->ProcessWrite(addr, value, opType); break;
		case CpuType::Nes: GetDebugger<CpuType::Nes, NesDebugger>()->ProcessWrite(addr, value, opType); break;
		case CpuType::Pce: GetDebugger<CpuType::Pce, PceDebugger>()->ProcessWrite(addr, value, opType); break;
		case CpuType::Sms: GetDebugger<CpuType::Sms, SmsDebugger>()->ProcessWrite(addr, value, opType); break;
		case CpuType::Gba: GetDebugger<CpuType::Gba, GbaDebugger>()->ProcessWrite<accessWidth>(addr, value, opType); break;
		case CpuType::Ws:
			if constexpr(accessWidth <= 2) {
				GetDebugger<CpuType::Ws, WsDebugger>()->ProcessWrite<accessWidth>(addr, value, opType);
			}
			break;
	}
	if(_scriptManager->HasCpuMemoryCallbacks()) {
		ProcessScripts<type>(addr, value, opType);
	}
	return !_debuggers[(int)type].Debugger->GetFrozenAddressManager().IsFrozenAddress(addr);
}
template<CpuType cpuType, MemoryType memType, MemoryOperationType opType, typename T>
void Debugger::ProcessMemoryAccess(uint32_t addr, T& value)
{
	IDebugger* debugger = _debuggers[(int)cpuType].Debugger.get();
	constexpr int accessWidth = std::is_same<T, uint16_t>::value ? 2 : 1;
	if(debugger->IsStepBack()) {
		return;
	}
	AddressInfo addressInfo = { (int32_t)addr, memType };
	MemoryOperationInfo operation(addr, value, opType, memType);
	if constexpr(opType == MemoryOperationType::Write) {
		_memoryAccessCounter->ProcessMemoryWrite<accessWidth>(addressInfo, _emu->GetMasterClock());
	} else {
		_memoryAccessCounter->ProcessMemoryRead<accessWidth>(addressInfo, _emu->GetMasterClock());
	}
	switch(cpuType) {
		default: break;
		case CpuType::Sms: GetDebugger<CpuType::Sms, SmsDebugger>()->ProcessMemoryAccess<opType>(addr, value, memType); break;
		case CpuType::Ws: GetDebugger<CpuType::Ws, WsDebugger>()->ProcessMemoryAccess<opType, T>(addr, value, memType); break;
	}
	if(_scriptManager->HasCpuMemoryCallbacks()) {
		ProcessScripts<cpuType>(addr, value, memType, opType);
	}
	ProcessBreakConditions<accessWidth>(cpuType, *debugger->GetStepRequest(), debugger->GetBreakpointManager(), operation, addressInfo);
}
template<CpuType type>
void Debugger::ProcessIdleCycle()
{
	if(_debuggers[(int)type].Debugger->IsStepBack()) {
		SleepOnBreakRequest<type>();
		return;
	}
	_debuggers[(int)type].Debugger->InstructionProgress.LastMemOperation.Type = MemoryOperationType::Idle;
	switch(type) {
		case CpuType::Snes: GetDebugger<type, SnesDebugger>()->ProcessIdleCycle(); break;
		case CpuType::Sa1: GetDebugger<type, SnesDebugger>()->ProcessIdleCycle(); break;
		case CpuType::Pce: GetDebugger<type, PceDebugger>()->ProcessIdleCycle(); break;
	}
}
template<CpuType type>
void Debugger::ProcessHaltedCpu()
{
	IDebugger* dbg = _debuggers[(int)type].Debugger.get();
	if(dbg->IsStepBack() && ProcessStepBack(dbg)) {
		dbg->AllowChangeProgramCounter = true;
		SleepOnBreakRequest<type>();
		dbg->AllowChangeProgramCounter = false;
		return;
	}
	dbg->AllowChangeProgramCounter = true;
	dbg->InstructionProgress.CurrentCycle = 0;
	StepRequest* req = dbg->GetStepRequest();
	req->ProcessCpuExec();
	if((int)req->BreakNeeded) {
		SleepUntilResume(type, req->GetBreakSource());
	} else {
		SleepOnBreakRequest<type>();
	}
	dbg->AllowChangeProgramCounter = false;
}
template<CpuType type>
void Debugger::SleepOnBreakRequest()
{
	if(_breakRequestCount) {
		SleepUntilResume(type, BreakSource::Unspecified);
	}
}
template<CpuType type, typename T>
void Debugger::ProcessPpuRead(uint16_t addr, T& value, MemoryType memoryType, MemoryOperationType opType)
{
	if(_debuggers[(int)type].Debugger->IsStepBack()) {
		return;
	}
	switch(type) {
		case CpuType::Snes: GetDebugger<type, SnesDebugger>()->ProcessPpuRead(addr, value, memoryType); break;
		case CpuType::Gameboy: GetDebugger<type, GbDebugger>()->ProcessPpuRead(addr, value, memoryType); break;
		case CpuType::Nes: GetDebugger<type, NesDebugger>()->ProcessPpuRead(addr, value, memoryType, opType); break;
		case CpuType::Pce: GetDebugger<type, PceDebugger>()->ProcessPpuRead(addr, value, memoryType); break;
		case CpuType::Sms: GetDebugger<type, SmsDebugger>()->ProcessPpuRead(addr, value, memoryType); break;
		default: throw std::runtime_error("Invalid cpu type");
	}
	if(_scriptManager->HasPpuMemoryCallbacks()) {
		ProcessScripts<type>(addr, value, memoryType, opType);
	}
}
template<CpuType type, typename T>
void Debugger::ProcessPpuWrite(uint16_t addr, T& value, MemoryType memoryType)
{
	if(_debuggers[(int)type].Debugger->IsStepBack()) {
		return;
	}
	switch(type) {
		case CpuType::Snes: GetDebugger<type, SnesDebugger>()->ProcessPpuWrite(addr, value, memoryType); break;
		case CpuType::Gameboy: GetDebugger<type, GbDebugger>()->ProcessPpuWrite(addr, value, memoryType); break;
		case CpuType::Nes: GetDebugger<type, NesDebugger>()->ProcessPpuWrite(addr, value, memoryType); break;
		case CpuType::Pce: GetDebugger<type, PceDebugger>()->ProcessPpuWrite(addr, value, memoryType); break;
		case CpuType::Sms: GetDebugger<type, SmsDebugger>()->ProcessPpuWrite(addr, value, memoryType); break;
		default: throw std::runtime_error("Invalid cpu type");
	}
	if(_scriptManager->HasPpuMemoryCallbacks()) {
		ProcessScripts<type>(addr, value, memoryType, MemoryOperationType::Write);
	}
}
template<CpuType type>
void Debugger::ProcessPpuCycle()
{
	if(_debuggers[(int)type].Debugger->IsStepBack()) {
		return;
	}
	switch(type) {
		case CpuType::Snes: GetDebugger<type, SnesDebugger>()->ProcessPpuCycle(); break;
		case CpuType::Gameboy: GetDebugger<type, GbDebugger>()->ProcessPpuCycle(); break;
		case CpuType::Nes: GetDebugger<type, NesDebugger>()->ProcessPpuCycle(); break;
		case CpuType::Pce: GetDebugger<type, PceDebugger>()->ProcessPpuCycle(); break;
		case CpuType::Sms: GetDebugger<type, SmsDebugger>()->ProcessPpuCycle(); break;
		case CpuType::Gba: GetDebugger<type, GbaDebugger>()->ProcessPpuCycle(); break;
		case CpuType::Ws: GetDebugger<type, WsDebugger>()->ProcessPpuCycle(); break;
		default: throw std::runtime_error("Invalid cpu type");
	}
}
void Debugger::SleepUntilResume(CpuType sourceCpu, BreakSource source, MemoryOperationInfo *operation, int breakpointId)
{
	if(_suspendRequestCount) {
		return;
	} else if(_executionStopped) {
		return;
	} else if(_breakRequestCount > 0 && (sourceCpu != _mainCpuType || !_debuggers[(int)sourceCpu].Debugger->AllowChangeProgramCounter)) {
		return;
	} else if(IsBreakpointForbidden(source, sourceCpu, operation)) {
		ClearPendingBreakExceptions();
		return;
	}
	_executionStopped = true;
	bool notificationSent = false;
	if(source != BreakSource::Unspecified || _breakRequestCount == 0) {
		GetMainDebugger()->OnBeforeBreak(sourceCpu);
		_emu->OnBeforePause(false);
		if(_settings->GetDebugConfig().SingleBreakpointPerInstruction) {
			_debuggers[(int)sourceCpu].Debugger->IgnoreBreakpoints = true;
		}
		if(_settings->GetDebugConfig().DrawPartialFrame) {
			_debuggers[(int)sourceCpu].Debugger->DrawPartialFrame();
		}
		BreakEvent evt = {};
		evt.SourceCpu = sourceCpu;
		evt.BreakpointId = breakpointId;
		evt.Source = source;
		if(operation) {
			evt.Operation = *operation;
		}
		_waitForBreakResume = true;
		_emu->GetNotificationManager()->SendNotification(ConsoleNotificationType::CodeBreak, &evt);
		ProcessEvent(EventType::CodeBreak, sourceCpu);
		notificationSent = true;
		PlatformUtilities::EnableScreensaver();
	}
	while((_waitForBreakResume && !_suspendRequestCount) || _breakRequestCount) {
		std::this_thread::sleep_for(std::chrono::duration<int, std::milli>(_breakRequestCount ? 1 : 10));
	}
	if(notificationSent) {
		PlatformUtilities::DisableScreensaver();
		_emu->GetNotificationManager()->SendNotification(ConsoleNotificationType::DebuggerResumed);
	}
	_executionStopped = false;
}
bool Debugger::IsBreakpointForbidden(BreakSource source, CpuType sourceCpu, MemoryOperationInfo* operation)
{
	if((source > BreakSource::InternalOperation || source == BreakSource::Breakpoint) && _breakRequestCount == 0) {
		BreakpointManager* bp = _debuggers[(int)sourceCpu].Debugger->GetBreakpointManager();
		uint32_t pc = GetProgramCounter(sourceCpu, true);
		AddressInfo relAddr = { (int32_t)pc, DebugUtilities::GetCpuMemoryType(sourceCpu) };
		AddressInfo absAddr = GetAbsoluteAddress(relAddr);
		return bp->IsForbidden(operation, relAddr, absAddr);
	}
	return false;
}
template<uint8_t accessWidth>
void Debugger::ProcessBreakConditions(CpuType sourceCpu, StepRequest& step, BreakpointManager* bpManager, MemoryOperationInfo& operation, AddressInfo& addressInfo)
{
	int breakpointId = bpManager->CheckBreakpoint<accessWidth>(operation, addressInfo, true);
	if(_breakRequestCount || _waitForBreakResume || ((int)step.BreakNeeded && (!_debuggers[(int)sourceCpu].Debugger->IgnoreBreakpoints || step.Type == StepType::CpuCycleStep))) {
		SleepUntilResume(sourceCpu, step.GetBreakSource());
	} else {
		if(breakpointId >= 0 && !_debuggers[(int)sourceCpu].Debugger->IgnoreBreakpoints) {
			SleepUntilResume(sourceCpu, BreakSource::Breakpoint, &operation, breakpointId);
		}
	}
}
template<uint8_t accessWidth>
void Debugger::ProcessPredictiveBreakpoint(CpuType sourceCpu, BreakpointManager* bpManager, MemoryOperationInfo& operation, AddressInfo& addressInfo)
{
	if(_debuggers[(int)sourceCpu].Debugger->IgnoreBreakpoints) {
		return;
	}
	int breakpointId = bpManager->CheckBreakpoint<accessWidth>(operation, addressInfo, false);
	if(breakpointId >= 0) {
		SleepUntilResume(sourceCpu, BreakSource::Breakpoint, &operation, breakpointId);
	}
}
template<CpuType type>
void Debugger::ProcessInterrupt(uint32_t originalPc, uint32_t currentPc, bool forNmi)
{
	if(_debuggers[(int)type].Debugger->IsStepBack()) {
		return;
	}
	_debuggers[(int)type].Debugger->ProcessInterrupt(originalPc, currentPc, forNmi);
	ProcessEvent(forNmi ? EventType::Nmi : EventType::Irq, type);
}
void Debugger::InternalProcessInterrupt(CpuType cpuType, IDebugger& dbg, StepRequest& stepRequest, AddressInfo& src, uint32_t srcAddr, AddressInfo& dest, uint32_t destAddr, AddressInfo& ret, uint32_t retAddr, uint32_t retSp, bool forNmi)
{
	dbg.GetCallstackManager()->Push(src, srcAddr, dest, destAddr, ret, retAddr, retSp, forNmi ? StackFrameFlags::Nmi : StackFrameFlags::Irq);
	dbg.GetEventManager()->AddEvent(forNmi ? DebugEventType::Nmi : DebugEventType::Irq);
	stepRequest.ProcessNmiIrq(forNmi);
}
void Debugger::ProcessEvent(EventType type, std::optional<CpuType> cpuTypeOpt)
{
	CpuType evtCpuType = cpuTypeOpt.value_or(_mainCpuType);
	_scriptManager->ProcessEvent(type, evtCpuType);
	switch(type) {
		default: break;
		case EventType::InputPolled:
			_debuggers[(int)evtCpuType].Debugger->ProcessInputOverrides(_inputOverrides);
			break;
		case EventType::StartFrame: {
			if(!_emu->IsDebuggerBlocked()) {
				_emu->GetNotificationManager()->SendNotification(ConsoleNotificationType::EventViewerRefresh, (void*)evtCpuType);
			}
			BaseEventManager* evtMgr = GetEventManager(evtCpuType);
			if(evtMgr) {
				evtMgr->ClearFrameEvents();
			}
			break;
		}
		case EventType::Reset:
			Reset();
			break;
		case EventType::StateLoaded:
			_memoryAccessCounter->ResetCounts();
			for(CpuType cpuType : _cpuTypes) {
				uint32_t pc = _debuggers[(int)cpuType].Debugger->GetProgramCounter(false);
				_debuggers[(int)cpuType].Debugger->SetProgramCounter(pc, true);
				CallstackManager* callstackManager = _debuggers[(int)cpuType].Debugger->GetCallstackManager();
				if(callstackManager) {
					callstackManager->Clear();
				}
			}
			break;
	}
}
template<CpuType type, typename T>
void Debugger::ProcessScripts(uint32_t addr, T& value, MemoryOperationType opType)
{
	MemoryOperationInfo memOp = GetDebugger<type, IDebugger>()->InstructionProgress.LastMemOperation;
	AddressInfo relAddr = { (int32_t)memOp.Address, memOp.MemType };
	_scriptManager->ProcessMemoryOperation(relAddr, value, opType, type, false);
}
template<CpuType type, typename T>
void Debugger::ProcessScripts(uint32_t addr, T& value, MemoryType memType, MemoryOperationType opType)
{
	AddressInfo relAddr = { (int32_t)addr, memType };
	_scriptManager->ProcessMemoryOperation(relAddr, value, opType, type, false);
}
void Debugger::ProcessConfigChange()
{
	for(int i = 0; i <= (int)DebugUtilities::GetLastCpuType(); i++) {
		if(_debuggers[i].Debugger) {
			_debuggers[i].Debugger->ProcessConfigChange();
		}
	}
}
void Debugger::GetTokenList(CpuType cpuType, char* tokenList)
{
	ExpressionEvaluator expEval(this, nullptr, cpuType);
	expEval.GetTokenList(tokenList);
}
int64_t Debugger::EvaluateExpression(string expression, CpuType cpuType, EvalResultType &resultType, bool useCache)
{
	MemoryOperationInfo operationInfo { 0, 0, MemoryOperationType::Read, MemoryType::None };
	AddressInfo addressInfo = { 0, MemoryType::None };
	if(useCache && _debuggers[(int)cpuType].Evaluator) {
		return _debuggers[(int)cpuType].Evaluator->Evaluate(expression, resultType, operationInfo, addressInfo);
	} else if(_debuggers[(int)cpuType].Debugger) {
		ExpressionEvaluator expEval(this, _debuggers[(int)cpuType].Debugger.get(), cpuType);
		return expEval.Evaluate(expression, resultType, operationInfo, addressInfo);
	}
	resultType = EvalResultType::Invalid;
	return 0;
}
void Debugger::Run()
{
	for(int i = 0; i <= (int)DebugUtilities::GetLastCpuType(); i++) {
		if(_debuggers[i].Debugger) {
			_debuggers[i].Debugger->ResetStepBackCache();
			_debuggers[i].Debugger->Run();
		}
	}
	_waitForBreakResume = false;
}
void Debugger::ClearPendingBreakExceptions()
{
	for(int i = 0; i <= (int)DebugUtilities::GetLastCpuType(); i++) {
		if(_debuggers[i].Debugger) {
			_debuggers[i].Debugger->GetStepRequest()->ClearException();
		}
	}
}
void Debugger::PauseOnNextFrame()
{
	switch(_mainCpuType) {
		case CpuType::Snes: Step(CpuType::Snes, 240, StepType::SpecificScanline, BreakSource::PpuStep); break;
		case CpuType::Gameboy: Step(CpuType::Gameboy, 144, StepType::SpecificScanline, BreakSource::PpuStep); break;
		case CpuType::Nes: Step(CpuType::Nes, 241, StepType::SpecificScanline, BreakSource::PpuStep); break;
		case CpuType::Pce: Step(CpuType::Pce, 243, StepType::SpecificScanline, BreakSource::PpuStep); break;
		case CpuType::Sms: Step(CpuType::Sms, 240, StepType::SpecificScanline, BreakSource::PpuStep); break;
		case CpuType::Gba: Step(CpuType::Gba, 160, StepType::SpecificScanline, BreakSource::PpuStep); break;
		case CpuType::Ws: Step(CpuType::Ws, 145, StepType::SpecificScanline, BreakSource::PpuStep); break;
	}
}
void Debugger::Step(CpuType cpuType, int32_t stepCount, StepType type, BreakSource source)
{
	DebugBreakHelper helper(this);
	IDebugger* debugger = _debuggers[(int)cpuType].Debugger.get();
	if(debugger) {
		if(type != StepType::StepBack) {
			debugger->ResetStepBackCache();
		} else {
			debugger->StepBack(stepCount);
		}
		debugger->Step(stepCount, type);
		debugger->GetStepRequest()->SetBreakSource(source, false);
	}
	for(int i = 0; i <= (int)DebugUtilities::GetLastCpuType(); i++) {
		if(_debuggers[i].Debugger && _debuggers[i].Debugger.get() != debugger) {
			_debuggers[i].Debugger->ResetStepBackCache();
			_debuggers[i].Debugger->Run();
		}
	}
	_waitForBreakResume = false;
}
bool Debugger::IsPaused()
{
	return _waitForBreakResume;
}
bool Debugger::IsExecutionStopped()
{
	return _executionStopped || _emu->IsThreadPaused();
}
bool Debugger::HasBreakRequest()
{
	return _breakRequestCount > 0;
}
void Debugger::BreakRequest(bool release)
{
	if(release) {
		_breakRequestCount--;
	} else {
		_breakRequestCount++;
	}
}
void Debugger::ResetSuspendCounter()
{
	_suspendRequestCount = 0;
}
void Debugger::SuspendDebugger(bool release)
{
	if(release) {
		if(_suspendRequestCount > 0) {
			_suspendRequestCount--;
		} else {
		#ifdef _DEBUG
		#endif
		}
	} else {
		_suspendRequestCount++;
	}
}
bool Debugger::IsDebugWindowOpened(CpuType cpuType)
{
	switch(cpuType) {
		case CpuType::Snes: return _settings->CheckDebuggerFlag(DebuggerFlags::SnesDebuggerEnabled);
		case CpuType::Spc: return _settings->CheckDebuggerFlag(DebuggerFlags::SpcDebuggerEnabled);
		case CpuType::NecDsp: return _settings->CheckDebuggerFlag(DebuggerFlags::NecDspDebuggerEnabled);
		case CpuType::Sa1: return _settings->CheckDebuggerFlag(DebuggerFlags::Sa1DebuggerEnabled);
		case CpuType::Gsu: return _settings->CheckDebuggerFlag(DebuggerFlags::GsuDebuggerEnabled);
		case CpuType::Cx4: return _settings->CheckDebuggerFlag(DebuggerFlags::Cx4DebuggerEnabled);
		case CpuType::St018: return _settings->CheckDebuggerFlag(DebuggerFlags::St018DebuggerEnabled);
		case CpuType::Gameboy: return _settings->CheckDebuggerFlag(DebuggerFlags::GbDebuggerEnabled);
		case CpuType::Nes: return _settings->CheckDebuggerFlag(DebuggerFlags::NesDebuggerEnabled);
		case CpuType::Pce: return _settings->CheckDebuggerFlag(DebuggerFlags::PceDebuggerEnabled);
		case CpuType::Sms: return _settings->CheckDebuggerFlag(DebuggerFlags::SmsDebuggerEnabled);
		case CpuType::Gba: return _settings->CheckDebuggerFlag(DebuggerFlags::GbaDebuggerEnabled);
		case CpuType::Ws: return _settings->CheckDebuggerFlag(DebuggerFlags::WsDebuggerEnabled);
	}
	return false;
}
bool Debugger::IsBreakOptionEnabled(BreakSource src)
{
	DebugConfig& cfg = _settings->GetDebugConfig();
	switch(src) {
		case BreakSource::GbDisableLcdOutsideVblank: return cfg.GbBreakOnDisableLcdOutsideVblank;
		case BreakSource::GbInvalidVramAccess: return cfg.GbBreakOnInvalidVramAccess;
		case BreakSource::GbInvalidOamAccess: return cfg.GbBreakOnInvalidOamAccess;
		case BreakSource::NesBreakOnDecayedOamRead: return cfg.NesBreakOnDecayedOamRead;
		case BreakSource::NesBreakOnPpuScrollGlitch: return cfg.NesBreakOnPpuScrollGlitch;
		case BreakSource::NesBusConflict: return cfg.NesBreakOnBusConflict;
		case BreakSource::NesBreakOnCpuCrash: return cfg.NesBreakOnCpuCrash;
		case BreakSource::NesBreakOnExtOutputMode: return cfg.NesBreakOnExtOutputMode;
		case BreakSource::NesInvalidVramAccess: return cfg.NesBreakOnInvalidVramAccess;
		case BreakSource::NesInvalidOamWrite: return cfg.NesBreakOnInvalidOamWrite;
		case BreakSource::NesDmaInputRead: return cfg.NesBreakOnDmaInputRead;
		case BreakSource::PceBreakOnInvalidVramAddress: return cfg.PceBreakOnInvalidVramAddress;
		case BreakSource::GbaInvalidOpCode: return cfg.GbaBreakOnInvalidOpCode;
		case BreakSource::GbaUnalignedMemoryAccess: return cfg.GbaBreakOnUnalignedMemAccess;
		case BreakSource::SnesInvalidPpuAccess: return cfg.SnesBreakOnInvalidPpuAccess;
		case BreakSource::SnesReadDuringAutoJoy: return cfg.SnesBreakOnReadDuringAutoJoy;
	}
	return true;
}
void Debugger::BreakImmediately(CpuType sourceCpu, BreakSource source)
{
	if(_debuggers[(int)sourceCpu].Debugger->IsStepBack()) {
		return;
	}
	if(IsDebugWindowOpened(sourceCpu) && IsBreakOptionEnabled(source)) {
		SleepUntilResume(sourceCpu, source);
	}
}
void Debugger::GetCpuState(BaseState &dstState, CpuType cpuType)
{
	BaseState& srcState = GetCpuStateRef(cpuType);
	switch(cpuType) {
		case CpuType::Snes: memcpy(&dstState, &srcState, sizeof(SnesCpuState)); break;
		case CpuType::Spc: memcpy(&dstState, &srcState, sizeof(SpcState)); break;
		case CpuType::NecDsp: memcpy(&dstState, &srcState, sizeof(NecDspState)); break;
		case CpuType::Sa1: memcpy(&dstState, &srcState, sizeof(SnesCpuState)); break;
		case CpuType::Gsu: memcpy(&dstState, &srcState, sizeof(GsuState)); break;
		case CpuType::Cx4: memcpy(&dstState, &srcState, sizeof(Cx4State)); break;
		case CpuType::St018: memcpy(&dstState, &srcState, sizeof(ArmV3CpuState)); break;
		case CpuType::Gameboy: memcpy(&dstState, &srcState, sizeof(GbCpuState)); break;
		case CpuType::Nes: memcpy(&dstState, &srcState, sizeof(NesCpuState)); break;
		case CpuType::Pce: memcpy(&dstState, &srcState, sizeof(PceCpuState)); break;
		case CpuType::Sms: memcpy(&dstState, &srcState, sizeof(SmsCpuState)); break;
		case CpuType::Gba: memcpy(&dstState, &srcState, sizeof(GbaCpuState)); break;
		case CpuType::Ws: memcpy(&dstState, &srcState, sizeof(WsCpuState)); break;
	}
}
void Debugger::SetCpuState(BaseState& srcState, CpuType cpuType)
{
	DebugBreakHelper helper(this);
	BaseState& dstState = GetCpuStateRef(cpuType);
	switch(cpuType) {
		case CpuType::Snes: memcpy(&dstState, &srcState, sizeof(SnesCpuState)); break;
		case CpuType::Spc: memcpy(&dstState, &srcState, sizeof(SpcState)); break;
		case CpuType::NecDsp: memcpy(&dstState, &srcState, sizeof(NecDspState)); break;
		case CpuType::Sa1: memcpy(&dstState, &srcState, sizeof(SnesCpuState)); break;
		case CpuType::Gsu: memcpy(&dstState, &srcState, sizeof(GsuState)); break;
		case CpuType::Cx4: memcpy(&dstState, &srcState, sizeof(Cx4State)); break;
		case CpuType::St018: memcpy(&dstState, &srcState, sizeof(ArmV3CpuState)); break;
		case CpuType::Gameboy: memcpy(&dstState, &srcState, sizeof(GbCpuState)); break;
		case CpuType::Nes: memcpy(&dstState, &srcState, sizeof(NesCpuState)); break;
		case CpuType::Pce: memcpy(&dstState, &srcState, sizeof(PceCpuState)); break;
		case CpuType::Sms: memcpy(&dstState, &srcState, sizeof(SmsCpuState)); break;
		case CpuType::Gba: memcpy(&dstState, &srcState, sizeof(GbaCpuState)); break;
		case CpuType::Ws: memcpy(&dstState, &srcState, sizeof(WsCpuState)); break;
	}
}
BaseState& Debugger::GetCpuStateRef(CpuType cpuType)
{
	return _debuggers[(int)cpuType].Debugger->GetState();
}
void Debugger::GetPpuState(BaseState& state, CpuType cpuType)
{
	switch(cpuType) {
		case CpuType::Snes:
		case CpuType::Spc:
		case CpuType::NecDsp:
		case CpuType::Sa1:
		case CpuType::Gsu:
		case CpuType::Cx4:
		case CpuType::St018: {
			GetDebugger<CpuType::Snes, SnesDebugger>()->GetPpuState(state);
			break;
		}
		case CpuType::Gameboy: {
			GetDebugger<CpuType::Gameboy, GbDebugger>()->GetPpuState(state);
			break;
		}
		case CpuType::Nes: {
			GetDebugger<CpuType::Nes, NesDebugger>()->GetPpuState(state);
			break;
		}
		case CpuType::Pce: {
			GetDebugger<CpuType::Pce, PceDebugger>()->GetPpuState(state);
			break;
		}
		case CpuType::Sms: {
			GetDebugger<CpuType::Sms, SmsDebugger>()->GetPpuState(state);
			break;
		}
		case CpuType::Gba: {
			GetDebugger<CpuType::Gba, GbaDebugger>()->GetPpuState(state);
			break;
		}
		case CpuType::Ws: {
			GetDebugger<CpuType::Ws, WsDebugger>()->GetPpuState(state);
			break;
		}
	}
}
void Debugger::SetPpuState(BaseState& state, CpuType cpuType)
{
	DebugBreakHelper helper(this);
	switch(cpuType) {
		case CpuType::Snes:
		case CpuType::Spc:
		case CpuType::NecDsp:
		case CpuType::Sa1:
		case CpuType::Gsu:
		case CpuType::Cx4:
		case CpuType::St018: {
			GetDebugger<CpuType::Snes, SnesDebugger>()->SetPpuState(state);
			break;
		}
		case CpuType::Gameboy: {
			GetDebugger<CpuType::Gameboy, GbDebugger>()->SetPpuState(state);
			break;
		}
		case CpuType::Nes: {
			GetDebugger<CpuType::Nes, NesDebugger>()->SetPpuState(state);
			break;
		}
		case CpuType::Pce: {
			GetDebugger<CpuType::Pce, PceDebugger>()->SetPpuState(state);
			break;
		}
		case CpuType::Sms: {
			GetDebugger<CpuType::Sms, SmsDebugger>()->SetPpuState(state);
			break;
		}
		case CpuType::Gba: {
			GetDebugger<CpuType::Gba, GbaDebugger>()->SetPpuState(state);
			break;
		}
		case CpuType::Ws: {
			GetDebugger<CpuType::Ws, WsDebugger>()->SetPpuState(state);
			break;
		}
	}
}
void Debugger::GetConsoleState(BaseState& state, ConsoleType consoleType)
{
	_console->GetConsoleState(state, consoleType);
}
DebuggerFeatures Debugger::GetDebuggerFeatures(CpuType cpuType)
{
	if(_debuggers[(int)cpuType].Debugger) {
		return _debuggers[(int)cpuType].Debugger->GetSupportedFeatures();
	}
	return {};
}
void Debugger::SetProgramCounter(CpuType cpuType, uint32_t addr)
{
	if(_debuggers[(int)cpuType].Debugger->AllowChangeProgramCounter) {
		_debuggers[(int)cpuType].Debugger->SetProgramCounter(addr);
	}
}
uint32_t Debugger::GetProgramCounter(CpuType cpuType, bool getInstPc)
{
	return _debuggers[(int)cpuType].Debugger->GetProgramCounter(getInstPc);
}
uint8_t Debugger::GetCpuFlags(CpuType cpuType, uint32_t addr)
{
	return _debuggers[(int)cpuType].Debugger->GetCpuFlags(addr);
}
CpuInstructionProgress Debugger::GetInstructionProgress(CpuType cpuType)
{
	CpuInstructionProgress progress = _debuggers[(int)cpuType].Debugger->InstructionProgress;
	progress.CurrentCycle = _debuggers[(int)cpuType].Debugger->GetCpuCycleCount();
	return progress;
}
AddressInfo Debugger::GetAbsoluteAddress(AddressInfo relAddress)
{
	return _console->GetAbsoluteAddress(relAddress);
}
AddressInfo Debugger::GetRelativeAddress(AddressInfo absAddress, CpuType cpuType)
{
	return _console->GetRelativeAddress(absAddress, cpuType);
}
bool Debugger::HasCpuType(CpuType cpuType)
{
	return _cpuTypes.find(cpuType) != _cpuTypes.end();
}
void Debugger::SetBreakpoints(Breakpoint breakpoints[], uint32_t length)
{
	DebugBreakHelper helper(this);
	for(int i = 0; i <= (int)DebugUtilities::GetLastCpuType(); i++) {
		if(_debuggers[i].Debugger) {
			_debuggers[i].Debugger->GetBreakpointManager()->SetBreakpoints(breakpoints, length);
		}
	}
}
void Debugger::SetInputOverrides(uint32_t index, DebugControllerState state)
{
	_inputOverrides[index] = state;
}
void Debugger::GetAvailableInputOverrides(uint8_t* availableIndexes)
{
	BaseControlManager* controlManager = _console->GetControlManager();
	for(int i = 0; i < 8; i++) {
		availableIndexes[i] = controlManager->GetControlDeviceByIndex(i) != nullptr;
	}
}
void Debugger::Log(string message)
{
	auto lock = _logLock.AcquireSafe();
	if(_debuggerLog.size() >= 1000) {
		_debuggerLog.pop_front();
	}
	_debuggerLog.push_back(message);
	std::cout << message << std::endl;
}
string Debugger::GetLog()
{
	auto lock = _logLock.AcquireSafe();
	stringstream ss;
	for(string& msg : _debuggerLog) {
		ss << msg << "\n";
	}
	return ss.str();
}
bool Debugger::SaveRomToDisk(string filename, bool saveAsIps, CdlStripOption stripOption)
{
	switch(_mainCpuType) {
		case CpuType::Snes:
			if(_debuggers[(int)CpuType::Gameboy].Debugger) {
				return GetDebugger<CpuType::Gameboy, GbDebugger>()->SaveRomToDisk(filename, saveAsIps, stripOption);
			} else {
				return GetDebugger<CpuType::Snes, SnesDebugger>()->SaveRomToDisk(filename, saveAsIps, stripOption);
			}
		case CpuType::Gameboy: return GetDebugger<CpuType::Gameboy, GbDebugger>()->SaveRomToDisk(filename, saveAsIps, stripOption);
		case CpuType::Nes: return GetDebugger<CpuType::Nes, NesDebugger>()->SaveRomToDisk(filename, saveAsIps, stripOption);
		case CpuType::Pce: return GetDebugger<CpuType::Pce, PceDebugger>()->SaveRomToDisk(filename, saveAsIps, stripOption);
		case CpuType::Sms: return GetDebugger<CpuType::Sms, SmsDebugger>()->SaveRomToDisk(filename, saveAsIps, stripOption);
		case CpuType::Gba: return GetDebugger<CpuType::Gba, GbaDebugger>()->SaveRomToDisk(filename, saveAsIps, stripOption);
		case CpuType::Ws: return GetDebugger<CpuType::Ws, WsDebugger>()->SaveRomToDisk(filename, saveAsIps, stripOption);
	}
	return false;
}
FrozenAddressManager* Debugger::GetFrozenAddressManager(CpuType cpuType)
{
	if(_debuggers[(int)cpuType].Debugger) {
		return &_debuggers[(int)cpuType].Debugger->GetFrozenAddressManager();
	}
	return nullptr;
}
ITraceLogger* Debugger::GetTraceLogger(CpuType cpuType)
{
	if(_debuggers[(int)cpuType].Debugger) {
		return _debuggers[(int)cpuType].Debugger->GetTraceLogger();
	}
	return nullptr;
}
void Debugger::ClearExecutionTrace()
{
	DebugBreakHelper helper(this);
	for(CpuType cpuType : _cpuTypes) {
		ITraceLogger* logger = GetTraceLogger(cpuType);
		logger->Clear();
	}
}
uint32_t Debugger::GetExecutionTrace(TraceRow output[], uint32_t startOffset, uint32_t maxLineCount)
{
	DebugBreakHelper helper(this);
	uint32_t offsetsByCpu[(int)DebugUtilities::GetLastCpuType() + 1] = {};
	uint32_t count = 0;
	int64_t lastRowId = ITraceLogger::NextRowId;
	while(count < maxLineCount) {
		bool added = false;
		for(CpuType cpuType : _cpuTypes) {
			ITraceLogger* logger = GetTraceLogger(cpuType);
			if(logger) {
				uint32_t& offset = offsetsByCpu[(int)cpuType];
				int64_t rowId = logger->GetRowId(offset);
				if(rowId == -1 || rowId != lastRowId - 1) {
					continue;
				}
				lastRowId = rowId;
				if(startOffset > 0) {
					startOffset--;
				} else {
					if(logger->IsEnabled()) {
						if(output) {
							logger->GetExecutionTrace(output[count], offset);
						}
						count++;
					}
				}
				offset++;
				added = true;
				break;
			}
		}
		if(!added) {
			break;
		}
	}
	return count;
}
PpuTools* Debugger::GetPpuTools(CpuType cpuType)
{
	if(_debuggers[(int)cpuType].Debugger) {
		return _debuggers[(int)cpuType].Debugger->GetPpuTools();
	}
	return nullptr;
}
BaseEventManager* Debugger::GetEventManager(CpuType cpuType)
{
	if(_debuggers[(int)cpuType].Debugger) {
		return _debuggers[(int)cpuType].Debugger->GetEventManager();
	}
	return nullptr;
}
CallstackManager* Debugger::GetCallstackManager(CpuType cpuType)
{
	if(_debuggers[(int)cpuType].Debugger) {
		return _debuggers[(int)cpuType].Debugger->GetCallstackManager();
	}
	return nullptr;
}
IAssembler* Debugger::GetAssembler(CpuType cpuType)
{
	if(_debuggers[(int)cpuType].Debugger) {
		return _debuggers[(int)cpuType].Debugger->GetAssembler();
	}
	return nullptr;
}
template void Debugger::ProcessInstruction<CpuType::Snes>();
template void Debugger::ProcessInstruction<CpuType::Sa1>();
template void Debugger::ProcessInstruction<CpuType::Spc>();
template void Debugger::ProcessInstruction<CpuType::Gsu>();
template void Debugger::ProcessInstruction<CpuType::NecDsp>();
template void Debugger::ProcessInstruction<CpuType::Cx4>();
template void Debugger::ProcessInstruction<CpuType::St018>();
template void Debugger::ProcessInstruction<CpuType::Gameboy>();
template void Debugger::ProcessInstruction<CpuType::Nes>();
template void Debugger::ProcessInstruction<CpuType::Pce>();
template void Debugger::ProcessInstruction<CpuType::Sms>();
template void Debugger::ProcessInstruction<CpuType::Gba>();
template void Debugger::ProcessInstruction<CpuType::Ws>();
template void Debugger::ProcessMemoryRead<CpuType::Snes>(uint32_t addr, uint8_t& value, MemoryOperationType opType);
template void Debugger::ProcessMemoryRead<CpuType::Sa1>(uint32_t addr, uint8_t& value, MemoryOperationType opType);
template void Debugger::ProcessMemoryRead<CpuType::Spc>(uint32_t addr, uint8_t& value, MemoryOperationType opType);
template void Debugger::ProcessMemoryRead<CpuType::Spc, 1, MemoryAccessFlags::DspAccess>(uint32_t addr, uint8_t& value, MemoryOperationType opType);
template void Debugger::ProcessMemoryRead<CpuType::Gsu>(uint32_t addr, uint8_t& value, MemoryOperationType opType);
template void Debugger::ProcessMemoryRead<CpuType::NecDsp>(uint32_t addr, uint32_t& value, MemoryOperationType opType);
template void Debugger::ProcessMemoryRead<CpuType::NecDsp>(uint32_t addr, uint16_t& value, MemoryOperationType opType);
template void Debugger::ProcessMemoryRead<CpuType::Cx4>(uint32_t addr, uint8_t& value, MemoryOperationType opType);
template void Debugger::ProcessMemoryRead<CpuType::St018, 1>(uint32_t addr, uint32_t& value, MemoryOperationType opType);
template void Debugger::ProcessMemoryRead<CpuType::St018, 4>(uint32_t addr, uint32_t& value, MemoryOperationType opType);
template void Debugger::ProcessMemoryRead<CpuType::Gameboy>(uint32_t addr, uint8_t& value, MemoryOperationType opType);
template void Debugger::ProcessMemoryRead<CpuType::Nes>(uint32_t addr, uint8_t& value, MemoryOperationType opType);
template void Debugger::ProcessMemoryRead<CpuType::Pce>(uint32_t addr, uint8_t& value, MemoryOperationType opType);
template void Debugger::ProcessMemoryRead<CpuType::Sms>(uint32_t addr, uint8_t& value, MemoryOperationType opType);
template void Debugger::ProcessMemoryRead<CpuType::Gba, 1>(uint32_t addr, uint32_t& value, MemoryOperationType opType);
template void Debugger::ProcessMemoryRead<CpuType::Gba, 2>(uint32_t addr, uint32_t& value, MemoryOperationType opType);
template void Debugger::ProcessMemoryRead<CpuType::Gba, 4>(uint32_t addr, uint32_t& value, MemoryOperationType opType);
template void Debugger::ProcessMemoryRead<CpuType::Ws, 1>(uint32_t addr, uint8_t& value, MemoryOperationType opType);
template void Debugger::ProcessMemoryRead<CpuType::Ws, 2>(uint32_t addr, uint16_t& value, MemoryOperationType opType);
template bool Debugger::ProcessMemoryWrite<CpuType::Snes>(uint32_t addr, uint8_t& value, MemoryOperationType opType);
template bool Debugger::ProcessMemoryWrite<CpuType::Sa1>(uint32_t addr, uint8_t& value, MemoryOperationType opType);
template bool Debugger::ProcessMemoryWrite<CpuType::Spc>(uint32_t addr, uint8_t& value, MemoryOperationType opType);
template bool Debugger::ProcessMemoryWrite<CpuType::Spc, 1, MemoryAccessFlags::DspAccess>(uint32_t addr, uint8_t& value, MemoryOperationType opType);
template bool Debugger::ProcessMemoryWrite<CpuType::Gsu>(uint32_t addr, uint8_t& value, MemoryOperationType opType);
template bool Debugger::ProcessMemoryWrite<CpuType::NecDsp>(uint32_t addr, uint16_t& value, MemoryOperationType opType);
template bool Debugger::ProcessMemoryWrite<CpuType::Cx4>(uint32_t addr, uint8_t& value, MemoryOperationType opType);
template bool Debugger::ProcessMemoryWrite<CpuType::St018, 1>(uint32_t addr, uint32_t& value, MemoryOperationType opType);
template bool Debugger::ProcessMemoryWrite<CpuType::St018, 4>(uint32_t addr, uint32_t& value, MemoryOperationType opType);
template bool Debugger::ProcessMemoryWrite<CpuType::Gameboy>(uint32_t addr, uint8_t& value, MemoryOperationType opType);
template bool Debugger::ProcessMemoryWrite<CpuType::Nes>(uint32_t addr, uint8_t& value, MemoryOperationType opType);
template bool Debugger::ProcessMemoryWrite<CpuType::Pce>(uint32_t addr, uint8_t& value, MemoryOperationType opType);
template bool Debugger::ProcessMemoryWrite<CpuType::Sms>(uint32_t addr, uint8_t& value, MemoryOperationType opType);
template bool Debugger::ProcessMemoryWrite<CpuType::Gba, 1>(uint32_t addr, uint32_t& value, MemoryOperationType opType);
template bool Debugger::ProcessMemoryWrite<CpuType::Gba, 2>(uint32_t addr, uint32_t& value, MemoryOperationType opType);
template bool Debugger::ProcessMemoryWrite<CpuType::Gba, 4>(uint32_t addr, uint32_t& value, MemoryOperationType opType);
template bool Debugger::ProcessMemoryWrite<CpuType::Ws, 1>(uint32_t addr, uint8_t& value, MemoryOperationType opType);
template bool Debugger::ProcessMemoryWrite<CpuType::Ws, 2>(uint32_t addr, uint16_t& value, MemoryOperationType opType);
template void Debugger::ProcessMemoryAccess<CpuType::Pce, MemoryType::PceAdpcmRam, MemoryOperationType::Write>(uint32_t addr, uint8_t& value);
template void Debugger::ProcessMemoryAccess<CpuType::Pce, MemoryType::PceAdpcmRam, MemoryOperationType::Read>(uint32_t addr, uint8_t& value);
template void Debugger::ProcessMemoryAccess<CpuType::Pce, MemoryType::PceArcadeCardRam, MemoryOperationType::Write>(uint32_t addr, uint8_t& value);
template void Debugger::ProcessMemoryAccess<CpuType::Pce, MemoryType::PceArcadeCardRam, MemoryOperationType::Read>(uint32_t addr, uint8_t& value);
template void Debugger::ProcessMemoryAccess<CpuType::Sms, MemoryType::SmsPort, MemoryOperationType::Write>(uint32_t addr, uint8_t& value);
template void Debugger::ProcessMemoryAccess<CpuType::Sms, MemoryType::SmsPort, MemoryOperationType::Read>(uint32_t addr, uint8_t& value);
template void Debugger::ProcessMemoryAccess<CpuType::Ws, MemoryType::WsPort, MemoryOperationType::Write>(uint32_t addr, uint8_t& value);
template void Debugger::ProcessMemoryAccess<CpuType::Ws, MemoryType::WsPort, MemoryOperationType::Read>(uint32_t addr, uint8_t& value);
template void Debugger::ProcessMemoryAccess<CpuType::Ws, MemoryType::WsPort, MemoryOperationType::Write>(uint32_t addr, uint16_t& value);
template void Debugger::ProcessMemoryAccess<CpuType::Ws, MemoryType::WsPort, MemoryOperationType::Read>(uint32_t addr, uint16_t& value);
template void Debugger::ProcessMemoryAccess<CpuType::Ws, MemoryType::WsInternalEeprom, MemoryOperationType::Read>(uint32_t addr, uint16_t& value);
template void Debugger::ProcessMemoryAccess<CpuType::Ws, MemoryType::WsInternalEeprom, MemoryOperationType::Write>(uint32_t addr, uint16_t& value);
template void Debugger::ProcessMemoryAccess<CpuType::Ws, MemoryType::WsCartEeprom, MemoryOperationType::Read>(uint32_t addr, uint16_t& value);
template void Debugger::ProcessMemoryAccess<CpuType::Ws, MemoryType::WsCartEeprom, MemoryOperationType::Write>(uint32_t addr, uint16_t& value);
template void Debugger::ProcessIdleCycle<CpuType::Snes>();
template void Debugger::ProcessIdleCycle<CpuType::Sa1>();
template void Debugger::ProcessIdleCycle<CpuType::Pce>();
template void Debugger::ProcessHaltedCpu<CpuType::Snes>();
template void Debugger::ProcessHaltedCpu<CpuType::Spc>();
template void Debugger::ProcessHaltedCpu<CpuType::Gameboy>();
template void Debugger::ProcessHaltedCpu<CpuType::Sms>();
template void Debugger::ProcessHaltedCpu<CpuType::Gba>();
template void Debugger::ProcessHaltedCpu<CpuType::Ws>();
template void Debugger::ProcessInterrupt<CpuType::Snes>(uint32_t originalPc, uint32_t currentPc, bool forNmi);
template void Debugger::ProcessInterrupt<CpuType::Sa1>(uint32_t originalPc, uint32_t currentPc, bool forNmi);
template void Debugger::ProcessInterrupt<CpuType::Gameboy>(uint32_t originalPc, uint32_t currentPc, bool forNmi);
template void Debugger::ProcessInterrupt<CpuType::Nes>(uint32_t originalPc, uint32_t currentPc, bool forNmi);
template void Debugger::ProcessInterrupt<CpuType::Pce>(uint32_t originalPc, uint32_t currentPc, bool forNmi);
template void Debugger::ProcessInterrupt<CpuType::Sms>(uint32_t originalPc, uint32_t currentPc, bool forNmi);
template void Debugger::ProcessInterrupt<CpuType::Gba>(uint32_t originalPc, uint32_t currentPc, bool forNmi);
template void Debugger::ProcessInterrupt<CpuType::Ws>(uint32_t originalPc, uint32_t currentPc, bool forNmi);
template void Debugger::ProcessPpuRead<CpuType::Snes>(uint16_t addr, uint8_t& value, MemoryType memoryType, MemoryOperationType opType);
template void Debugger::ProcessPpuRead<CpuType::Gameboy>(uint16_t addr, uint8_t& value, MemoryType memoryType, MemoryOperationType opType);
template void Debugger::ProcessPpuRead<CpuType::Nes>(uint16_t addr, uint8_t& value, MemoryType memoryType, MemoryOperationType opType);
template void Debugger::ProcessPpuRead<CpuType::Pce>(uint16_t addr, uint16_t& value, MemoryType memoryType, MemoryOperationType opType);
template void Debugger::ProcessPpuRead<CpuType::Pce>(uint16_t addr, uint8_t& value, MemoryType memoryType, MemoryOperationType opType);
template void Debugger::ProcessPpuRead<CpuType::Sms>(uint16_t addr, uint8_t& value, MemoryType memoryType, MemoryOperationType opType);
template void Debugger::ProcessPpuWrite<CpuType::Snes>(uint16_t addr, uint8_t& value, MemoryType memoryType);
template void Debugger::ProcessPpuWrite<CpuType::Gameboy>(uint16_t addr, uint8_t& value, MemoryType memoryType);
template void Debugger::ProcessPpuWrite<CpuType::Nes>(uint16_t addr, uint8_t& value, MemoryType memoryType);
template void Debugger::ProcessPpuWrite<CpuType::Pce>(uint16_t addr, uint16_t& value, MemoryType memoryType);
template void Debugger::ProcessPpuWrite<CpuType::Pce>(uint16_t addr, uint8_t& value, MemoryType memoryType);
template void Debugger::ProcessPpuWrite<CpuType::Sms>(uint16_t addr, uint8_t& value, MemoryType memoryType);
template void Debugger::ProcessPpuCycle<CpuType::Snes>();
template void Debugger::ProcessPpuCycle<CpuType::Gameboy>();
template void Debugger::ProcessPpuCycle<CpuType::Nes>();
template void Debugger::ProcessPpuCycle<CpuType::Pce>();
template void Debugger::ProcessPpuCycle<CpuType::Sms>();
template void Debugger::ProcessPpuCycle<CpuType::Gba>();
template void Debugger::ProcessPpuCycle<CpuType::Ws>();
template void Debugger::ProcessBreakConditions<1>(CpuType sourceCpu, StepRequest& step, BreakpointManager* bpManager, MemoryOperationInfo& operation, AddressInfo& addressInfo);
template void Debugger::ProcessBreakConditions<2>(CpuType sourceCpu, StepRequest& step, BreakpointManager* bpManager, MemoryOperationInfo& operation, AddressInfo& addressInfo);
template void Debugger::ProcessBreakConditions<4>(CpuType sourceCpu, StepRequest& step, BreakpointManager* bpManager, MemoryOperationInfo& operation, AddressInfo& addressInfo);
template void Debugger::ProcessPredictiveBreakpoint<1>(CpuType sourceCpu, BreakpointManager* bpManager, MemoryOperationInfo& operation, AddressInfo& addressInfo);
template void Debugger::ProcessPredictiveBreakpoint<2>(CpuType sourceCpu, BreakpointManager* bpManager, MemoryOperationInfo& operation, AddressInfo& addressInfo);
template void Debugger::ProcessPredictiveBreakpoint<4>(CpuType sourceCpu, BreakpointManager* bpManager, MemoryOperationInfo& operation, AddressInfo& addressInfo);
```
